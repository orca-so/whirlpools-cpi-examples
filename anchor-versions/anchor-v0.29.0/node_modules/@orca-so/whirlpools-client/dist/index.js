// src/generated/accounts/feeTier.ts
import {
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  getU16Decoder,
  getU16Encoder,
  transformEncoder
} from "@solana/web3.js";
var FEE_TIER_DISCRIMINATOR = new Uint8Array([
  56,
  75,
  159,
  76,
  142,
  68,
  190,
  105
]);
function getFeeTierDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(FEE_TIER_DISCRIMINATOR);
}
function getFeeTierEncoder() {
  return transformEncoder(
    getStructEncoder([
      ["discriminator", fixEncoderSize(getBytesEncoder(), 8)],
      ["whirlpoolsConfig", getAddressEncoder()],
      ["tickSpacing", getU16Encoder()],
      ["defaultFeeRate", getU16Encoder()]
    ]),
    (value) => ({ ...value, discriminator: FEE_TIER_DISCRIMINATOR })
  );
}
function getFeeTierDecoder() {
  return getStructDecoder([
    ["discriminator", fixDecoderSize(getBytesDecoder(), 8)],
    ["whirlpoolsConfig", getAddressDecoder()],
    ["tickSpacing", getU16Decoder()],
    ["defaultFeeRate", getU16Decoder()]
  ]);
}
function getFeeTierCodec() {
  return combineCodec(getFeeTierEncoder(), getFeeTierDecoder());
}
function decodeFeeTier(encodedAccount) {
  return decodeAccount(
    encodedAccount,
    getFeeTierDecoder()
  );
}
async function fetchFeeTier(rpc, address, config) {
  const maybeAccount = await fetchMaybeFeeTier(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeFeeTier(rpc, address, config) {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodeFeeTier(maybeAccount);
}
async function fetchAllFeeTier(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeFeeTier(rpc, addresses, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeFeeTier(rpc, addresses, config) {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeFeeTier(maybeAccount));
}
function getFeeTierSize() {
  return 44;
}

// src/generated/accounts/position.ts
import {
  assertAccountExists as assertAccountExists2,
  assertAccountsExist as assertAccountsExist2,
  combineCodec as combineCodec8,
  decodeAccount as decodeAccount2,
  fetchEncodedAccount as fetchEncodedAccount2,
  fetchEncodedAccounts as fetchEncodedAccounts2,
  fixDecoderSize as fixDecoderSize2,
  fixEncoderSize as fixEncoderSize2,
  getAddressDecoder as getAddressDecoder3,
  getAddressEncoder as getAddressEncoder3,
  getArrayDecoder as getArrayDecoder3,
  getArrayEncoder as getArrayEncoder3,
  getBytesDecoder as getBytesDecoder2,
  getBytesEncoder as getBytesEncoder2,
  getI32Decoder,
  getI32Encoder,
  getStructDecoder as getStructDecoder7,
  getStructEncoder as getStructEncoder7,
  getU128Decoder as getU128Decoder4,
  getU128Encoder as getU128Encoder4,
  getU64Decoder as getU64Decoder2,
  getU64Encoder as getU64Encoder2,
  transformEncoder as transformEncoder2
} from "@solana/web3.js";

// src/generated/types/accountsType.ts
import {
  combineCodec as combineCodec2,
  getEnumDecoder,
  getEnumEncoder
} from "@solana/web3.js";
var AccountsType = /* @__PURE__ */ ((AccountsType2) => {
  AccountsType2[AccountsType2["TransferHookA"] = 0] = "TransferHookA";
  AccountsType2[AccountsType2["TransferHookB"] = 1] = "TransferHookB";
  AccountsType2[AccountsType2["TransferHookReward"] = 2] = "TransferHookReward";
  AccountsType2[AccountsType2["TransferHookInput"] = 3] = "TransferHookInput";
  AccountsType2[AccountsType2["TransferHookIntermediate"] = 4] = "TransferHookIntermediate";
  AccountsType2[AccountsType2["TransferHookOutput"] = 5] = "TransferHookOutput";
  AccountsType2[AccountsType2["SupplementalTickArrays"] = 6] = "SupplementalTickArrays";
  AccountsType2[AccountsType2["SupplementalTickArraysOne"] = 7] = "SupplementalTickArraysOne";
  AccountsType2[AccountsType2["SupplementalTickArraysTwo"] = 8] = "SupplementalTickArraysTwo";
  return AccountsType2;
})(AccountsType || {});
function getAccountsTypeEncoder() {
  return getEnumEncoder(AccountsType);
}
function getAccountsTypeDecoder() {
  return getEnumDecoder(AccountsType);
}
function getAccountsTypeCodec() {
  return combineCodec2(getAccountsTypeEncoder(), getAccountsTypeDecoder());
}

// src/generated/types/positionRewardInfo.ts
import {
  combineCodec as combineCodec3,
  getStructDecoder as getStructDecoder2,
  getStructEncoder as getStructEncoder2,
  getU128Decoder,
  getU128Encoder,
  getU64Decoder,
  getU64Encoder
} from "@solana/web3.js";
function getPositionRewardInfoEncoder() {
  return getStructEncoder2([
    ["growthInsideCheckpoint", getU128Encoder()],
    ["amountOwed", getU64Encoder()]
  ]);
}
function getPositionRewardInfoDecoder() {
  return getStructDecoder2([
    ["growthInsideCheckpoint", getU128Decoder()],
    ["amountOwed", getU64Decoder()]
  ]);
}
function getPositionRewardInfoCodec() {
  return combineCodec3(
    getPositionRewardInfoEncoder(),
    getPositionRewardInfoDecoder()
  );
}

// src/generated/types/remainingAccountsInfo.ts
import {
  combineCodec as combineCodec4,
  getArrayDecoder,
  getArrayEncoder,
  getStructDecoder as getStructDecoder3,
  getStructEncoder as getStructEncoder3
} from "@solana/web3.js";
function getRemainingAccountsInfoEncoder() {
  return getStructEncoder3([
    ["slices", getArrayEncoder(getRemainingAccountsSliceEncoder())]
  ]);
}
function getRemainingAccountsInfoDecoder() {
  return getStructDecoder3([
    ["slices", getArrayDecoder(getRemainingAccountsSliceDecoder())]
  ]);
}
function getRemainingAccountsInfoCodec() {
  return combineCodec4(
    getRemainingAccountsInfoEncoder(),
    getRemainingAccountsInfoDecoder()
  );
}

// src/generated/types/remainingAccountsSlice.ts
import {
  combineCodec as combineCodec5,
  getStructDecoder as getStructDecoder4,
  getStructEncoder as getStructEncoder4,
  getU8Decoder,
  getU8Encoder
} from "@solana/web3.js";
function getRemainingAccountsSliceEncoder() {
  return getStructEncoder4([
    ["accountsType", getAccountsTypeEncoder()],
    ["length", getU8Encoder()]
  ]);
}
function getRemainingAccountsSliceDecoder() {
  return getStructDecoder4([
    ["accountsType", getAccountsTypeDecoder()],
    ["length", getU8Decoder()]
  ]);
}
function getRemainingAccountsSliceCodec() {
  return combineCodec5(
    getRemainingAccountsSliceEncoder(),
    getRemainingAccountsSliceDecoder()
  );
}

// src/generated/types/tick.ts
import {
  combineCodec as combineCodec6,
  getArrayDecoder as getArrayDecoder2,
  getArrayEncoder as getArrayEncoder2,
  getBooleanDecoder,
  getBooleanEncoder,
  getI128Decoder,
  getI128Encoder,
  getStructDecoder as getStructDecoder5,
  getStructEncoder as getStructEncoder5,
  getU128Decoder as getU128Decoder2,
  getU128Encoder as getU128Encoder2
} from "@solana/web3.js";
function getTickEncoder() {
  return getStructEncoder5([
    ["initialized", getBooleanEncoder()],
    ["liquidityNet", getI128Encoder()],
    ["liquidityGross", getU128Encoder2()],
    ["feeGrowthOutsideA", getU128Encoder2()],
    ["feeGrowthOutsideB", getU128Encoder2()],
    ["rewardGrowthsOutside", getArrayEncoder2(getU128Encoder2(), { size: 3 })]
  ]);
}
function getTickDecoder() {
  return getStructDecoder5([
    ["initialized", getBooleanDecoder()],
    ["liquidityNet", getI128Decoder()],
    ["liquidityGross", getU128Decoder2()],
    ["feeGrowthOutsideA", getU128Decoder2()],
    ["feeGrowthOutsideB", getU128Decoder2()],
    ["rewardGrowthsOutside", getArrayDecoder2(getU128Decoder2(), { size: 3 })]
  ]);
}
function getTickCodec() {
  return combineCodec6(getTickEncoder(), getTickDecoder());
}

// src/generated/types/whirlpoolRewardInfo.ts
import {
  combineCodec as combineCodec7,
  getAddressDecoder as getAddressDecoder2,
  getAddressEncoder as getAddressEncoder2,
  getStructDecoder as getStructDecoder6,
  getStructEncoder as getStructEncoder6,
  getU128Decoder as getU128Decoder3,
  getU128Encoder as getU128Encoder3
} from "@solana/web3.js";
function getWhirlpoolRewardInfoEncoder() {
  return getStructEncoder6([
    ["mint", getAddressEncoder2()],
    ["vault", getAddressEncoder2()],
    ["authority", getAddressEncoder2()],
    ["emissionsPerSecondX64", getU128Encoder3()],
    ["growthGlobalX64", getU128Encoder3()]
  ]);
}
function getWhirlpoolRewardInfoDecoder() {
  return getStructDecoder6([
    ["mint", getAddressDecoder2()],
    ["vault", getAddressDecoder2()],
    ["authority", getAddressDecoder2()],
    ["emissionsPerSecondX64", getU128Decoder3()],
    ["growthGlobalX64", getU128Decoder3()]
  ]);
}
function getWhirlpoolRewardInfoCodec() {
  return combineCodec7(
    getWhirlpoolRewardInfoEncoder(),
    getWhirlpoolRewardInfoDecoder()
  );
}

// src/generated/accounts/position.ts
var POSITION_DISCRIMINATOR = new Uint8Array([
  170,
  188,
  143,
  228,
  122,
  64,
  247,
  208
]);
function getPositionDiscriminatorBytes() {
  return fixEncoderSize2(getBytesEncoder2(), 8).encode(POSITION_DISCRIMINATOR);
}
function getPositionEncoder() {
  return transformEncoder2(
    getStructEncoder7([
      ["discriminator", fixEncoderSize2(getBytesEncoder2(), 8)],
      ["whirlpool", getAddressEncoder3()],
      ["positionMint", getAddressEncoder3()],
      ["liquidity", getU128Encoder4()],
      ["tickLowerIndex", getI32Encoder()],
      ["tickUpperIndex", getI32Encoder()],
      ["feeGrowthCheckpointA", getU128Encoder4()],
      ["feeOwedA", getU64Encoder2()],
      ["feeGrowthCheckpointB", getU128Encoder4()],
      ["feeOwedB", getU64Encoder2()],
      [
        "rewardInfos",
        getArrayEncoder3(getPositionRewardInfoEncoder(), { size: 3 })
      ]
    ]),
    (value) => ({ ...value, discriminator: POSITION_DISCRIMINATOR })
  );
}
function getPositionDecoder() {
  return getStructDecoder7([
    ["discriminator", fixDecoderSize2(getBytesDecoder2(), 8)],
    ["whirlpool", getAddressDecoder3()],
    ["positionMint", getAddressDecoder3()],
    ["liquidity", getU128Decoder4()],
    ["tickLowerIndex", getI32Decoder()],
    ["tickUpperIndex", getI32Decoder()],
    ["feeGrowthCheckpointA", getU128Decoder4()],
    ["feeOwedA", getU64Decoder2()],
    ["feeGrowthCheckpointB", getU128Decoder4()],
    ["feeOwedB", getU64Decoder2()],
    [
      "rewardInfos",
      getArrayDecoder3(getPositionRewardInfoDecoder(), { size: 3 })
    ]
  ]);
}
function getPositionCodec() {
  return combineCodec8(getPositionEncoder(), getPositionDecoder());
}
function decodePosition(encodedAccount) {
  return decodeAccount2(
    encodedAccount,
    getPositionDecoder()
  );
}
async function fetchPosition(rpc, address, config) {
  const maybeAccount = await fetchMaybePosition(rpc, address, config);
  assertAccountExists2(maybeAccount);
  return maybeAccount;
}
async function fetchMaybePosition(rpc, address, config) {
  const maybeAccount = await fetchEncodedAccount2(rpc, address, config);
  return decodePosition(maybeAccount);
}
async function fetchAllPosition(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybePosition(rpc, addresses, config);
  assertAccountsExist2(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybePosition(rpc, addresses, config) {
  const maybeAccounts = await fetchEncodedAccounts2(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodePosition(maybeAccount));
}
function getPositionSize() {
  return 216;
}

// src/generated/accounts/positionBundle.ts
import {
  assertAccountExists as assertAccountExists3,
  assertAccountsExist as assertAccountsExist3,
  combineCodec as combineCodec9,
  decodeAccount as decodeAccount3,
  fetchEncodedAccount as fetchEncodedAccount3,
  fetchEncodedAccounts as fetchEncodedAccounts3,
  fixDecoderSize as fixDecoderSize3,
  fixEncoderSize as fixEncoderSize3,
  getAddressDecoder as getAddressDecoder4,
  getAddressEncoder as getAddressEncoder4,
  getBytesDecoder as getBytesDecoder3,
  getBytesEncoder as getBytesEncoder3,
  getStructDecoder as getStructDecoder8,
  getStructEncoder as getStructEncoder8,
  transformEncoder as transformEncoder3
} from "@solana/web3.js";
var POSITION_BUNDLE_DISCRIMINATOR = new Uint8Array([
  129,
  169,
  175,
  65,
  185,
  95,
  32,
  100
]);
function getPositionBundleDiscriminatorBytes() {
  return fixEncoderSize3(getBytesEncoder3(), 8).encode(
    POSITION_BUNDLE_DISCRIMINATOR
  );
}
function getPositionBundleEncoder() {
  return transformEncoder3(
    getStructEncoder8([
      ["discriminator", fixEncoderSize3(getBytesEncoder3(), 8)],
      ["positionBundleMint", getAddressEncoder4()],
      ["positionBitmap", fixEncoderSize3(getBytesEncoder3(), 32)]
    ]),
    (value) => ({ ...value, discriminator: POSITION_BUNDLE_DISCRIMINATOR })
  );
}
function getPositionBundleDecoder() {
  return getStructDecoder8([
    ["discriminator", fixDecoderSize3(getBytesDecoder3(), 8)],
    ["positionBundleMint", getAddressDecoder4()],
    ["positionBitmap", fixDecoderSize3(getBytesDecoder3(), 32)]
  ]);
}
function getPositionBundleCodec() {
  return combineCodec9(getPositionBundleEncoder(), getPositionBundleDecoder());
}
function decodePositionBundle(encodedAccount) {
  return decodeAccount3(
    encodedAccount,
    getPositionBundleDecoder()
  );
}
async function fetchPositionBundle(rpc, address, config) {
  const maybeAccount = await fetchMaybePositionBundle(rpc, address, config);
  assertAccountExists3(maybeAccount);
  return maybeAccount;
}
async function fetchMaybePositionBundle(rpc, address, config) {
  const maybeAccount = await fetchEncodedAccount3(rpc, address, config);
  return decodePositionBundle(maybeAccount);
}
async function fetchAllPositionBundle(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybePositionBundle(
    rpc,
    addresses,
    config
  );
  assertAccountsExist3(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybePositionBundle(rpc, addresses, config) {
  const maybeAccounts = await fetchEncodedAccounts3(rpc, addresses, config);
  return maybeAccounts.map(
    (maybeAccount) => decodePositionBundle(maybeAccount)
  );
}
function getPositionBundleSize() {
  return 72;
}

// src/generated/accounts/tickArray.ts
import {
  assertAccountExists as assertAccountExists4,
  assertAccountsExist as assertAccountsExist4,
  combineCodec as combineCodec10,
  decodeAccount as decodeAccount4,
  fetchEncodedAccount as fetchEncodedAccount4,
  fetchEncodedAccounts as fetchEncodedAccounts4,
  fixDecoderSize as fixDecoderSize4,
  fixEncoderSize as fixEncoderSize4,
  getAddressDecoder as getAddressDecoder5,
  getAddressEncoder as getAddressEncoder5,
  getArrayDecoder as getArrayDecoder4,
  getArrayEncoder as getArrayEncoder4,
  getBytesDecoder as getBytesDecoder4,
  getBytesEncoder as getBytesEncoder4,
  getI32Decoder as getI32Decoder2,
  getI32Encoder as getI32Encoder2,
  getStructDecoder as getStructDecoder9,
  getStructEncoder as getStructEncoder9,
  transformEncoder as transformEncoder4
} from "@solana/web3.js";
var TICK_ARRAY_DISCRIMINATOR = new Uint8Array([
  69,
  97,
  189,
  190,
  110,
  7,
  66,
  187
]);
function getTickArrayDiscriminatorBytes() {
  return fixEncoderSize4(getBytesEncoder4(), 8).encode(TICK_ARRAY_DISCRIMINATOR);
}
function getTickArrayEncoder() {
  return transformEncoder4(
    getStructEncoder9([
      ["discriminator", fixEncoderSize4(getBytesEncoder4(), 8)],
      ["startTickIndex", getI32Encoder2()],
      ["ticks", getArrayEncoder4(getTickEncoder(), { size: 88 })],
      ["whirlpool", getAddressEncoder5()]
    ]),
    (value) => ({ ...value, discriminator: TICK_ARRAY_DISCRIMINATOR })
  );
}
function getTickArrayDecoder() {
  return getStructDecoder9([
    ["discriminator", fixDecoderSize4(getBytesDecoder4(), 8)],
    ["startTickIndex", getI32Decoder2()],
    ["ticks", getArrayDecoder4(getTickDecoder(), { size: 88 })],
    ["whirlpool", getAddressDecoder5()]
  ]);
}
function getTickArrayCodec() {
  return combineCodec10(getTickArrayEncoder(), getTickArrayDecoder());
}
function decodeTickArray(encodedAccount) {
  return decodeAccount4(
    encodedAccount,
    getTickArrayDecoder()
  );
}
async function fetchTickArray(rpc, address, config) {
  const maybeAccount = await fetchMaybeTickArray(rpc, address, config);
  assertAccountExists4(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeTickArray(rpc, address, config) {
  const maybeAccount = await fetchEncodedAccount4(rpc, address, config);
  return decodeTickArray(maybeAccount);
}
async function fetchAllTickArray(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeTickArray(rpc, addresses, config);
  assertAccountsExist4(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeTickArray(rpc, addresses, config) {
  const maybeAccounts = await fetchEncodedAccounts4(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeTickArray(maybeAccount));
}
function getTickArraySize() {
  return 9988;
}

// src/generated/accounts/tokenBadge.ts
import {
  assertAccountExists as assertAccountExists5,
  assertAccountsExist as assertAccountsExist5,
  combineCodec as combineCodec11,
  decodeAccount as decodeAccount5,
  fetchEncodedAccount as fetchEncodedAccount5,
  fetchEncodedAccounts as fetchEncodedAccounts5,
  fixDecoderSize as fixDecoderSize5,
  fixEncoderSize as fixEncoderSize5,
  getAddressDecoder as getAddressDecoder6,
  getAddressEncoder as getAddressEncoder6,
  getBytesDecoder as getBytesDecoder5,
  getBytesEncoder as getBytesEncoder5,
  getStructDecoder as getStructDecoder10,
  getStructEncoder as getStructEncoder10,
  transformEncoder as transformEncoder5
} from "@solana/web3.js";
var TOKEN_BADGE_DISCRIMINATOR = new Uint8Array([
  116,
  219,
  204,
  229,
  249,
  116,
  255,
  150
]);
function getTokenBadgeDiscriminatorBytes() {
  return fixEncoderSize5(getBytesEncoder5(), 8).encode(TOKEN_BADGE_DISCRIMINATOR);
}
function getTokenBadgeEncoder() {
  return transformEncoder5(
    getStructEncoder10([
      ["discriminator", fixEncoderSize5(getBytesEncoder5(), 8)],
      ["whirlpoolsConfig", getAddressEncoder6()],
      ["tokenMint", getAddressEncoder6()]
    ]),
    (value) => ({ ...value, discriminator: TOKEN_BADGE_DISCRIMINATOR })
  );
}
function getTokenBadgeDecoder() {
  return getStructDecoder10([
    ["discriminator", fixDecoderSize5(getBytesDecoder5(), 8)],
    ["whirlpoolsConfig", getAddressDecoder6()],
    ["tokenMint", getAddressDecoder6()]
  ]);
}
function getTokenBadgeCodec() {
  return combineCodec11(getTokenBadgeEncoder(), getTokenBadgeDecoder());
}
function decodeTokenBadge(encodedAccount) {
  return decodeAccount5(
    encodedAccount,
    getTokenBadgeDecoder()
  );
}
async function fetchTokenBadge(rpc, address, config) {
  const maybeAccount = await fetchMaybeTokenBadge(rpc, address, config);
  assertAccountExists5(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeTokenBadge(rpc, address, config) {
  const maybeAccount = await fetchEncodedAccount5(rpc, address, config);
  return decodeTokenBadge(maybeAccount);
}
async function fetchAllTokenBadge(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeTokenBadge(rpc, addresses, config);
  assertAccountsExist5(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeTokenBadge(rpc, addresses, config) {
  const maybeAccounts = await fetchEncodedAccounts5(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeTokenBadge(maybeAccount));
}
function getTokenBadgeSize() {
  return 72;
}

// src/generated/accounts/whirlpool.ts
import {
  assertAccountExists as assertAccountExists6,
  assertAccountsExist as assertAccountsExist6,
  combineCodec as combineCodec12,
  decodeAccount as decodeAccount6,
  fetchEncodedAccount as fetchEncodedAccount6,
  fetchEncodedAccounts as fetchEncodedAccounts6,
  fixDecoderSize as fixDecoderSize6,
  fixEncoderSize as fixEncoderSize6,
  getAddressDecoder as getAddressDecoder7,
  getAddressEncoder as getAddressEncoder7,
  getArrayDecoder as getArrayDecoder5,
  getArrayEncoder as getArrayEncoder5,
  getBytesDecoder as getBytesDecoder6,
  getBytesEncoder as getBytesEncoder6,
  getI32Decoder as getI32Decoder3,
  getI32Encoder as getI32Encoder3,
  getStructDecoder as getStructDecoder11,
  getStructEncoder as getStructEncoder11,
  getU128Decoder as getU128Decoder5,
  getU128Encoder as getU128Encoder5,
  getU16Decoder as getU16Decoder2,
  getU16Encoder as getU16Encoder2,
  getU64Decoder as getU64Decoder3,
  getU64Encoder as getU64Encoder3,
  transformEncoder as transformEncoder6
} from "@solana/web3.js";
var WHIRLPOOL_DISCRIMINATOR = new Uint8Array([
  63,
  149,
  209,
  12,
  225,
  128,
  99,
  9
]);
function getWhirlpoolDiscriminatorBytes() {
  return fixEncoderSize6(getBytesEncoder6(), 8).encode(WHIRLPOOL_DISCRIMINATOR);
}
function getWhirlpoolEncoder() {
  return transformEncoder6(
    getStructEncoder11([
      ["discriminator", fixEncoderSize6(getBytesEncoder6(), 8)],
      ["whirlpoolsConfig", getAddressEncoder7()],
      ["whirlpoolBump", fixEncoderSize6(getBytesEncoder6(), 1)],
      ["tickSpacing", getU16Encoder2()],
      ["tickSpacingSeed", fixEncoderSize6(getBytesEncoder6(), 2)],
      ["feeRate", getU16Encoder2()],
      ["protocolFeeRate", getU16Encoder2()],
      ["liquidity", getU128Encoder5()],
      ["sqrtPrice", getU128Encoder5()],
      ["tickCurrentIndex", getI32Encoder3()],
      ["protocolFeeOwedA", getU64Encoder3()],
      ["protocolFeeOwedB", getU64Encoder3()],
      ["tokenMintA", getAddressEncoder7()],
      ["tokenVaultA", getAddressEncoder7()],
      ["feeGrowthGlobalA", getU128Encoder5()],
      ["tokenMintB", getAddressEncoder7()],
      ["tokenVaultB", getAddressEncoder7()],
      ["feeGrowthGlobalB", getU128Encoder5()],
      ["rewardLastUpdatedTimestamp", getU64Encoder3()],
      [
        "rewardInfos",
        getArrayEncoder5(getWhirlpoolRewardInfoEncoder(), { size: 3 })
      ]
    ]),
    (value) => ({ ...value, discriminator: WHIRLPOOL_DISCRIMINATOR })
  );
}
function getWhirlpoolDecoder() {
  return getStructDecoder11([
    ["discriminator", fixDecoderSize6(getBytesDecoder6(), 8)],
    ["whirlpoolsConfig", getAddressDecoder7()],
    ["whirlpoolBump", fixDecoderSize6(getBytesDecoder6(), 1)],
    ["tickSpacing", getU16Decoder2()],
    ["tickSpacingSeed", fixDecoderSize6(getBytesDecoder6(), 2)],
    ["feeRate", getU16Decoder2()],
    ["protocolFeeRate", getU16Decoder2()],
    ["liquidity", getU128Decoder5()],
    ["sqrtPrice", getU128Decoder5()],
    ["tickCurrentIndex", getI32Decoder3()],
    ["protocolFeeOwedA", getU64Decoder3()],
    ["protocolFeeOwedB", getU64Decoder3()],
    ["tokenMintA", getAddressDecoder7()],
    ["tokenVaultA", getAddressDecoder7()],
    ["feeGrowthGlobalA", getU128Decoder5()],
    ["tokenMintB", getAddressDecoder7()],
    ["tokenVaultB", getAddressDecoder7()],
    ["feeGrowthGlobalB", getU128Decoder5()],
    ["rewardLastUpdatedTimestamp", getU64Decoder3()],
    [
      "rewardInfos",
      getArrayDecoder5(getWhirlpoolRewardInfoDecoder(), { size: 3 })
    ]
  ]);
}
function getWhirlpoolCodec() {
  return combineCodec12(getWhirlpoolEncoder(), getWhirlpoolDecoder());
}
function decodeWhirlpool(encodedAccount) {
  return decodeAccount6(
    encodedAccount,
    getWhirlpoolDecoder()
  );
}
async function fetchWhirlpool(rpc, address, config) {
  const maybeAccount = await fetchMaybeWhirlpool(rpc, address, config);
  assertAccountExists6(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeWhirlpool(rpc, address, config) {
  const maybeAccount = await fetchEncodedAccount6(rpc, address, config);
  return decodeWhirlpool(maybeAccount);
}
async function fetchAllWhirlpool(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeWhirlpool(rpc, addresses, config);
  assertAccountsExist6(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeWhirlpool(rpc, addresses, config) {
  const maybeAccounts = await fetchEncodedAccounts6(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeWhirlpool(maybeAccount));
}
function getWhirlpoolSize() {
  return 653;
}

// src/generated/accounts/whirlpoolsConfig.ts
import {
  assertAccountExists as assertAccountExists7,
  assertAccountsExist as assertAccountsExist7,
  combineCodec as combineCodec13,
  decodeAccount as decodeAccount7,
  fetchEncodedAccount as fetchEncodedAccount7,
  fetchEncodedAccounts as fetchEncodedAccounts7,
  fixDecoderSize as fixDecoderSize7,
  fixEncoderSize as fixEncoderSize7,
  getAddressDecoder as getAddressDecoder8,
  getAddressEncoder as getAddressEncoder8,
  getBytesDecoder as getBytesDecoder7,
  getBytesEncoder as getBytesEncoder7,
  getStructDecoder as getStructDecoder12,
  getStructEncoder as getStructEncoder12,
  getU16Decoder as getU16Decoder3,
  getU16Encoder as getU16Encoder3,
  transformEncoder as transformEncoder7
} from "@solana/web3.js";
var WHIRLPOOLS_CONFIG_DISCRIMINATOR = new Uint8Array([
  157,
  20,
  49,
  224,
  217,
  87,
  193,
  254
]);
function getWhirlpoolsConfigDiscriminatorBytes() {
  return fixEncoderSize7(getBytesEncoder7(), 8).encode(
    WHIRLPOOLS_CONFIG_DISCRIMINATOR
  );
}
function getWhirlpoolsConfigEncoder() {
  return transformEncoder7(
    getStructEncoder12([
      ["discriminator", fixEncoderSize7(getBytesEncoder7(), 8)],
      ["feeAuthority", getAddressEncoder8()],
      ["collectProtocolFeesAuthority", getAddressEncoder8()],
      ["rewardEmissionsSuperAuthority", getAddressEncoder8()],
      ["defaultProtocolFeeRate", getU16Encoder3()]
    ]),
    (value) => ({ ...value, discriminator: WHIRLPOOLS_CONFIG_DISCRIMINATOR })
  );
}
function getWhirlpoolsConfigDecoder() {
  return getStructDecoder12([
    ["discriminator", fixDecoderSize7(getBytesDecoder7(), 8)],
    ["feeAuthority", getAddressDecoder8()],
    ["collectProtocolFeesAuthority", getAddressDecoder8()],
    ["rewardEmissionsSuperAuthority", getAddressDecoder8()],
    ["defaultProtocolFeeRate", getU16Decoder3()]
  ]);
}
function getWhirlpoolsConfigCodec() {
  return combineCodec13(
    getWhirlpoolsConfigEncoder(),
    getWhirlpoolsConfigDecoder()
  );
}
function decodeWhirlpoolsConfig(encodedAccount) {
  return decodeAccount7(
    encodedAccount,
    getWhirlpoolsConfigDecoder()
  );
}
async function fetchWhirlpoolsConfig(rpc, address, config) {
  const maybeAccount = await fetchMaybeWhirlpoolsConfig(rpc, address, config);
  assertAccountExists7(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeWhirlpoolsConfig(rpc, address, config) {
  const maybeAccount = await fetchEncodedAccount7(rpc, address, config);
  return decodeWhirlpoolsConfig(maybeAccount);
}
async function fetchAllWhirlpoolsConfig(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeWhirlpoolsConfig(
    rpc,
    addresses,
    config
  );
  assertAccountsExist7(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeWhirlpoolsConfig(rpc, addresses, config) {
  const maybeAccounts = await fetchEncodedAccounts7(rpc, addresses, config);
  return maybeAccounts.map(
    (maybeAccount) => decodeWhirlpoolsConfig(maybeAccount)
  );
}
function getWhirlpoolsConfigSize() {
  return 106;
}

// src/generated/accounts/whirlpoolsConfigExtension.ts
import {
  assertAccountExists as assertAccountExists8,
  assertAccountsExist as assertAccountsExist8,
  combineCodec as combineCodec14,
  decodeAccount as decodeAccount8,
  fetchEncodedAccount as fetchEncodedAccount8,
  fetchEncodedAccounts as fetchEncodedAccounts8,
  fixDecoderSize as fixDecoderSize8,
  fixEncoderSize as fixEncoderSize8,
  getAddressDecoder as getAddressDecoder9,
  getAddressEncoder as getAddressEncoder9,
  getBytesDecoder as getBytesDecoder8,
  getBytesEncoder as getBytesEncoder8,
  getStructDecoder as getStructDecoder13,
  getStructEncoder as getStructEncoder13,
  transformEncoder as transformEncoder8
} from "@solana/web3.js";
var WHIRLPOOLS_CONFIG_EXTENSION_DISCRIMINATOR = new Uint8Array([
  2,
  99,
  215,
  163,
  240,
  26,
  153,
  58
]);
function getWhirlpoolsConfigExtensionDiscriminatorBytes() {
  return fixEncoderSize8(getBytesEncoder8(), 8).encode(
    WHIRLPOOLS_CONFIG_EXTENSION_DISCRIMINATOR
  );
}
function getWhirlpoolsConfigExtensionEncoder() {
  return transformEncoder8(
    getStructEncoder13([
      ["discriminator", fixEncoderSize8(getBytesEncoder8(), 8)],
      ["whirlpoolsConfig", getAddressEncoder9()],
      ["configExtensionAuthority", getAddressEncoder9()],
      ["tokenBadgeAuthority", getAddressEncoder9()]
    ]),
    (value) => ({
      ...value,
      discriminator: WHIRLPOOLS_CONFIG_EXTENSION_DISCRIMINATOR
    })
  );
}
function getWhirlpoolsConfigExtensionDecoder() {
  return getStructDecoder13([
    ["discriminator", fixDecoderSize8(getBytesDecoder8(), 8)],
    ["whirlpoolsConfig", getAddressDecoder9()],
    ["configExtensionAuthority", getAddressDecoder9()],
    ["tokenBadgeAuthority", getAddressDecoder9()]
  ]);
}
function getWhirlpoolsConfigExtensionCodec() {
  return combineCodec14(
    getWhirlpoolsConfigExtensionEncoder(),
    getWhirlpoolsConfigExtensionDecoder()
  );
}
function decodeWhirlpoolsConfigExtension(encodedAccount) {
  return decodeAccount8(
    encodedAccount,
    getWhirlpoolsConfigExtensionDecoder()
  );
}
async function fetchWhirlpoolsConfigExtension(rpc, address, config) {
  const maybeAccount = await fetchMaybeWhirlpoolsConfigExtension(
    rpc,
    address,
    config
  );
  assertAccountExists8(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeWhirlpoolsConfigExtension(rpc, address, config) {
  const maybeAccount = await fetchEncodedAccount8(rpc, address, config);
  return decodeWhirlpoolsConfigExtension(maybeAccount);
}
async function fetchAllWhirlpoolsConfigExtension(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeWhirlpoolsConfigExtension(
    rpc,
    addresses,
    config
  );
  assertAccountsExist8(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeWhirlpoolsConfigExtension(rpc, addresses, config) {
  const maybeAccounts = await fetchEncodedAccounts8(rpc, addresses, config);
  return maybeAccounts.map(
    (maybeAccount) => decodeWhirlpoolsConfigExtension(maybeAccount)
  );
}
function getWhirlpoolsConfigExtensionSize() {
  return 104;
}

// src/generated/errors/whirlpool.ts
import {
  isProgramError
} from "@solana/web3.js";

// src/generated/programs/whirlpool.ts
import {
  containsBytes,
  fixEncoderSize as fixEncoderSize9,
  getBytesEncoder as getBytesEncoder9
} from "@solana/web3.js";
var WHIRLPOOL_PROGRAM_ADDRESS = "whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc";
var WhirlpoolAccount = /* @__PURE__ */ ((WhirlpoolAccount2) => {
  WhirlpoolAccount2[WhirlpoolAccount2["WhirlpoolsConfig"] = 0] = "WhirlpoolsConfig";
  WhirlpoolAccount2[WhirlpoolAccount2["WhirlpoolsConfigExtension"] = 1] = "WhirlpoolsConfigExtension";
  WhirlpoolAccount2[WhirlpoolAccount2["FeeTier"] = 2] = "FeeTier";
  WhirlpoolAccount2[WhirlpoolAccount2["Position"] = 3] = "Position";
  WhirlpoolAccount2[WhirlpoolAccount2["PositionBundle"] = 4] = "PositionBundle";
  WhirlpoolAccount2[WhirlpoolAccount2["TickArray"] = 5] = "TickArray";
  WhirlpoolAccount2[WhirlpoolAccount2["TokenBadge"] = 6] = "TokenBadge";
  WhirlpoolAccount2[WhirlpoolAccount2["Whirlpool"] = 7] = "Whirlpool";
  return WhirlpoolAccount2;
})(WhirlpoolAccount || {});
function identifyWhirlpoolAccount(account) {
  const data = "data" in account ? account.data : account;
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([157, 20, 49, 224, 217, 87, 193, 254])
    ),
    0
  )) {
    return 0 /* WhirlpoolsConfig */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([2, 99, 215, 163, 240, 26, 153, 58])
    ),
    0
  )) {
    return 1 /* WhirlpoolsConfigExtension */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([56, 75, 159, 76, 142, 68, 190, 105])
    ),
    0
  )) {
    return 2 /* FeeTier */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([170, 188, 143, 228, 122, 64, 247, 208])
    ),
    0
  )) {
    return 3 /* Position */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([129, 169, 175, 65, 185, 95, 32, 100])
    ),
    0
  )) {
    return 4 /* PositionBundle */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([69, 97, 189, 190, 110, 7, 66, 187])
    ),
    0
  )) {
    return 5 /* TickArray */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([116, 219, 204, 229, 249, 116, 255, 150])
    ),
    0
  )) {
    return 6 /* TokenBadge */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([63, 149, 209, 12, 225, 128, 99, 9])
    ),
    0
  )) {
    return 7 /* Whirlpool */;
  }
  throw new Error(
    "The provided account could not be identified as a whirlpool account."
  );
}
var WhirlpoolInstruction = /* @__PURE__ */ ((WhirlpoolInstruction2) => {
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializeConfig"] = 0] = "InitializeConfig";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializePool"] = 1] = "InitializePool";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializeTickArray"] = 2] = "InitializeTickArray";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializeFeeTier"] = 3] = "InitializeFeeTier";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializeReward"] = 4] = "InitializeReward";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetRewardEmissions"] = 5] = "SetRewardEmissions";
  WhirlpoolInstruction2[WhirlpoolInstruction2["OpenPosition"] = 6] = "OpenPosition";
  WhirlpoolInstruction2[WhirlpoolInstruction2["OpenPositionWithMetadata"] = 7] = "OpenPositionWithMetadata";
  WhirlpoolInstruction2[WhirlpoolInstruction2["IncreaseLiquidity"] = 8] = "IncreaseLiquidity";
  WhirlpoolInstruction2[WhirlpoolInstruction2["DecreaseLiquidity"] = 9] = "DecreaseLiquidity";
  WhirlpoolInstruction2[WhirlpoolInstruction2["UpdateFeesAndRewards"] = 10] = "UpdateFeesAndRewards";
  WhirlpoolInstruction2[WhirlpoolInstruction2["CollectFees"] = 11] = "CollectFees";
  WhirlpoolInstruction2[WhirlpoolInstruction2["CollectReward"] = 12] = "CollectReward";
  WhirlpoolInstruction2[WhirlpoolInstruction2["CollectProtocolFees"] = 13] = "CollectProtocolFees";
  WhirlpoolInstruction2[WhirlpoolInstruction2["Swap"] = 14] = "Swap";
  WhirlpoolInstruction2[WhirlpoolInstruction2["ClosePosition"] = 15] = "ClosePosition";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetDefaultFeeRate"] = 16] = "SetDefaultFeeRate";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetDefaultProtocolFeeRate"] = 17] = "SetDefaultProtocolFeeRate";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetFeeRate"] = 18] = "SetFeeRate";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetProtocolFeeRate"] = 19] = "SetProtocolFeeRate";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetFeeAuthority"] = 20] = "SetFeeAuthority";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetCollectProtocolFeesAuthority"] = 21] = "SetCollectProtocolFeesAuthority";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetRewardAuthority"] = 22] = "SetRewardAuthority";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetRewardAuthorityBySuperAuthority"] = 23] = "SetRewardAuthorityBySuperAuthority";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetRewardEmissionsSuperAuthority"] = 24] = "SetRewardEmissionsSuperAuthority";
  WhirlpoolInstruction2[WhirlpoolInstruction2["TwoHopSwap"] = 25] = "TwoHopSwap";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializePositionBundle"] = 26] = "InitializePositionBundle";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializePositionBundleWithMetadata"] = 27] = "InitializePositionBundleWithMetadata";
  WhirlpoolInstruction2[WhirlpoolInstruction2["DeletePositionBundle"] = 28] = "DeletePositionBundle";
  WhirlpoolInstruction2[WhirlpoolInstruction2["OpenBundledPosition"] = 29] = "OpenBundledPosition";
  WhirlpoolInstruction2[WhirlpoolInstruction2["CloseBundledPosition"] = 30] = "CloseBundledPosition";
  WhirlpoolInstruction2[WhirlpoolInstruction2["OpenPositionWithTokenExtensions"] = 31] = "OpenPositionWithTokenExtensions";
  WhirlpoolInstruction2[WhirlpoolInstruction2["ClosePositionWithTokenExtensions"] = 32] = "ClosePositionWithTokenExtensions";
  WhirlpoolInstruction2[WhirlpoolInstruction2["CollectFeesV2"] = 33] = "CollectFeesV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["CollectProtocolFeesV2"] = 34] = "CollectProtocolFeesV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["CollectRewardV2"] = 35] = "CollectRewardV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["DecreaseLiquidityV2"] = 36] = "DecreaseLiquidityV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["IncreaseLiquidityV2"] = 37] = "IncreaseLiquidityV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializePoolV2"] = 38] = "InitializePoolV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializeRewardV2"] = 39] = "InitializeRewardV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetRewardEmissionsV2"] = 40] = "SetRewardEmissionsV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SwapV2"] = 41] = "SwapV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["TwoHopSwapV2"] = 42] = "TwoHopSwapV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializeConfigExtension"] = 43] = "InitializeConfigExtension";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetConfigExtensionAuthority"] = 44] = "SetConfigExtensionAuthority";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetTokenBadgeAuthority"] = 45] = "SetTokenBadgeAuthority";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializeTokenBadge"] = 46] = "InitializeTokenBadge";
  WhirlpoolInstruction2[WhirlpoolInstruction2["DeleteTokenBadge"] = 47] = "DeleteTokenBadge";
  return WhirlpoolInstruction2;
})(WhirlpoolInstruction || {});
function identifyWhirlpoolInstruction(instruction) {
  const data = "data" in instruction ? instruction.data : instruction;
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([208, 127, 21, 1, 194, 190, 196, 70])
    ),
    0
  )) {
    return 0 /* InitializeConfig */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([95, 180, 10, 172, 84, 174, 232, 40])
    ),
    0
  )) {
    return 1 /* InitializePool */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([11, 188, 193, 214, 141, 91, 149, 184])
    ),
    0
  )) {
    return 2 /* InitializeTickArray */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([183, 74, 156, 160, 112, 2, 42, 30])
    ),
    0
  )) {
    return 3 /* InitializeFeeTier */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([95, 135, 192, 196, 242, 129, 230, 68])
    ),
    0
  )) {
    return 4 /* InitializeReward */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([13, 197, 86, 168, 109, 176, 27, 244])
    ),
    0
  )) {
    return 5 /* SetRewardEmissions */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([135, 128, 47, 77, 15, 152, 240, 49])
    ),
    0
  )) {
    return 6 /* OpenPosition */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([242, 29, 134, 48, 58, 110, 14, 60])
    ),
    0
  )) {
    return 7 /* OpenPositionWithMetadata */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([46, 156, 243, 118, 13, 205, 251, 178])
    ),
    0
  )) {
    return 8 /* IncreaseLiquidity */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([160, 38, 208, 111, 104, 91, 44, 1])
    ),
    0
  )) {
    return 9 /* DecreaseLiquidity */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([154, 230, 250, 13, 236, 209, 75, 223])
    ),
    0
  )) {
    return 10 /* UpdateFeesAndRewards */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([164, 152, 207, 99, 30, 186, 19, 182])
    ),
    0
  )) {
    return 11 /* CollectFees */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([70, 5, 132, 87, 86, 235, 177, 34])
    ),
    0
  )) {
    return 12 /* CollectReward */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([22, 67, 23, 98, 150, 178, 70, 220])
    ),
    0
  )) {
    return 13 /* CollectProtocolFees */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([248, 198, 158, 145, 225, 117, 135, 200])
    ),
    0
  )) {
    return 14 /* Swap */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([123, 134, 81, 0, 49, 68, 98, 98])
    ),
    0
  )) {
    return 15 /* ClosePosition */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([118, 215, 214, 157, 182, 229, 208, 228])
    ),
    0
  )) {
    return 16 /* SetDefaultFeeRate */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([107, 205, 249, 226, 151, 35, 86, 0])
    ),
    0
  )) {
    return 17 /* SetDefaultProtocolFeeRate */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([53, 243, 137, 65, 8, 140, 158, 6])
    ),
    0
  )) {
    return 18 /* SetFeeRate */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([95, 7, 4, 50, 154, 79, 156, 131])
    ),
    0
  )) {
    return 19 /* SetProtocolFeeRate */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([31, 1, 50, 87, 237, 101, 97, 132])
    ),
    0
  )) {
    return 20 /* SetFeeAuthority */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([34, 150, 93, 244, 139, 225, 233, 67])
    ),
    0
  )) {
    return 21 /* SetCollectProtocolFeesAuthority */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([34, 39, 183, 252, 83, 28, 85, 127])
    ),
    0
  )) {
    return 22 /* SetRewardAuthority */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([240, 154, 201, 198, 148, 93, 56, 25])
    ),
    0
  )) {
    return 23 /* SetRewardAuthorityBySuperAuthority */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([207, 5, 200, 209, 122, 56, 82, 183])
    ),
    0
  )) {
    return 24 /* SetRewardEmissionsSuperAuthority */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([195, 96, 237, 108, 68, 162, 219, 230])
    ),
    0
  )) {
    return 25 /* TwoHopSwap */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([117, 45, 241, 149, 24, 18, 194, 65])
    ),
    0
  )) {
    return 26 /* InitializePositionBundle */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([93, 124, 16, 179, 249, 131, 115, 245])
    ),
    0
  )) {
    return 27 /* InitializePositionBundleWithMetadata */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([100, 25, 99, 2, 217, 239, 124, 173])
    ),
    0
  )) {
    return 28 /* DeletePositionBundle */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([169, 113, 126, 171, 213, 172, 212, 49])
    ),
    0
  )) {
    return 29 /* OpenBundledPosition */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([41, 36, 216, 245, 27, 85, 103, 67])
    ),
    0
  )) {
    return 30 /* CloseBundledPosition */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([212, 47, 95, 92, 114, 102, 131, 250])
    ),
    0
  )) {
    return 31 /* OpenPositionWithTokenExtensions */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([1, 182, 135, 59, 155, 25, 99, 223])
    ),
    0
  )) {
    return 32 /* ClosePositionWithTokenExtensions */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([207, 117, 95, 191, 229, 180, 226, 15])
    ),
    0
  )) {
    return 33 /* CollectFeesV2 */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([103, 128, 222, 134, 114, 200, 22, 200])
    ),
    0
  )) {
    return 34 /* CollectProtocolFeesV2 */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([177, 107, 37, 180, 160, 19, 49, 209])
    ),
    0
  )) {
    return 35 /* CollectRewardV2 */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([58, 127, 188, 62, 79, 82, 196, 96])
    ),
    0
  )) {
    return 36 /* DecreaseLiquidityV2 */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([133, 29, 89, 223, 69, 238, 176, 10])
    ),
    0
  )) {
    return 37 /* IncreaseLiquidityV2 */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([207, 45, 87, 242, 27, 63, 204, 67])
    ),
    0
  )) {
    return 38 /* InitializePoolV2 */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([91, 1, 77, 50, 235, 229, 133, 49])
    ),
    0
  )) {
    return 39 /* InitializeRewardV2 */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([114, 228, 72, 32, 193, 48, 160, 102])
    ),
    0
  )) {
    return 40 /* SetRewardEmissionsV2 */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([43, 4, 237, 11, 26, 201, 30, 98])
    ),
    0
  )) {
    return 41 /* SwapV2 */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([186, 143, 209, 29, 254, 2, 194, 117])
    ),
    0
  )) {
    return 42 /* TwoHopSwapV2 */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([55, 9, 53, 9, 114, 57, 209, 52])
    ),
    0
  )) {
    return 43 /* InitializeConfigExtension */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([44, 94, 241, 116, 24, 188, 60, 143])
    ),
    0
  )) {
    return 44 /* SetConfigExtensionAuthority */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([207, 202, 4, 32, 205, 79, 13, 178])
    ),
    0
  )) {
    return 45 /* SetTokenBadgeAuthority */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([253, 77, 205, 95, 27, 224, 89, 223])
    ),
    0
  )) {
    return 46 /* InitializeTokenBadge */;
  }
  if (containsBytes(
    data,
    fixEncoderSize9(getBytesEncoder9(), 8).encode(
      new Uint8Array([53, 146, 68, 8, 18, 117, 17, 185])
    ),
    0
  )) {
    return 47 /* DeleteTokenBadge */;
  }
  throw new Error(
    "The provided instruction could not be identified as a whirlpool instruction."
  );
}

// src/generated/errors/whirlpool.ts
var WHIRLPOOL_ERROR__INVALID_ENUM = 6e3;
var WHIRLPOOL_ERROR__INVALID_START_TICK = 6001;
var WHIRLPOOL_ERROR__TICK_ARRAY_EXIST_IN_POOL = 6002;
var WHIRLPOOL_ERROR__TICK_ARRAY_INDEX_OUTOF_BOUNDS = 6003;
var WHIRLPOOL_ERROR__INVALID_TICK_SPACING = 6004;
var WHIRLPOOL_ERROR__CLOSE_POSITION_NOT_EMPTY = 6005;
var WHIRLPOOL_ERROR__DIVIDE_BY_ZERO = 6006;
var WHIRLPOOL_ERROR__NUMBER_CAST_ERROR = 6007;
var WHIRLPOOL_ERROR__NUMBER_DOWN_CAST_ERROR = 6008;
var WHIRLPOOL_ERROR__TICK_NOT_FOUND = 6009;
var WHIRLPOOL_ERROR__INVALID_TICK_INDEX = 6010;
var WHIRLPOOL_ERROR__SQRT_PRICE_OUT_OF_BOUNDS = 6011;
var WHIRLPOOL_ERROR__LIQUIDITY_ZERO = 6012;
var WHIRLPOOL_ERROR__LIQUIDITY_TOO_HIGH = 6013;
var WHIRLPOOL_ERROR__LIQUIDITY_OVERFLOW = 6014;
var WHIRLPOOL_ERROR__LIQUIDITY_UNDERFLOW = 6015;
var WHIRLPOOL_ERROR__LIQUIDITY_NET_ERROR = 6016;
var WHIRLPOOL_ERROR__TOKEN_MAX_EXCEEDED = 6017;
var WHIRLPOOL_ERROR__TOKEN_MIN_SUBCEEDED = 6018;
var WHIRLPOOL_ERROR__MISSING_OR_INVALID_DELEGATE = 6019;
var WHIRLPOOL_ERROR__INVALID_POSITION_TOKEN_AMOUNT = 6020;
var WHIRLPOOL_ERROR__INVALID_TIMESTAMP_CONVERSION = 6021;
var WHIRLPOOL_ERROR__INVALID_TIMESTAMP = 6022;
var WHIRLPOOL_ERROR__INVALID_TICK_ARRAY_SEQUENCE = 6023;
var WHIRLPOOL_ERROR__INVALID_TOKEN_MINT_ORDER = 6024;
var WHIRLPOOL_ERROR__REWARD_NOT_INITIALIZED = 6025;
var WHIRLPOOL_ERROR__INVALID_REWARD_INDEX = 6026;
var WHIRLPOOL_ERROR__REWARD_VAULT_AMOUNT_INSUFFICIENT = 6027;
var WHIRLPOOL_ERROR__FEE_RATE_MAX_EXCEEDED = 6028;
var WHIRLPOOL_ERROR__PROTOCOL_FEE_RATE_MAX_EXCEEDED = 6029;
var WHIRLPOOL_ERROR__MULTIPLICATION_SHIFT_RIGHT_OVERFLOW = 6030;
var WHIRLPOOL_ERROR__MUL_DIV_OVERFLOW = 6031;
var WHIRLPOOL_ERROR__MUL_DIV_INVALID_INPUT = 6032;
var WHIRLPOOL_ERROR__MULTIPLICATION_OVERFLOW = 6033;
var WHIRLPOOL_ERROR__INVALID_SQRT_PRICE_LIMIT_DIRECTION = 6034;
var WHIRLPOOL_ERROR__ZERO_TRADABLE_AMOUNT = 6035;
var WHIRLPOOL_ERROR__AMOUNT_OUT_BELOW_MINIMUM = 6036;
var WHIRLPOOL_ERROR__AMOUNT_IN_ABOVE_MAXIMUM = 6037;
var WHIRLPOOL_ERROR__TICK_ARRAY_SEQUENCE_INVALID_INDEX = 6038;
var WHIRLPOOL_ERROR__AMOUNT_CALC_OVERFLOW = 6039;
var WHIRLPOOL_ERROR__AMOUNT_REMAINING_OVERFLOW = 6040;
var WHIRLPOOL_ERROR__INVALID_INTERMEDIARY_MINT = 6041;
var WHIRLPOOL_ERROR__DUPLICATE_TWO_HOP_POOL = 6042;
var WHIRLPOOL_ERROR__INVALID_BUNDLE_INDEX = 6043;
var WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_OPENED = 6044;
var WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_CLOSED = 6045;
var WHIRLPOOL_ERROR__POSITION_BUNDLE_NOT_DELETABLE = 6046;
var WHIRLPOOL_ERROR__UNSUPPORTED_TOKEN_MINT = 6047;
var WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INVALID_SLICE = 6048;
var WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INSUFFICIENT = 6049;
var WHIRLPOOL_ERROR__NO_EXTRA_ACCOUNTS_FOR_TRANSFER_HOOK = 6050;
var WHIRLPOOL_ERROR__INTERMEDIATE_TOKEN_AMOUNT_MISMATCH = 6051;
var WHIRLPOOL_ERROR__TRANSFER_FEE_CALCULATION_ERROR = 6052;
var WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_DUPLICATED_ACCOUNTS_TYPE = 6053;
var WHIRLPOOL_ERROR__FULL_RANGE_ONLY_POOL = 6054;
var WHIRLPOOL_ERROR__TOO_MANY_SUPPLEMENTAL_TICK_ARRAYS = 6055;
var WHIRLPOOL_ERROR__DIFFERENT_WHIRLPOOL_TICK_ARRAY_ACCOUNT = 6056;
var WHIRLPOOL_ERROR__PARTIAL_FILL_ERROR = 6057;
var whirlpoolErrorMessages;
if (process.env.NODE_ENV !== "production") {
  whirlpoolErrorMessages = {
    [WHIRLPOOL_ERROR__AMOUNT_CALC_OVERFLOW]: `Amount calculated overflows`,
    [WHIRLPOOL_ERROR__AMOUNT_IN_ABOVE_MAXIMUM]: `Amount in above maximum threshold`,
    [WHIRLPOOL_ERROR__AMOUNT_OUT_BELOW_MINIMUM]: `Amount out below minimum threshold`,
    [WHIRLPOOL_ERROR__AMOUNT_REMAINING_OVERFLOW]: `Amount remaining overflows`,
    [WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_CLOSED]: `Position has already been closed`,
    [WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_OPENED]: `Position has already been opened`,
    [WHIRLPOOL_ERROR__CLOSE_POSITION_NOT_EMPTY]: `Position is not empty It cannot be closed`,
    [WHIRLPOOL_ERROR__DIFFERENT_WHIRLPOOL_TICK_ARRAY_ACCOUNT]: `TickArray account for different whirlpool provided`,
    [WHIRLPOOL_ERROR__DIVIDE_BY_ZERO]: `Unable to divide by zero`,
    [WHIRLPOOL_ERROR__DUPLICATE_TWO_HOP_POOL]: `Duplicate two hop pool`,
    [WHIRLPOOL_ERROR__FEE_RATE_MAX_EXCEEDED]: `Exceeded max fee rate`,
    [WHIRLPOOL_ERROR__FULL_RANGE_ONLY_POOL]: `This whirlpool only supports full-range positions`,
    [WHIRLPOOL_ERROR__INTERMEDIATE_TOKEN_AMOUNT_MISMATCH]: `Output and input amount mismatch`,
    [WHIRLPOOL_ERROR__INVALID_BUNDLE_INDEX]: `Bundle index is out of bounds`,
    [WHIRLPOOL_ERROR__INVALID_ENUM]: `Enum value could not be converted`,
    [WHIRLPOOL_ERROR__INVALID_INTERMEDIARY_MINT]: `Invalid intermediary mint`,
    [WHIRLPOOL_ERROR__INVALID_POSITION_TOKEN_AMOUNT]: `Position token amount must be 1`,
    [WHIRLPOOL_ERROR__INVALID_REWARD_INDEX]: `Invalid reward index`,
    [WHIRLPOOL_ERROR__INVALID_SQRT_PRICE_LIMIT_DIRECTION]: `Provided SqrtPriceLimit not in the same direction as the swap.`,
    [WHIRLPOOL_ERROR__INVALID_START_TICK]: `Invalid start tick index provided.`,
    [WHIRLPOOL_ERROR__INVALID_TICK_ARRAY_SEQUENCE]: `Invalid tick array sequence provided for instruction.`,
    [WHIRLPOOL_ERROR__INVALID_TICK_INDEX]: `Provided tick index is either out of bounds or uninitializable`,
    [WHIRLPOOL_ERROR__INVALID_TICK_SPACING]: `Tick-spacing is not supported`,
    [WHIRLPOOL_ERROR__INVALID_TIMESTAMP]: `Timestamp should be greater than the last updated timestamp`,
    [WHIRLPOOL_ERROR__INVALID_TIMESTAMP_CONVERSION]: `Timestamp should be convertible from i64 to u64`,
    [WHIRLPOOL_ERROR__INVALID_TOKEN_MINT_ORDER]: `Token Mint in wrong order`,
    [WHIRLPOOL_ERROR__LIQUIDITY_NET_ERROR]: `Tick liquidity net underflowed or overflowed`,
    [WHIRLPOOL_ERROR__LIQUIDITY_OVERFLOW]: `Liquidity overflow`,
    [WHIRLPOOL_ERROR__LIQUIDITY_TOO_HIGH]: `Liquidity amount must be less than i64::MAX`,
    [WHIRLPOOL_ERROR__LIQUIDITY_UNDERFLOW]: `Liquidity underflow`,
    [WHIRLPOOL_ERROR__LIQUIDITY_ZERO]: `Liquidity amount must be greater than zero`,
    [WHIRLPOOL_ERROR__MISSING_OR_INVALID_DELEGATE]: `Position token account has a missing or invalid delegate`,
    [WHIRLPOOL_ERROR__MUL_DIV_INVALID_INPUT]: `Invalid div_u256 input`,
    [WHIRLPOOL_ERROR__MUL_DIV_OVERFLOW]: `Muldiv overflow`,
    [WHIRLPOOL_ERROR__MULTIPLICATION_OVERFLOW]: `Multiplication overflow`,
    [WHIRLPOOL_ERROR__MULTIPLICATION_SHIFT_RIGHT_OVERFLOW]: `Multiplication with shift right overflow`,
    [WHIRLPOOL_ERROR__NO_EXTRA_ACCOUNTS_FOR_TRANSFER_HOOK]: `Unable to call transfer hook without extra accounts`,
    [WHIRLPOOL_ERROR__NUMBER_CAST_ERROR]: `Unable to cast number into BigInt`,
    [WHIRLPOOL_ERROR__NUMBER_DOWN_CAST_ERROR]: `Unable to down cast number`,
    [WHIRLPOOL_ERROR__PARTIAL_FILL_ERROR]: `Trade resulted in partial fill`,
    [WHIRLPOOL_ERROR__POSITION_BUNDLE_NOT_DELETABLE]: `Unable to delete PositionBundle with open positions`,
    [WHIRLPOOL_ERROR__PROTOCOL_FEE_RATE_MAX_EXCEEDED]: `Exceeded max protocol fee rate`,
    [WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_DUPLICATED_ACCOUNTS_TYPE]: `Same accounts type is provided more than once`,
    [WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INSUFFICIENT]: `Insufficient remaining accounts`,
    [WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INVALID_SLICE]: `Invalid remaining accounts`,
    [WHIRLPOOL_ERROR__REWARD_NOT_INITIALIZED]: `Reward not initialized`,
    [WHIRLPOOL_ERROR__REWARD_VAULT_AMOUNT_INSUFFICIENT]: `Reward vault requires amount to support emissions for at least one day`,
    [WHIRLPOOL_ERROR__SQRT_PRICE_OUT_OF_BOUNDS]: `Provided sqrt price out of bounds`,
    [WHIRLPOOL_ERROR__TICK_ARRAY_EXIST_IN_POOL]: `Tick-array already exists in this whirlpool`,
    [WHIRLPOOL_ERROR__TICK_ARRAY_INDEX_OUTOF_BOUNDS]: `Attempt to search for a tick-array failed`,
    [WHIRLPOOL_ERROR__TICK_ARRAY_SEQUENCE_INVALID_INDEX]: `Invalid index for tick array sequence`,
    [WHIRLPOOL_ERROR__TICK_NOT_FOUND]: `Tick not found within tick array`,
    [WHIRLPOOL_ERROR__TOKEN_MAX_EXCEEDED]: `Exceeded token max`,
    [WHIRLPOOL_ERROR__TOKEN_MIN_SUBCEEDED]: `Did not meet token min`,
    [WHIRLPOOL_ERROR__TOO_MANY_SUPPLEMENTAL_TICK_ARRAYS]: `Too many supplemental tick arrays provided`,
    [WHIRLPOOL_ERROR__TRANSFER_FEE_CALCULATION_ERROR]: `Transfer fee calculation failed`,
    [WHIRLPOOL_ERROR__UNSUPPORTED_TOKEN_MINT]: `Token mint has unsupported attributes`,
    [WHIRLPOOL_ERROR__ZERO_TRADABLE_AMOUNT]: `There are no tradable amount to swap.`
  };
}
function getWhirlpoolErrorMessage(code) {
  if (process.env.NODE_ENV !== "production") {
    return whirlpoolErrorMessages[code];
  }
  return "Error message not available in production bundles.";
}
function isWhirlpoolError(error, transactionMessage, code) {
  return isProgramError(
    error,
    transactionMessage,
    WHIRLPOOL_PROGRAM_ADDRESS,
    code
  );
}

// src/generated/instructions/closeBundledPosition.ts
import {
  combineCodec as combineCodec15,
  fixDecoderSize as fixDecoderSize9,
  fixEncoderSize as fixEncoderSize10,
  getBytesDecoder as getBytesDecoder9,
  getBytesEncoder as getBytesEncoder10,
  getStructDecoder as getStructDecoder14,
  getStructEncoder as getStructEncoder14,
  getU16Decoder as getU16Decoder4,
  getU16Encoder as getU16Encoder4,
  transformEncoder as transformEncoder9
} from "@solana/web3.js";

// src/generated/shared/index.ts
import {
  AccountRole,
  isProgramDerivedAddress,
  isTransactionSigner as web3JsIsTransactionSigner,
  upgradeRoleToSigner
} from "@solana/web3.js";
function expectAddress(value) {
  if (!value) {
    throw new Error("Expected a Address.");
  }
  if (typeof value === "object" && "address" in value) {
    return value.address;
  }
  if (Array.isArray(value)) {
    return value[0];
  }
  return value;
}
function getAccountMetaFactory(programAddress, optionalAccountStrategy) {
  return (account) => {
    if (!account.value) {
      if (optionalAccountStrategy === "omitted") return;
      return Object.freeze({
        address: programAddress,
        role: AccountRole.READONLY
      });
    }
    const writableRole = account.isWritable ? AccountRole.WRITABLE : AccountRole.READONLY;
    return Object.freeze({
      address: expectAddress(account.value),
      role: isTransactionSigner(account.value) ? upgradeRoleToSigner(writableRole) : writableRole,
      ...isTransactionSigner(account.value) ? { signer: account.value } : {}
    });
  };
}
function isTransactionSigner(value) {
  return !!value && typeof value === "object" && "address" in value && web3JsIsTransactionSigner(value);
}

// src/generated/instructions/closeBundledPosition.ts
var CLOSE_BUNDLED_POSITION_DISCRIMINATOR = new Uint8Array([
  41,
  36,
  216,
  245,
  27,
  85,
  103,
  67
]);
function getCloseBundledPositionDiscriminatorBytes() {
  return fixEncoderSize10(getBytesEncoder10(), 8).encode(
    CLOSE_BUNDLED_POSITION_DISCRIMINATOR
  );
}
function getCloseBundledPositionInstructionDataEncoder() {
  return transformEncoder9(
    getStructEncoder14([
      ["discriminator", fixEncoderSize10(getBytesEncoder10(), 8)],
      ["bundleIndex", getU16Encoder4()]
    ]),
    (value) => ({
      ...value,
      discriminator: CLOSE_BUNDLED_POSITION_DISCRIMINATOR
    })
  );
}
function getCloseBundledPositionInstructionDataDecoder() {
  return getStructDecoder14([
    ["discriminator", fixDecoderSize9(getBytesDecoder9(), 8)],
    ["bundleIndex", getU16Decoder4()]
  ]);
}
function getCloseBundledPositionInstructionDataCodec() {
  return combineCodec15(
    getCloseBundledPositionInstructionDataEncoder(),
    getCloseBundledPositionInstructionDataDecoder()
  );
}
function getCloseBundledPositionInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    bundledPosition: { value: input.bundledPosition ?? null, isWritable: true },
    positionBundle: { value: input.positionBundle ?? null, isWritable: true },
    positionBundleTokenAccount: {
      value: input.positionBundleTokenAccount ?? null,
      isWritable: false
    },
    positionBundleAuthority: {
      value: input.positionBundleAuthority ?? null,
      isWritable: false
    },
    receiver: { value: input.receiver ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.bundledPosition),
      getAccountMeta(accounts.positionBundle),
      getAccountMeta(accounts.positionBundleTokenAccount),
      getAccountMeta(accounts.positionBundleAuthority),
      getAccountMeta(accounts.receiver)
    ],
    programAddress,
    data: getCloseBundledPositionInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseCloseBundledPositionInstruction(instruction) {
  if (instruction.accounts.length < 5) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      bundledPosition: getNextAccount(),
      positionBundle: getNextAccount(),
      positionBundleTokenAccount: getNextAccount(),
      positionBundleAuthority: getNextAccount(),
      receiver: getNextAccount()
    },
    data: getCloseBundledPositionInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/closePosition.ts
import {
  combineCodec as combineCodec16,
  fixDecoderSize as fixDecoderSize10,
  fixEncoderSize as fixEncoderSize11,
  getBytesDecoder as getBytesDecoder10,
  getBytesEncoder as getBytesEncoder11,
  getStructDecoder as getStructDecoder15,
  getStructEncoder as getStructEncoder15,
  transformEncoder as transformEncoder10
} from "@solana/web3.js";
var CLOSE_POSITION_DISCRIMINATOR = new Uint8Array([
  123,
  134,
  81,
  0,
  49,
  68,
  98,
  98
]);
function getClosePositionDiscriminatorBytes() {
  return fixEncoderSize11(getBytesEncoder11(), 8).encode(
    CLOSE_POSITION_DISCRIMINATOR
  );
}
function getClosePositionInstructionDataEncoder() {
  return transformEncoder10(
    getStructEncoder15([["discriminator", fixEncoderSize11(getBytesEncoder11(), 8)]]),
    (value) => ({ ...value, discriminator: CLOSE_POSITION_DISCRIMINATOR })
  );
}
function getClosePositionInstructionDataDecoder() {
  return getStructDecoder15([
    ["discriminator", fixDecoderSize10(getBytesDecoder10(), 8)]
  ]);
}
function getClosePositionInstructionDataCodec() {
  return combineCodec16(
    getClosePositionInstructionDataEncoder(),
    getClosePositionInstructionDataDecoder()
  );
}
function getClosePositionInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    receiver: { value: input.receiver ?? null, isWritable: true },
    position: { value: input.position ?? null, isWritable: true },
    positionMint: { value: input.positionMint ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: true
    },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.receiver),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionMint),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.tokenProgram)
    ],
    programAddress,
    data: getClosePositionInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseClosePositionInstruction(instruction) {
  if (instruction.accounts.length < 6) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      positionAuthority: getNextAccount(),
      receiver: getNextAccount(),
      position: getNextAccount(),
      positionMint: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      tokenProgram: getNextAccount()
    },
    data: getClosePositionInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/closePositionWithTokenExtensions.ts
import {
  combineCodec as combineCodec17,
  fixDecoderSize as fixDecoderSize11,
  fixEncoderSize as fixEncoderSize12,
  getBytesDecoder as getBytesDecoder11,
  getBytesEncoder as getBytesEncoder12,
  getStructDecoder as getStructDecoder16,
  getStructEncoder as getStructEncoder16,
  transformEncoder as transformEncoder11
} from "@solana/web3.js";
var CLOSE_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR = new Uint8Array([1, 182, 135, 59, 155, 25, 99, 223]);
function getClosePositionWithTokenExtensionsDiscriminatorBytes() {
  return fixEncoderSize12(getBytesEncoder12(), 8).encode(
    CLOSE_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR
  );
}
function getClosePositionWithTokenExtensionsInstructionDataEncoder() {
  return transformEncoder11(
    getStructEncoder16([["discriminator", fixEncoderSize12(getBytesEncoder12(), 8)]]),
    (value) => ({
      ...value,
      discriminator: CLOSE_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR
    })
  );
}
function getClosePositionWithTokenExtensionsInstructionDataDecoder() {
  return getStructDecoder16([
    ["discriminator", fixDecoderSize11(getBytesDecoder11(), 8)]
  ]);
}
function getClosePositionWithTokenExtensionsInstructionDataCodec() {
  return combineCodec17(
    getClosePositionWithTokenExtensionsInstructionDataEncoder(),
    getClosePositionWithTokenExtensionsInstructionDataDecoder()
  );
}
function getClosePositionWithTokenExtensionsInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    receiver: { value: input.receiver ?? null, isWritable: true },
    position: { value: input.position ?? null, isWritable: true },
    positionMint: { value: input.positionMint ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: true
    },
    token2022Program: {
      value: input.token2022Program ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.receiver),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionMint),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.token2022Program)
    ],
    programAddress,
    data: getClosePositionWithTokenExtensionsInstructionDataEncoder().encode(
      {}
    )
  };
  return instruction;
}
function parseClosePositionWithTokenExtensionsInstruction(instruction) {
  if (instruction.accounts.length < 6) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      positionAuthority: getNextAccount(),
      receiver: getNextAccount(),
      position: getNextAccount(),
      positionMint: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      token2022Program: getNextAccount()
    },
    data: getClosePositionWithTokenExtensionsInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/collectFees.ts
import {
  combineCodec as combineCodec18,
  fixDecoderSize as fixDecoderSize12,
  fixEncoderSize as fixEncoderSize13,
  getBytesDecoder as getBytesDecoder12,
  getBytesEncoder as getBytesEncoder13,
  getStructDecoder as getStructDecoder17,
  getStructEncoder as getStructEncoder17,
  transformEncoder as transformEncoder12
} from "@solana/web3.js";
var COLLECT_FEES_DISCRIMINATOR = new Uint8Array([
  164,
  152,
  207,
  99,
  30,
  186,
  19,
  182
]);
function getCollectFeesDiscriminatorBytes() {
  return fixEncoderSize13(getBytesEncoder13(), 8).encode(
    COLLECT_FEES_DISCRIMINATOR
  );
}
function getCollectFeesInstructionDataEncoder() {
  return transformEncoder12(
    getStructEncoder17([["discriminator", fixEncoderSize13(getBytesEncoder13(), 8)]]),
    (value) => ({ ...value, discriminator: COLLECT_FEES_DISCRIMINATOR })
  );
}
function getCollectFeesInstructionDataDecoder() {
  return getStructDecoder17([
    ["discriminator", fixDecoderSize12(getBytesDecoder12(), 8)]
  ]);
}
function getCollectFeesInstructionDataCodec() {
  return combineCodec18(
    getCollectFeesInstructionDataEncoder(),
    getCollectFeesInstructionDataDecoder()
  );
}
function getCollectFeesInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    position: { value: input.position ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: false
    },
    tokenOwnerAccountA: {
      value: input.tokenOwnerAccountA ?? null,
      isWritable: true
    },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenOwnerAccountB: {
      value: input.tokenOwnerAccountB ?? null,
      isWritable: true
    },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.tokenOwnerAccountA),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenOwnerAccountB),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tokenProgram)
    ],
    programAddress,
    data: getCollectFeesInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseCollectFeesInstruction(instruction) {
  if (instruction.accounts.length < 9) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      positionAuthority: getNextAccount(),
      position: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      tokenOwnerAccountA: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenOwnerAccountB: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tokenProgram: getNextAccount()
    },
    data: getCollectFeesInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/collectFeesV2.ts
import {
  combineCodec as combineCodec19,
  fixDecoderSize as fixDecoderSize13,
  fixEncoderSize as fixEncoderSize14,
  getBytesDecoder as getBytesDecoder13,
  getBytesEncoder as getBytesEncoder14,
  getOptionDecoder,
  getOptionEncoder,
  getStructDecoder as getStructDecoder18,
  getStructEncoder as getStructEncoder18,
  transformEncoder as transformEncoder13
} from "@solana/web3.js";
var COLLECT_FEES_V2_DISCRIMINATOR = new Uint8Array([
  207,
  117,
  95,
  191,
  229,
  180,
  226,
  15
]);
function getCollectFeesV2DiscriminatorBytes() {
  return fixEncoderSize14(getBytesEncoder14(), 8).encode(
    COLLECT_FEES_V2_DISCRIMINATOR
  );
}
function getCollectFeesV2InstructionDataEncoder() {
  return transformEncoder13(
    getStructEncoder18([
      ["discriminator", fixEncoderSize14(getBytesEncoder14(), 8)],
      [
        "remainingAccountsInfo",
        getOptionEncoder(getRemainingAccountsInfoEncoder())
      ]
    ]),
    (value) => ({ ...value, discriminator: COLLECT_FEES_V2_DISCRIMINATOR })
  );
}
function getCollectFeesV2InstructionDataDecoder() {
  return getStructDecoder18([
    ["discriminator", fixDecoderSize13(getBytesDecoder13(), 8)],
    [
      "remainingAccountsInfo",
      getOptionDecoder(getRemainingAccountsInfoDecoder())
    ]
  ]);
}
function getCollectFeesV2InstructionDataCodec() {
  return combineCodec19(
    getCollectFeesV2InstructionDataEncoder(),
    getCollectFeesV2InstructionDataDecoder()
  );
}
function getCollectFeesV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    position: { value: input.position ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: false
    },
    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },
    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },
    tokenOwnerAccountA: {
      value: input.tokenOwnerAccountA ?? null,
      isWritable: true
    },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenOwnerAccountB: {
      value: input.tokenOwnerAccountB ?? null,
      isWritable: true
    },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tokenProgramA: { value: input.tokenProgramA ?? null, isWritable: false },
    tokenProgramB: { value: input.tokenProgramB ?? null, isWritable: false },
    memoProgram: { value: input.memoProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.tokenMintA),
      getAccountMeta(accounts.tokenMintB),
      getAccountMeta(accounts.tokenOwnerAccountA),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenOwnerAccountB),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tokenProgramA),
      getAccountMeta(accounts.tokenProgramB),
      getAccountMeta(accounts.memoProgram)
    ],
    programAddress,
    data: getCollectFeesV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseCollectFeesV2Instruction(instruction) {
  if (instruction.accounts.length < 13) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      positionAuthority: getNextAccount(),
      position: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      tokenMintA: getNextAccount(),
      tokenMintB: getNextAccount(),
      tokenOwnerAccountA: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenOwnerAccountB: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tokenProgramA: getNextAccount(),
      tokenProgramB: getNextAccount(),
      memoProgram: getNextAccount()
    },
    data: getCollectFeesV2InstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/collectProtocolFees.ts
import {
  combineCodec as combineCodec20,
  fixDecoderSize as fixDecoderSize14,
  fixEncoderSize as fixEncoderSize15,
  getBytesDecoder as getBytesDecoder14,
  getBytesEncoder as getBytesEncoder15,
  getStructDecoder as getStructDecoder19,
  getStructEncoder as getStructEncoder19,
  transformEncoder as transformEncoder14
} from "@solana/web3.js";
var COLLECT_PROTOCOL_FEES_DISCRIMINATOR = new Uint8Array([
  22,
  67,
  23,
  98,
  150,
  178,
  70,
  220
]);
function getCollectProtocolFeesDiscriminatorBytes() {
  return fixEncoderSize15(getBytesEncoder15(), 8).encode(
    COLLECT_PROTOCOL_FEES_DISCRIMINATOR
  );
}
function getCollectProtocolFeesInstructionDataEncoder() {
  return transformEncoder14(
    getStructEncoder19([["discriminator", fixEncoderSize15(getBytesEncoder15(), 8)]]),
    (value) => ({
      ...value,
      discriminator: COLLECT_PROTOCOL_FEES_DISCRIMINATOR
    })
  );
}
function getCollectProtocolFeesInstructionDataDecoder() {
  return getStructDecoder19([
    ["discriminator", fixDecoderSize14(getBytesDecoder14(), 8)]
  ]);
}
function getCollectProtocolFeesInstructionDataCodec() {
  return combineCodec20(
    getCollectProtocolFeesInstructionDataEncoder(),
    getCollectProtocolFeesInstructionDataDecoder()
  );
}
function getCollectProtocolFeesInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    collectProtocolFeesAuthority: {
      value: input.collectProtocolFeesAuthority ?? null,
      isWritable: false
    },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tokenDestinationA: {
      value: input.tokenDestinationA ?? null,
      isWritable: true
    },
    tokenDestinationB: {
      value: input.tokenDestinationB ?? null,
      isWritable: true
    },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.collectProtocolFeesAuthority),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tokenDestinationA),
      getAccountMeta(accounts.tokenDestinationB),
      getAccountMeta(accounts.tokenProgram)
    ],
    programAddress,
    data: getCollectProtocolFeesInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseCollectProtocolFeesInstruction(instruction) {
  if (instruction.accounts.length < 8) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      whirlpool: getNextAccount(),
      collectProtocolFeesAuthority: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tokenDestinationA: getNextAccount(),
      tokenDestinationB: getNextAccount(),
      tokenProgram: getNextAccount()
    },
    data: getCollectProtocolFeesInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/collectProtocolFeesV2.ts
import {
  combineCodec as combineCodec21,
  fixDecoderSize as fixDecoderSize15,
  fixEncoderSize as fixEncoderSize16,
  getBytesDecoder as getBytesDecoder15,
  getBytesEncoder as getBytesEncoder16,
  getOptionDecoder as getOptionDecoder2,
  getOptionEncoder as getOptionEncoder2,
  getStructDecoder as getStructDecoder20,
  getStructEncoder as getStructEncoder20,
  transformEncoder as transformEncoder15
} from "@solana/web3.js";
var COLLECT_PROTOCOL_FEES_V2_DISCRIMINATOR = new Uint8Array([
  103,
  128,
  222,
  134,
  114,
  200,
  22,
  200
]);
function getCollectProtocolFeesV2DiscriminatorBytes() {
  return fixEncoderSize16(getBytesEncoder16(), 8).encode(
    COLLECT_PROTOCOL_FEES_V2_DISCRIMINATOR
  );
}
function getCollectProtocolFeesV2InstructionDataEncoder() {
  return transformEncoder15(
    getStructEncoder20([
      ["discriminator", fixEncoderSize16(getBytesEncoder16(), 8)],
      [
        "remainingAccountsInfo",
        getOptionEncoder2(getRemainingAccountsInfoEncoder())
      ]
    ]),
    (value) => ({
      ...value,
      discriminator: COLLECT_PROTOCOL_FEES_V2_DISCRIMINATOR
    })
  );
}
function getCollectProtocolFeesV2InstructionDataDecoder() {
  return getStructDecoder20([
    ["discriminator", fixDecoderSize15(getBytesDecoder15(), 8)],
    [
      "remainingAccountsInfo",
      getOptionDecoder2(getRemainingAccountsInfoDecoder())
    ]
  ]);
}
function getCollectProtocolFeesV2InstructionDataCodec() {
  return combineCodec21(
    getCollectProtocolFeesV2InstructionDataEncoder(),
    getCollectProtocolFeesV2InstructionDataDecoder()
  );
}
function getCollectProtocolFeesV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    collectProtocolFeesAuthority: {
      value: input.collectProtocolFeesAuthority ?? null,
      isWritable: false
    },
    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },
    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tokenDestinationA: {
      value: input.tokenDestinationA ?? null,
      isWritable: true
    },
    tokenDestinationB: {
      value: input.tokenDestinationB ?? null,
      isWritable: true
    },
    tokenProgramA: { value: input.tokenProgramA ?? null, isWritable: false },
    tokenProgramB: { value: input.tokenProgramB ?? null, isWritable: false },
    memoProgram: { value: input.memoProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.collectProtocolFeesAuthority),
      getAccountMeta(accounts.tokenMintA),
      getAccountMeta(accounts.tokenMintB),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tokenDestinationA),
      getAccountMeta(accounts.tokenDestinationB),
      getAccountMeta(accounts.tokenProgramA),
      getAccountMeta(accounts.tokenProgramB),
      getAccountMeta(accounts.memoProgram)
    ],
    programAddress,
    data: getCollectProtocolFeesV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseCollectProtocolFeesV2Instruction(instruction) {
  if (instruction.accounts.length < 12) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      whirlpool: getNextAccount(),
      collectProtocolFeesAuthority: getNextAccount(),
      tokenMintA: getNextAccount(),
      tokenMintB: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tokenDestinationA: getNextAccount(),
      tokenDestinationB: getNextAccount(),
      tokenProgramA: getNextAccount(),
      tokenProgramB: getNextAccount(),
      memoProgram: getNextAccount()
    },
    data: getCollectProtocolFeesV2InstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/collectReward.ts
import {
  combineCodec as combineCodec22,
  fixDecoderSize as fixDecoderSize16,
  fixEncoderSize as fixEncoderSize17,
  getBytesDecoder as getBytesDecoder16,
  getBytesEncoder as getBytesEncoder17,
  getStructDecoder as getStructDecoder21,
  getStructEncoder as getStructEncoder21,
  getU8Decoder as getU8Decoder2,
  getU8Encoder as getU8Encoder2,
  transformEncoder as transformEncoder16
} from "@solana/web3.js";
var COLLECT_REWARD_DISCRIMINATOR = new Uint8Array([
  70,
  5,
  132,
  87,
  86,
  235,
  177,
  34
]);
function getCollectRewardDiscriminatorBytes() {
  return fixEncoderSize17(getBytesEncoder17(), 8).encode(
    COLLECT_REWARD_DISCRIMINATOR
  );
}
function getCollectRewardInstructionDataEncoder() {
  return transformEncoder16(
    getStructEncoder21([
      ["discriminator", fixEncoderSize17(getBytesEncoder17(), 8)],
      ["rewardIndex", getU8Encoder2()]
    ]),
    (value) => ({ ...value, discriminator: COLLECT_REWARD_DISCRIMINATOR })
  );
}
function getCollectRewardInstructionDataDecoder() {
  return getStructDecoder21([
    ["discriminator", fixDecoderSize16(getBytesDecoder16(), 8)],
    ["rewardIndex", getU8Decoder2()]
  ]);
}
function getCollectRewardInstructionDataCodec() {
  return combineCodec22(
    getCollectRewardInstructionDataEncoder(),
    getCollectRewardInstructionDataDecoder()
  );
}
function getCollectRewardInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    position: { value: input.position ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: false
    },
    rewardOwnerAccount: {
      value: input.rewardOwnerAccount ?? null,
      isWritable: true
    },
    rewardVault: { value: input.rewardVault ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.rewardOwnerAccount),
      getAccountMeta(accounts.rewardVault),
      getAccountMeta(accounts.tokenProgram)
    ],
    programAddress,
    data: getCollectRewardInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseCollectRewardInstruction(instruction) {
  if (instruction.accounts.length < 7) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      positionAuthority: getNextAccount(),
      position: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      rewardOwnerAccount: getNextAccount(),
      rewardVault: getNextAccount(),
      tokenProgram: getNextAccount()
    },
    data: getCollectRewardInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/collectRewardV2.ts
import {
  combineCodec as combineCodec23,
  fixDecoderSize as fixDecoderSize17,
  fixEncoderSize as fixEncoderSize18,
  getBytesDecoder as getBytesDecoder17,
  getBytesEncoder as getBytesEncoder18,
  getOptionDecoder as getOptionDecoder3,
  getOptionEncoder as getOptionEncoder3,
  getStructDecoder as getStructDecoder22,
  getStructEncoder as getStructEncoder22,
  getU8Decoder as getU8Decoder3,
  getU8Encoder as getU8Encoder3,
  transformEncoder as transformEncoder17
} from "@solana/web3.js";
var COLLECT_REWARD_V2_DISCRIMINATOR = new Uint8Array([
  177,
  107,
  37,
  180,
  160,
  19,
  49,
  209
]);
function getCollectRewardV2DiscriminatorBytes() {
  return fixEncoderSize18(getBytesEncoder18(), 8).encode(
    COLLECT_REWARD_V2_DISCRIMINATOR
  );
}
function getCollectRewardV2InstructionDataEncoder() {
  return transformEncoder17(
    getStructEncoder22([
      ["discriminator", fixEncoderSize18(getBytesEncoder18(), 8)],
      ["rewardIndex", getU8Encoder3()],
      [
        "remainingAccountsInfo",
        getOptionEncoder3(getRemainingAccountsInfoEncoder())
      ]
    ]),
    (value) => ({ ...value, discriminator: COLLECT_REWARD_V2_DISCRIMINATOR })
  );
}
function getCollectRewardV2InstructionDataDecoder() {
  return getStructDecoder22([
    ["discriminator", fixDecoderSize17(getBytesDecoder17(), 8)],
    ["rewardIndex", getU8Decoder3()],
    [
      "remainingAccountsInfo",
      getOptionDecoder3(getRemainingAccountsInfoDecoder())
    ]
  ]);
}
function getCollectRewardV2InstructionDataCodec() {
  return combineCodec23(
    getCollectRewardV2InstructionDataEncoder(),
    getCollectRewardV2InstructionDataDecoder()
  );
}
function getCollectRewardV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    position: { value: input.position ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: false
    },
    rewardOwnerAccount: {
      value: input.rewardOwnerAccount ?? null,
      isWritable: true
    },
    rewardMint: { value: input.rewardMint ?? null, isWritable: false },
    rewardVault: { value: input.rewardVault ?? null, isWritable: true },
    rewardTokenProgram: {
      value: input.rewardTokenProgram ?? null,
      isWritable: false
    },
    memoProgram: { value: input.memoProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.rewardOwnerAccount),
      getAccountMeta(accounts.rewardMint),
      getAccountMeta(accounts.rewardVault),
      getAccountMeta(accounts.rewardTokenProgram),
      getAccountMeta(accounts.memoProgram)
    ],
    programAddress,
    data: getCollectRewardV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseCollectRewardV2Instruction(instruction) {
  if (instruction.accounts.length < 9) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      positionAuthority: getNextAccount(),
      position: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      rewardOwnerAccount: getNextAccount(),
      rewardMint: getNextAccount(),
      rewardVault: getNextAccount(),
      rewardTokenProgram: getNextAccount(),
      memoProgram: getNextAccount()
    },
    data: getCollectRewardV2InstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/decreaseLiquidity.ts
import {
  combineCodec as combineCodec24,
  fixDecoderSize as fixDecoderSize18,
  fixEncoderSize as fixEncoderSize19,
  getBytesDecoder as getBytesDecoder18,
  getBytesEncoder as getBytesEncoder19,
  getStructDecoder as getStructDecoder23,
  getStructEncoder as getStructEncoder23,
  getU128Decoder as getU128Decoder6,
  getU128Encoder as getU128Encoder6,
  getU64Decoder as getU64Decoder4,
  getU64Encoder as getU64Encoder4,
  transformEncoder as transformEncoder18
} from "@solana/web3.js";
var DECREASE_LIQUIDITY_DISCRIMINATOR = new Uint8Array([
  160,
  38,
  208,
  111,
  104,
  91,
  44,
  1
]);
function getDecreaseLiquidityDiscriminatorBytes() {
  return fixEncoderSize19(getBytesEncoder19(), 8).encode(
    DECREASE_LIQUIDITY_DISCRIMINATOR
  );
}
function getDecreaseLiquidityInstructionDataEncoder() {
  return transformEncoder18(
    getStructEncoder23([
      ["discriminator", fixEncoderSize19(getBytesEncoder19(), 8)],
      ["liquidityAmount", getU128Encoder6()],
      ["tokenMinA", getU64Encoder4()],
      ["tokenMinB", getU64Encoder4()]
    ]),
    (value) => ({ ...value, discriminator: DECREASE_LIQUIDITY_DISCRIMINATOR })
  );
}
function getDecreaseLiquidityInstructionDataDecoder() {
  return getStructDecoder23([
    ["discriminator", fixDecoderSize18(getBytesDecoder18(), 8)],
    ["liquidityAmount", getU128Decoder6()],
    ["tokenMinA", getU64Decoder4()],
    ["tokenMinB", getU64Decoder4()]
  ]);
}
function getDecreaseLiquidityInstructionDataCodec() {
  return combineCodec24(
    getDecreaseLiquidityInstructionDataEncoder(),
    getDecreaseLiquidityInstructionDataDecoder()
  );
}
function getDecreaseLiquidityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    position: { value: input.position ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: false
    },
    tokenOwnerAccountA: {
      value: input.tokenOwnerAccountA ?? null,
      isWritable: true
    },
    tokenOwnerAccountB: {
      value: input.tokenOwnerAccountB ?? null,
      isWritable: true
    },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tickArrayLower: { value: input.tickArrayLower ?? null, isWritable: true },
    tickArrayUpper: { value: input.tickArrayUpper ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.tokenOwnerAccountA),
      getAccountMeta(accounts.tokenOwnerAccountB),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tickArrayLower),
      getAccountMeta(accounts.tickArrayUpper)
    ],
    programAddress,
    data: getDecreaseLiquidityInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseDecreaseLiquidityInstruction(instruction) {
  if (instruction.accounts.length < 11) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      tokenProgram: getNextAccount(),
      positionAuthority: getNextAccount(),
      position: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      tokenOwnerAccountA: getNextAccount(),
      tokenOwnerAccountB: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tickArrayLower: getNextAccount(),
      tickArrayUpper: getNextAccount()
    },
    data: getDecreaseLiquidityInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/decreaseLiquidityV2.ts
import {
  combineCodec as combineCodec25,
  fixDecoderSize as fixDecoderSize19,
  fixEncoderSize as fixEncoderSize20,
  getBytesDecoder as getBytesDecoder19,
  getBytesEncoder as getBytesEncoder20,
  getOptionDecoder as getOptionDecoder4,
  getOptionEncoder as getOptionEncoder4,
  getStructDecoder as getStructDecoder24,
  getStructEncoder as getStructEncoder24,
  getU128Decoder as getU128Decoder7,
  getU128Encoder as getU128Encoder7,
  getU64Decoder as getU64Decoder5,
  getU64Encoder as getU64Encoder5,
  transformEncoder as transformEncoder19
} from "@solana/web3.js";
var DECREASE_LIQUIDITY_V2_DISCRIMINATOR = new Uint8Array([
  58,
  127,
  188,
  62,
  79,
  82,
  196,
  96
]);
function getDecreaseLiquidityV2DiscriminatorBytes() {
  return fixEncoderSize20(getBytesEncoder20(), 8).encode(
    DECREASE_LIQUIDITY_V2_DISCRIMINATOR
  );
}
function getDecreaseLiquidityV2InstructionDataEncoder() {
  return transformEncoder19(
    getStructEncoder24([
      ["discriminator", fixEncoderSize20(getBytesEncoder20(), 8)],
      ["liquidityAmount", getU128Encoder7()],
      ["tokenMinA", getU64Encoder5()],
      ["tokenMinB", getU64Encoder5()],
      [
        "remainingAccountsInfo",
        getOptionEncoder4(getRemainingAccountsInfoEncoder())
      ]
    ]),
    (value) => ({
      ...value,
      discriminator: DECREASE_LIQUIDITY_V2_DISCRIMINATOR
    })
  );
}
function getDecreaseLiquidityV2InstructionDataDecoder() {
  return getStructDecoder24([
    ["discriminator", fixDecoderSize19(getBytesDecoder19(), 8)],
    ["liquidityAmount", getU128Decoder7()],
    ["tokenMinA", getU64Decoder5()],
    ["tokenMinB", getU64Decoder5()],
    [
      "remainingAccountsInfo",
      getOptionDecoder4(getRemainingAccountsInfoDecoder())
    ]
  ]);
}
function getDecreaseLiquidityV2InstructionDataCodec() {
  return combineCodec25(
    getDecreaseLiquidityV2InstructionDataEncoder(),
    getDecreaseLiquidityV2InstructionDataDecoder()
  );
}
function getDecreaseLiquidityV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    tokenProgramA: { value: input.tokenProgramA ?? null, isWritable: false },
    tokenProgramB: { value: input.tokenProgramB ?? null, isWritable: false },
    memoProgram: { value: input.memoProgram ?? null, isWritable: false },
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    position: { value: input.position ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: false
    },
    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },
    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },
    tokenOwnerAccountA: {
      value: input.tokenOwnerAccountA ?? null,
      isWritable: true
    },
    tokenOwnerAccountB: {
      value: input.tokenOwnerAccountB ?? null,
      isWritable: true
    },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tickArrayLower: { value: input.tickArrayLower ?? null, isWritable: true },
    tickArrayUpper: { value: input.tickArrayUpper ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenProgramA),
      getAccountMeta(accounts.tokenProgramB),
      getAccountMeta(accounts.memoProgram),
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.tokenMintA),
      getAccountMeta(accounts.tokenMintB),
      getAccountMeta(accounts.tokenOwnerAccountA),
      getAccountMeta(accounts.tokenOwnerAccountB),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tickArrayLower),
      getAccountMeta(accounts.tickArrayUpper)
    ],
    programAddress,
    data: getDecreaseLiquidityV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseDecreaseLiquidityV2Instruction(instruction) {
  if (instruction.accounts.length < 15) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      tokenProgramA: getNextAccount(),
      tokenProgramB: getNextAccount(),
      memoProgram: getNextAccount(),
      positionAuthority: getNextAccount(),
      position: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      tokenMintA: getNextAccount(),
      tokenMintB: getNextAccount(),
      tokenOwnerAccountA: getNextAccount(),
      tokenOwnerAccountB: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tickArrayLower: getNextAccount(),
      tickArrayUpper: getNextAccount()
    },
    data: getDecreaseLiquidityV2InstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/deletePositionBundle.ts
import {
  combineCodec as combineCodec26,
  fixDecoderSize as fixDecoderSize20,
  fixEncoderSize as fixEncoderSize21,
  getBytesDecoder as getBytesDecoder20,
  getBytesEncoder as getBytesEncoder21,
  getStructDecoder as getStructDecoder25,
  getStructEncoder as getStructEncoder25,
  transformEncoder as transformEncoder20
} from "@solana/web3.js";
var DELETE_POSITION_BUNDLE_DISCRIMINATOR = new Uint8Array([
  100,
  25,
  99,
  2,
  217,
  239,
  124,
  173
]);
function getDeletePositionBundleDiscriminatorBytes() {
  return fixEncoderSize21(getBytesEncoder21(), 8).encode(
    DELETE_POSITION_BUNDLE_DISCRIMINATOR
  );
}
function getDeletePositionBundleInstructionDataEncoder() {
  return transformEncoder20(
    getStructEncoder25([["discriminator", fixEncoderSize21(getBytesEncoder21(), 8)]]),
    (value) => ({
      ...value,
      discriminator: DELETE_POSITION_BUNDLE_DISCRIMINATOR
    })
  );
}
function getDeletePositionBundleInstructionDataDecoder() {
  return getStructDecoder25([
    ["discriminator", fixDecoderSize20(getBytesDecoder20(), 8)]
  ]);
}
function getDeletePositionBundleInstructionDataCodec() {
  return combineCodec26(
    getDeletePositionBundleInstructionDataEncoder(),
    getDeletePositionBundleInstructionDataDecoder()
  );
}
function getDeletePositionBundleInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    positionBundle: { value: input.positionBundle ?? null, isWritable: true },
    positionBundleMint: {
      value: input.positionBundleMint ?? null,
      isWritable: true
    },
    positionBundleTokenAccount: {
      value: input.positionBundleTokenAccount ?? null,
      isWritable: true
    },
    positionBundleOwner: {
      value: input.positionBundleOwner ?? null,
      isWritable: false
    },
    receiver: { value: input.receiver ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.positionBundle),
      getAccountMeta(accounts.positionBundleMint),
      getAccountMeta(accounts.positionBundleTokenAccount),
      getAccountMeta(accounts.positionBundleOwner),
      getAccountMeta(accounts.receiver),
      getAccountMeta(accounts.tokenProgram)
    ],
    programAddress,
    data: getDeletePositionBundleInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseDeletePositionBundleInstruction(instruction) {
  if (instruction.accounts.length < 6) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      positionBundle: getNextAccount(),
      positionBundleMint: getNextAccount(),
      positionBundleTokenAccount: getNextAccount(),
      positionBundleOwner: getNextAccount(),
      receiver: getNextAccount(),
      tokenProgram: getNextAccount()
    },
    data: getDeletePositionBundleInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/deleteTokenBadge.ts
import {
  combineCodec as combineCodec27,
  fixDecoderSize as fixDecoderSize21,
  fixEncoderSize as fixEncoderSize22,
  getBytesDecoder as getBytesDecoder21,
  getBytesEncoder as getBytesEncoder22,
  getStructDecoder as getStructDecoder26,
  getStructEncoder as getStructEncoder26,
  transformEncoder as transformEncoder21
} from "@solana/web3.js";
var DELETE_TOKEN_BADGE_DISCRIMINATOR = new Uint8Array([
  53,
  146,
  68,
  8,
  18,
  117,
  17,
  185
]);
function getDeleteTokenBadgeDiscriminatorBytes() {
  return fixEncoderSize22(getBytesEncoder22(), 8).encode(
    DELETE_TOKEN_BADGE_DISCRIMINATOR
  );
}
function getDeleteTokenBadgeInstructionDataEncoder() {
  return transformEncoder21(
    getStructEncoder26([["discriminator", fixEncoderSize22(getBytesEncoder22(), 8)]]),
    (value) => ({ ...value, discriminator: DELETE_TOKEN_BADGE_DISCRIMINATOR })
  );
}
function getDeleteTokenBadgeInstructionDataDecoder() {
  return getStructDecoder26([
    ["discriminator", fixDecoderSize21(getBytesDecoder21(), 8)]
  ]);
}
function getDeleteTokenBadgeInstructionDataCodec() {
  return combineCodec27(
    getDeleteTokenBadgeInstructionDataEncoder(),
    getDeleteTokenBadgeInstructionDataDecoder()
  );
}
function getDeleteTokenBadgeInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    whirlpoolsConfigExtension: {
      value: input.whirlpoolsConfigExtension ?? null,
      isWritable: false
    },
    tokenBadgeAuthority: {
      value: input.tokenBadgeAuthority ?? null,
      isWritable: false
    },
    tokenMint: { value: input.tokenMint ?? null, isWritable: false },
    tokenBadge: { value: input.tokenBadge ?? null, isWritable: true },
    receiver: { value: input.receiver ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.whirlpoolsConfigExtension),
      getAccountMeta(accounts.tokenBadgeAuthority),
      getAccountMeta(accounts.tokenMint),
      getAccountMeta(accounts.tokenBadge),
      getAccountMeta(accounts.receiver)
    ],
    programAddress,
    data: getDeleteTokenBadgeInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseDeleteTokenBadgeInstruction(instruction) {
  if (instruction.accounts.length < 6) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      whirlpoolsConfigExtension: getNextAccount(),
      tokenBadgeAuthority: getNextAccount(),
      tokenMint: getNextAccount(),
      tokenBadge: getNextAccount(),
      receiver: getNextAccount()
    },
    data: getDeleteTokenBadgeInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/increaseLiquidity.ts
import {
  combineCodec as combineCodec28,
  fixDecoderSize as fixDecoderSize22,
  fixEncoderSize as fixEncoderSize23,
  getBytesDecoder as getBytesDecoder22,
  getBytesEncoder as getBytesEncoder23,
  getStructDecoder as getStructDecoder27,
  getStructEncoder as getStructEncoder27,
  getU128Decoder as getU128Decoder8,
  getU128Encoder as getU128Encoder8,
  getU64Decoder as getU64Decoder6,
  getU64Encoder as getU64Encoder6,
  transformEncoder as transformEncoder22
} from "@solana/web3.js";
var INCREASE_LIQUIDITY_DISCRIMINATOR = new Uint8Array([
  46,
  156,
  243,
  118,
  13,
  205,
  251,
  178
]);
function getIncreaseLiquidityDiscriminatorBytes() {
  return fixEncoderSize23(getBytesEncoder23(), 8).encode(
    INCREASE_LIQUIDITY_DISCRIMINATOR
  );
}
function getIncreaseLiquidityInstructionDataEncoder() {
  return transformEncoder22(
    getStructEncoder27([
      ["discriminator", fixEncoderSize23(getBytesEncoder23(), 8)],
      ["liquidityAmount", getU128Encoder8()],
      ["tokenMaxA", getU64Encoder6()],
      ["tokenMaxB", getU64Encoder6()]
    ]),
    (value) => ({ ...value, discriminator: INCREASE_LIQUIDITY_DISCRIMINATOR })
  );
}
function getIncreaseLiquidityInstructionDataDecoder() {
  return getStructDecoder27([
    ["discriminator", fixDecoderSize22(getBytesDecoder22(), 8)],
    ["liquidityAmount", getU128Decoder8()],
    ["tokenMaxA", getU64Decoder6()],
    ["tokenMaxB", getU64Decoder6()]
  ]);
}
function getIncreaseLiquidityInstructionDataCodec() {
  return combineCodec28(
    getIncreaseLiquidityInstructionDataEncoder(),
    getIncreaseLiquidityInstructionDataDecoder()
  );
}
function getIncreaseLiquidityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    position: { value: input.position ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: false
    },
    tokenOwnerAccountA: {
      value: input.tokenOwnerAccountA ?? null,
      isWritable: true
    },
    tokenOwnerAccountB: {
      value: input.tokenOwnerAccountB ?? null,
      isWritable: true
    },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tickArrayLower: { value: input.tickArrayLower ?? null, isWritable: true },
    tickArrayUpper: { value: input.tickArrayUpper ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.tokenOwnerAccountA),
      getAccountMeta(accounts.tokenOwnerAccountB),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tickArrayLower),
      getAccountMeta(accounts.tickArrayUpper)
    ],
    programAddress,
    data: getIncreaseLiquidityInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseIncreaseLiquidityInstruction(instruction) {
  if (instruction.accounts.length < 11) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      tokenProgram: getNextAccount(),
      positionAuthority: getNextAccount(),
      position: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      tokenOwnerAccountA: getNextAccount(),
      tokenOwnerAccountB: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tickArrayLower: getNextAccount(),
      tickArrayUpper: getNextAccount()
    },
    data: getIncreaseLiquidityInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/increaseLiquidityV2.ts
import {
  combineCodec as combineCodec29,
  fixDecoderSize as fixDecoderSize23,
  fixEncoderSize as fixEncoderSize24,
  getBytesDecoder as getBytesDecoder23,
  getBytesEncoder as getBytesEncoder24,
  getOptionDecoder as getOptionDecoder5,
  getOptionEncoder as getOptionEncoder5,
  getStructDecoder as getStructDecoder28,
  getStructEncoder as getStructEncoder28,
  getU128Decoder as getU128Decoder9,
  getU128Encoder as getU128Encoder9,
  getU64Decoder as getU64Decoder7,
  getU64Encoder as getU64Encoder7,
  transformEncoder as transformEncoder23
} from "@solana/web3.js";
var INCREASE_LIQUIDITY_V2_DISCRIMINATOR = new Uint8Array([
  133,
  29,
  89,
  223,
  69,
  238,
  176,
  10
]);
function getIncreaseLiquidityV2DiscriminatorBytes() {
  return fixEncoderSize24(getBytesEncoder24(), 8).encode(
    INCREASE_LIQUIDITY_V2_DISCRIMINATOR
  );
}
function getIncreaseLiquidityV2InstructionDataEncoder() {
  return transformEncoder23(
    getStructEncoder28([
      ["discriminator", fixEncoderSize24(getBytesEncoder24(), 8)],
      ["liquidityAmount", getU128Encoder9()],
      ["tokenMaxA", getU64Encoder7()],
      ["tokenMaxB", getU64Encoder7()],
      [
        "remainingAccountsInfo",
        getOptionEncoder5(getRemainingAccountsInfoEncoder())
      ]
    ]),
    (value) => ({
      ...value,
      discriminator: INCREASE_LIQUIDITY_V2_DISCRIMINATOR
    })
  );
}
function getIncreaseLiquidityV2InstructionDataDecoder() {
  return getStructDecoder28([
    ["discriminator", fixDecoderSize23(getBytesDecoder23(), 8)],
    ["liquidityAmount", getU128Decoder9()],
    ["tokenMaxA", getU64Decoder7()],
    ["tokenMaxB", getU64Decoder7()],
    [
      "remainingAccountsInfo",
      getOptionDecoder5(getRemainingAccountsInfoDecoder())
    ]
  ]);
}
function getIncreaseLiquidityV2InstructionDataCodec() {
  return combineCodec29(
    getIncreaseLiquidityV2InstructionDataEncoder(),
    getIncreaseLiquidityV2InstructionDataDecoder()
  );
}
function getIncreaseLiquidityV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    tokenProgramA: { value: input.tokenProgramA ?? null, isWritable: false },
    tokenProgramB: { value: input.tokenProgramB ?? null, isWritable: false },
    memoProgram: { value: input.memoProgram ?? null, isWritable: false },
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    position: { value: input.position ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: false
    },
    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },
    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },
    tokenOwnerAccountA: {
      value: input.tokenOwnerAccountA ?? null,
      isWritable: true
    },
    tokenOwnerAccountB: {
      value: input.tokenOwnerAccountB ?? null,
      isWritable: true
    },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tickArrayLower: { value: input.tickArrayLower ?? null, isWritable: true },
    tickArrayUpper: { value: input.tickArrayUpper ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenProgramA),
      getAccountMeta(accounts.tokenProgramB),
      getAccountMeta(accounts.memoProgram),
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.tokenMintA),
      getAccountMeta(accounts.tokenMintB),
      getAccountMeta(accounts.tokenOwnerAccountA),
      getAccountMeta(accounts.tokenOwnerAccountB),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tickArrayLower),
      getAccountMeta(accounts.tickArrayUpper)
    ],
    programAddress,
    data: getIncreaseLiquidityV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseIncreaseLiquidityV2Instruction(instruction) {
  if (instruction.accounts.length < 15) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      tokenProgramA: getNextAccount(),
      tokenProgramB: getNextAccount(),
      memoProgram: getNextAccount(),
      positionAuthority: getNextAccount(),
      position: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      tokenMintA: getNextAccount(),
      tokenMintB: getNextAccount(),
      tokenOwnerAccountA: getNextAccount(),
      tokenOwnerAccountB: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tickArrayLower: getNextAccount(),
      tickArrayUpper: getNextAccount()
    },
    data: getIncreaseLiquidityV2InstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/initializeConfig.ts
import {
  combineCodec as combineCodec30,
  fixDecoderSize as fixDecoderSize24,
  fixEncoderSize as fixEncoderSize25,
  getAddressDecoder as getAddressDecoder10,
  getAddressEncoder as getAddressEncoder10,
  getBytesDecoder as getBytesDecoder24,
  getBytesEncoder as getBytesEncoder25,
  getStructDecoder as getStructDecoder29,
  getStructEncoder as getStructEncoder29,
  getU16Decoder as getU16Decoder5,
  getU16Encoder as getU16Encoder5,
  transformEncoder as transformEncoder24
} from "@solana/web3.js";
var INITIALIZE_CONFIG_DISCRIMINATOR = new Uint8Array([
  208,
  127,
  21,
  1,
  194,
  190,
  196,
  70
]);
function getInitializeConfigDiscriminatorBytes() {
  return fixEncoderSize25(getBytesEncoder25(), 8).encode(
    INITIALIZE_CONFIG_DISCRIMINATOR
  );
}
function getInitializeConfigInstructionDataEncoder() {
  return transformEncoder24(
    getStructEncoder29([
      ["discriminator", fixEncoderSize25(getBytesEncoder25(), 8)],
      ["feeAuthority", getAddressEncoder10()],
      ["collectProtocolFeesAuthority", getAddressEncoder10()],
      ["rewardEmissionsSuperAuthority", getAddressEncoder10()],
      ["defaultProtocolFeeRate", getU16Encoder5()]
    ]),
    (value) => ({ ...value, discriminator: INITIALIZE_CONFIG_DISCRIMINATOR })
  );
}
function getInitializeConfigInstructionDataDecoder() {
  return getStructDecoder29([
    ["discriminator", fixDecoderSize24(getBytesDecoder24(), 8)],
    ["feeAuthority", getAddressDecoder10()],
    ["collectProtocolFeesAuthority", getAddressDecoder10()],
    ["rewardEmissionsSuperAuthority", getAddressDecoder10()],
    ["defaultProtocolFeeRate", getU16Decoder5()]
  ]);
}
function getInitializeConfigInstructionDataCodec() {
  return combineCodec30(
    getInitializeConfigInstructionDataEncoder(),
    getInitializeConfigInstructionDataDecoder()
  );
}
function getInitializeConfigInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    config: { value: input.config ?? null, isWritable: true },
    funder: { value: input.funder ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.config),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.systemProgram)
    ],
    programAddress,
    data: getInitializeConfigInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeConfigInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      config: getNextAccount(),
      funder: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getInitializeConfigInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/initializeConfigExtension.ts
import {
  combineCodec as combineCodec31,
  fixDecoderSize as fixDecoderSize25,
  fixEncoderSize as fixEncoderSize26,
  getBytesDecoder as getBytesDecoder25,
  getBytesEncoder as getBytesEncoder26,
  getStructDecoder as getStructDecoder30,
  getStructEncoder as getStructEncoder30,
  transformEncoder as transformEncoder25
} from "@solana/web3.js";
var INITIALIZE_CONFIG_EXTENSION_DISCRIMINATOR = new Uint8Array([
  55,
  9,
  53,
  9,
  114,
  57,
  209,
  52
]);
function getInitializeConfigExtensionDiscriminatorBytes() {
  return fixEncoderSize26(getBytesEncoder26(), 8).encode(
    INITIALIZE_CONFIG_EXTENSION_DISCRIMINATOR
  );
}
function getInitializeConfigExtensionInstructionDataEncoder() {
  return transformEncoder25(
    getStructEncoder30([["discriminator", fixEncoderSize26(getBytesEncoder26(), 8)]]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_CONFIG_EXTENSION_DISCRIMINATOR
    })
  );
}
function getInitializeConfigExtensionInstructionDataDecoder() {
  return getStructDecoder30([
    ["discriminator", fixDecoderSize25(getBytesDecoder25(), 8)]
  ]);
}
function getInitializeConfigExtensionInstructionDataCodec() {
  return combineCodec31(
    getInitializeConfigExtensionInstructionDataEncoder(),
    getInitializeConfigExtensionInstructionDataDecoder()
  );
}
function getInitializeConfigExtensionInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    config: { value: input.config ?? null, isWritable: false },
    configExtension: { value: input.configExtension ?? null, isWritable: true },
    funder: { value: input.funder ?? null, isWritable: true },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.config),
      getAccountMeta(accounts.configExtension),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.feeAuthority),
      getAccountMeta(accounts.systemProgram)
    ],
    programAddress,
    data: getInitializeConfigExtensionInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseInitializeConfigExtensionInstruction(instruction) {
  if (instruction.accounts.length < 5) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      config: getNextAccount(),
      configExtension: getNextAccount(),
      funder: getNextAccount(),
      feeAuthority: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getInitializeConfigExtensionInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/initializeFeeTier.ts
import {
  combineCodec as combineCodec32,
  fixDecoderSize as fixDecoderSize26,
  fixEncoderSize as fixEncoderSize27,
  getBytesDecoder as getBytesDecoder26,
  getBytesEncoder as getBytesEncoder27,
  getStructDecoder as getStructDecoder31,
  getStructEncoder as getStructEncoder31,
  getU16Decoder as getU16Decoder6,
  getU16Encoder as getU16Encoder6,
  transformEncoder as transformEncoder26
} from "@solana/web3.js";
var INITIALIZE_FEE_TIER_DISCRIMINATOR = new Uint8Array([
  183,
  74,
  156,
  160,
  112,
  2,
  42,
  30
]);
function getInitializeFeeTierDiscriminatorBytes() {
  return fixEncoderSize27(getBytesEncoder27(), 8).encode(
    INITIALIZE_FEE_TIER_DISCRIMINATOR
  );
}
function getInitializeFeeTierInstructionDataEncoder() {
  return transformEncoder26(
    getStructEncoder31([
      ["discriminator", fixEncoderSize27(getBytesEncoder27(), 8)],
      ["tickSpacing", getU16Encoder6()],
      ["defaultFeeRate", getU16Encoder6()]
    ]),
    (value) => ({ ...value, discriminator: INITIALIZE_FEE_TIER_DISCRIMINATOR })
  );
}
function getInitializeFeeTierInstructionDataDecoder() {
  return getStructDecoder31([
    ["discriminator", fixDecoderSize26(getBytesDecoder26(), 8)],
    ["tickSpacing", getU16Decoder6()],
    ["defaultFeeRate", getU16Decoder6()]
  ]);
}
function getInitializeFeeTierInstructionDataCodec() {
  return combineCodec32(
    getInitializeFeeTierInstructionDataEncoder(),
    getInitializeFeeTierInstructionDataDecoder()
  );
}
function getInitializeFeeTierInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    config: { value: input.config ?? null, isWritable: false },
    feeTier: { value: input.feeTier ?? null, isWritable: true },
    funder: { value: input.funder ?? null, isWritable: true },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.config),
      getAccountMeta(accounts.feeTier),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.feeAuthority),
      getAccountMeta(accounts.systemProgram)
    ],
    programAddress,
    data: getInitializeFeeTierInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeFeeTierInstruction(instruction) {
  if (instruction.accounts.length < 5) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      config: getNextAccount(),
      feeTier: getNextAccount(),
      funder: getNextAccount(),
      feeAuthority: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getInitializeFeeTierInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/initializePool.ts
import {
  combineCodec as combineCodec33,
  fixDecoderSize as fixDecoderSize27,
  fixEncoderSize as fixEncoderSize28,
  getBytesDecoder as getBytesDecoder27,
  getBytesEncoder as getBytesEncoder28,
  getStructDecoder as getStructDecoder32,
  getStructEncoder as getStructEncoder32,
  getU128Decoder as getU128Decoder10,
  getU128Encoder as getU128Encoder10,
  getU16Decoder as getU16Decoder7,
  getU16Encoder as getU16Encoder7,
  getU8Decoder as getU8Decoder4,
  getU8Encoder as getU8Encoder4,
  transformEncoder as transformEncoder27
} from "@solana/web3.js";
var INITIALIZE_POOL_DISCRIMINATOR = new Uint8Array([
  95,
  180,
  10,
  172,
  84,
  174,
  232,
  40
]);
function getInitializePoolDiscriminatorBytes() {
  return fixEncoderSize28(getBytesEncoder28(), 8).encode(
    INITIALIZE_POOL_DISCRIMINATOR
  );
}
function getInitializePoolInstructionDataEncoder() {
  return transformEncoder27(
    getStructEncoder32([
      ["discriminator", fixEncoderSize28(getBytesEncoder28(), 8)],
      ["whirlpoolBump", getU8Encoder4()],
      ["tickSpacing", getU16Encoder7()],
      ["initialSqrtPrice", getU128Encoder10()]
    ]),
    (value) => ({ ...value, discriminator: INITIALIZE_POOL_DISCRIMINATOR })
  );
}
function getInitializePoolInstructionDataDecoder() {
  return getStructDecoder32([
    ["discriminator", fixDecoderSize27(getBytesDecoder27(), 8)],
    ["whirlpoolBump", getU8Decoder4()],
    ["tickSpacing", getU16Decoder7()],
    ["initialSqrtPrice", getU128Decoder10()]
  ]);
}
function getInitializePoolInstructionDataCodec() {
  return combineCodec33(
    getInitializePoolInstructionDataEncoder(),
    getInitializePoolInstructionDataDecoder()
  );
}
function getInitializePoolInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },
    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },
    funder: { value: input.funder ?? null, isWritable: true },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    feeTier: { value: input.feeTier ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.tokenMintA),
      getAccountMeta(accounts.tokenMintB),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.feeTier),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent)
    ],
    programAddress,
    data: getInitializePoolInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializePoolInstruction(instruction) {
  if (instruction.accounts.length < 11) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      tokenMintA: getNextAccount(),
      tokenMintB: getNextAccount(),
      funder: getNextAccount(),
      whirlpool: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenVaultB: getNextAccount(),
      feeTier: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount()
    },
    data: getInitializePoolInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/initializePoolV2.ts
import {
  combineCodec as combineCodec34,
  fixDecoderSize as fixDecoderSize28,
  fixEncoderSize as fixEncoderSize29,
  getBytesDecoder as getBytesDecoder28,
  getBytesEncoder as getBytesEncoder29,
  getStructDecoder as getStructDecoder33,
  getStructEncoder as getStructEncoder33,
  getU128Decoder as getU128Decoder11,
  getU128Encoder as getU128Encoder11,
  getU16Decoder as getU16Decoder8,
  getU16Encoder as getU16Encoder8,
  transformEncoder as transformEncoder28
} from "@solana/web3.js";
var INITIALIZE_POOL_V2_DISCRIMINATOR = new Uint8Array([
  207,
  45,
  87,
  242,
  27,
  63,
  204,
  67
]);
function getInitializePoolV2DiscriminatorBytes() {
  return fixEncoderSize29(getBytesEncoder29(), 8).encode(
    INITIALIZE_POOL_V2_DISCRIMINATOR
  );
}
function getInitializePoolV2InstructionDataEncoder() {
  return transformEncoder28(
    getStructEncoder33([
      ["discriminator", fixEncoderSize29(getBytesEncoder29(), 8)],
      ["tickSpacing", getU16Encoder8()],
      ["initialSqrtPrice", getU128Encoder11()]
    ]),
    (value) => ({ ...value, discriminator: INITIALIZE_POOL_V2_DISCRIMINATOR })
  );
}
function getInitializePoolV2InstructionDataDecoder() {
  return getStructDecoder33([
    ["discriminator", fixDecoderSize28(getBytesDecoder28(), 8)],
    ["tickSpacing", getU16Decoder8()],
    ["initialSqrtPrice", getU128Decoder11()]
  ]);
}
function getInitializePoolV2InstructionDataCodec() {
  return combineCodec34(
    getInitializePoolV2InstructionDataEncoder(),
    getInitializePoolV2InstructionDataDecoder()
  );
}
function getInitializePoolV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },
    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },
    tokenBadgeA: { value: input.tokenBadgeA ?? null, isWritable: false },
    tokenBadgeB: { value: input.tokenBadgeB ?? null, isWritable: false },
    funder: { value: input.funder ?? null, isWritable: true },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    feeTier: { value: input.feeTier ?? null, isWritable: false },
    tokenProgramA: { value: input.tokenProgramA ?? null, isWritable: false },
    tokenProgramB: { value: input.tokenProgramB ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.tokenMintA),
      getAccountMeta(accounts.tokenMintB),
      getAccountMeta(accounts.tokenBadgeA),
      getAccountMeta(accounts.tokenBadgeB),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.feeTier),
      getAccountMeta(accounts.tokenProgramA),
      getAccountMeta(accounts.tokenProgramB),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent)
    ],
    programAddress,
    data: getInitializePoolV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializePoolV2Instruction(instruction) {
  if (instruction.accounts.length < 14) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      tokenMintA: getNextAccount(),
      tokenMintB: getNextAccount(),
      tokenBadgeA: getNextAccount(),
      tokenBadgeB: getNextAccount(),
      funder: getNextAccount(),
      whirlpool: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenVaultB: getNextAccount(),
      feeTier: getNextAccount(),
      tokenProgramA: getNextAccount(),
      tokenProgramB: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount()
    },
    data: getInitializePoolV2InstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/initializePositionBundle.ts
import {
  combineCodec as combineCodec35,
  fixDecoderSize as fixDecoderSize29,
  fixEncoderSize as fixEncoderSize30,
  getBytesDecoder as getBytesDecoder29,
  getBytesEncoder as getBytesEncoder30,
  getStructDecoder as getStructDecoder34,
  getStructEncoder as getStructEncoder34,
  transformEncoder as transformEncoder29
} from "@solana/web3.js";
var INITIALIZE_POSITION_BUNDLE_DISCRIMINATOR = new Uint8Array([
  117,
  45,
  241,
  149,
  24,
  18,
  194,
  65
]);
function getInitializePositionBundleDiscriminatorBytes() {
  return fixEncoderSize30(getBytesEncoder30(), 8).encode(
    INITIALIZE_POSITION_BUNDLE_DISCRIMINATOR
  );
}
function getInitializePositionBundleInstructionDataEncoder() {
  return transformEncoder29(
    getStructEncoder34([["discriminator", fixEncoderSize30(getBytesEncoder30(), 8)]]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_POSITION_BUNDLE_DISCRIMINATOR
    })
  );
}
function getInitializePositionBundleInstructionDataDecoder() {
  return getStructDecoder34([
    ["discriminator", fixDecoderSize29(getBytesDecoder29(), 8)]
  ]);
}
function getInitializePositionBundleInstructionDataCodec() {
  return combineCodec35(
    getInitializePositionBundleInstructionDataEncoder(),
    getInitializePositionBundleInstructionDataDecoder()
  );
}
function getInitializePositionBundleInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    positionBundle: { value: input.positionBundle ?? null, isWritable: true },
    positionBundleMint: {
      value: input.positionBundleMint ?? null,
      isWritable: true
    },
    positionBundleTokenAccount: {
      value: input.positionBundleTokenAccount ?? null,
      isWritable: true
    },
    positionBundleOwner: {
      value: input.positionBundleOwner ?? null,
      isWritable: false
    },
    funder: { value: input.funder ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.positionBundle),
      getAccountMeta(accounts.positionBundleMint),
      getAccountMeta(accounts.positionBundleTokenAccount),
      getAccountMeta(accounts.positionBundleOwner),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent),
      getAccountMeta(accounts.associatedTokenProgram)
    ],
    programAddress,
    data: getInitializePositionBundleInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseInitializePositionBundleInstruction(instruction) {
  if (instruction.accounts.length < 9) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      positionBundle: getNextAccount(),
      positionBundleMint: getNextAccount(),
      positionBundleTokenAccount: getNextAccount(),
      positionBundleOwner: getNextAccount(),
      funder: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount(),
      associatedTokenProgram: getNextAccount()
    },
    data: getInitializePositionBundleInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/initializePositionBundleWithMetadata.ts
import {
  combineCodec as combineCodec36,
  fixDecoderSize as fixDecoderSize30,
  fixEncoderSize as fixEncoderSize31,
  getBytesDecoder as getBytesDecoder30,
  getBytesEncoder as getBytesEncoder31,
  getStructDecoder as getStructDecoder35,
  getStructEncoder as getStructEncoder35,
  transformEncoder as transformEncoder30
} from "@solana/web3.js";
var INITIALIZE_POSITION_BUNDLE_WITH_METADATA_DISCRIMINATOR = new Uint8Array([93, 124, 16, 179, 249, 131, 115, 245]);
function getInitializePositionBundleWithMetadataDiscriminatorBytes() {
  return fixEncoderSize31(getBytesEncoder31(), 8).encode(
    INITIALIZE_POSITION_BUNDLE_WITH_METADATA_DISCRIMINATOR
  );
}
function getInitializePositionBundleWithMetadataInstructionDataEncoder() {
  return transformEncoder30(
    getStructEncoder35([["discriminator", fixEncoderSize31(getBytesEncoder31(), 8)]]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_POSITION_BUNDLE_WITH_METADATA_DISCRIMINATOR
    })
  );
}
function getInitializePositionBundleWithMetadataInstructionDataDecoder() {
  return getStructDecoder35([
    ["discriminator", fixDecoderSize30(getBytesDecoder30(), 8)]
  ]);
}
function getInitializePositionBundleWithMetadataInstructionDataCodec() {
  return combineCodec36(
    getInitializePositionBundleWithMetadataInstructionDataEncoder(),
    getInitializePositionBundleWithMetadataInstructionDataDecoder()
  );
}
function getInitializePositionBundleWithMetadataInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    positionBundle: { value: input.positionBundle ?? null, isWritable: true },
    positionBundleMint: {
      value: input.positionBundleMint ?? null,
      isWritable: true
    },
    positionBundleMetadata: {
      value: input.positionBundleMetadata ?? null,
      isWritable: true
    },
    positionBundleTokenAccount: {
      value: input.positionBundleTokenAccount ?? null,
      isWritable: true
    },
    positionBundleOwner: {
      value: input.positionBundleOwner ?? null,
      isWritable: false
    },
    funder: { value: input.funder ?? null, isWritable: true },
    metadataUpdateAuth: {
      value: input.metadataUpdateAuth ?? null,
      isWritable: false
    },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false
    },
    metadataProgram: {
      value: input.metadataProgram ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.positionBundle),
      getAccountMeta(accounts.positionBundleMint),
      getAccountMeta(accounts.positionBundleMetadata),
      getAccountMeta(accounts.positionBundleTokenAccount),
      getAccountMeta(accounts.positionBundleOwner),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.metadataUpdateAuth),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent),
      getAccountMeta(accounts.associatedTokenProgram),
      getAccountMeta(accounts.metadataProgram)
    ],
    programAddress,
    data: getInitializePositionBundleWithMetadataInstructionDataEncoder().encode(
      {}
    )
  };
  return instruction;
}
function parseInitializePositionBundleWithMetadataInstruction(instruction) {
  if (instruction.accounts.length < 12) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      positionBundle: getNextAccount(),
      positionBundleMint: getNextAccount(),
      positionBundleMetadata: getNextAccount(),
      positionBundleTokenAccount: getNextAccount(),
      positionBundleOwner: getNextAccount(),
      funder: getNextAccount(),
      metadataUpdateAuth: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount(),
      associatedTokenProgram: getNextAccount(),
      metadataProgram: getNextAccount()
    },
    data: getInitializePositionBundleWithMetadataInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/initializeReward.ts
import {
  combineCodec as combineCodec37,
  fixDecoderSize as fixDecoderSize31,
  fixEncoderSize as fixEncoderSize32,
  getBytesDecoder as getBytesDecoder31,
  getBytesEncoder as getBytesEncoder32,
  getStructDecoder as getStructDecoder36,
  getStructEncoder as getStructEncoder36,
  getU8Decoder as getU8Decoder5,
  getU8Encoder as getU8Encoder5,
  transformEncoder as transformEncoder31
} from "@solana/web3.js";
var INITIALIZE_REWARD_DISCRIMINATOR = new Uint8Array([
  95,
  135,
  192,
  196,
  242,
  129,
  230,
  68
]);
function getInitializeRewardDiscriminatorBytes() {
  return fixEncoderSize32(getBytesEncoder32(), 8).encode(
    INITIALIZE_REWARD_DISCRIMINATOR
  );
}
function getInitializeRewardInstructionDataEncoder() {
  return transformEncoder31(
    getStructEncoder36([
      ["discriminator", fixEncoderSize32(getBytesEncoder32(), 8)],
      ["rewardIndex", getU8Encoder5()]
    ]),
    (value) => ({ ...value, discriminator: INITIALIZE_REWARD_DISCRIMINATOR })
  );
}
function getInitializeRewardInstructionDataDecoder() {
  return getStructDecoder36([
    ["discriminator", fixDecoderSize31(getBytesDecoder31(), 8)],
    ["rewardIndex", getU8Decoder5()]
  ]);
}
function getInitializeRewardInstructionDataCodec() {
  return combineCodec37(
    getInitializeRewardInstructionDataEncoder(),
    getInitializeRewardInstructionDataDecoder()
  );
}
function getInitializeRewardInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    rewardAuthority: {
      value: input.rewardAuthority ?? null,
      isWritable: false
    },
    funder: { value: input.funder ?? null, isWritable: true },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    rewardMint: { value: input.rewardMint ?? null, isWritable: false },
    rewardVault: { value: input.rewardVault ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.rewardAuthority),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.rewardMint),
      getAccountMeta(accounts.rewardVault),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent)
    ],
    programAddress,
    data: getInitializeRewardInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeRewardInstruction(instruction) {
  if (instruction.accounts.length < 8) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      rewardAuthority: getNextAccount(),
      funder: getNextAccount(),
      whirlpool: getNextAccount(),
      rewardMint: getNextAccount(),
      rewardVault: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount()
    },
    data: getInitializeRewardInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/initializeRewardV2.ts
import {
  combineCodec as combineCodec38,
  fixDecoderSize as fixDecoderSize32,
  fixEncoderSize as fixEncoderSize33,
  getBytesDecoder as getBytesDecoder32,
  getBytesEncoder as getBytesEncoder33,
  getStructDecoder as getStructDecoder37,
  getStructEncoder as getStructEncoder37,
  getU8Decoder as getU8Decoder6,
  getU8Encoder as getU8Encoder6,
  transformEncoder as transformEncoder32
} from "@solana/web3.js";
var INITIALIZE_REWARD_V2_DISCRIMINATOR = new Uint8Array([
  91,
  1,
  77,
  50,
  235,
  229,
  133,
  49
]);
function getInitializeRewardV2DiscriminatorBytes() {
  return fixEncoderSize33(getBytesEncoder33(), 8).encode(
    INITIALIZE_REWARD_V2_DISCRIMINATOR
  );
}
function getInitializeRewardV2InstructionDataEncoder() {
  return transformEncoder32(
    getStructEncoder37([
      ["discriminator", fixEncoderSize33(getBytesEncoder33(), 8)],
      ["rewardIndex", getU8Encoder6()]
    ]),
    (value) => ({ ...value, discriminator: INITIALIZE_REWARD_V2_DISCRIMINATOR })
  );
}
function getInitializeRewardV2InstructionDataDecoder() {
  return getStructDecoder37([
    ["discriminator", fixDecoderSize32(getBytesDecoder32(), 8)],
    ["rewardIndex", getU8Decoder6()]
  ]);
}
function getInitializeRewardV2InstructionDataCodec() {
  return combineCodec38(
    getInitializeRewardV2InstructionDataEncoder(),
    getInitializeRewardV2InstructionDataDecoder()
  );
}
function getInitializeRewardV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    rewardAuthority: {
      value: input.rewardAuthority ?? null,
      isWritable: false
    },
    funder: { value: input.funder ?? null, isWritable: true },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    rewardMint: { value: input.rewardMint ?? null, isWritable: false },
    rewardTokenBadge: {
      value: input.rewardTokenBadge ?? null,
      isWritable: false
    },
    rewardVault: { value: input.rewardVault ?? null, isWritable: true },
    rewardTokenProgram: {
      value: input.rewardTokenProgram ?? null,
      isWritable: false
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.rewardAuthority),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.rewardMint),
      getAccountMeta(accounts.rewardTokenBadge),
      getAccountMeta(accounts.rewardVault),
      getAccountMeta(accounts.rewardTokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent)
    ],
    programAddress,
    data: getInitializeRewardV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeRewardV2Instruction(instruction) {
  if (instruction.accounts.length < 9) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      rewardAuthority: getNextAccount(),
      funder: getNextAccount(),
      whirlpool: getNextAccount(),
      rewardMint: getNextAccount(),
      rewardTokenBadge: getNextAccount(),
      rewardVault: getNextAccount(),
      rewardTokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount()
    },
    data: getInitializeRewardV2InstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/initializeTickArray.ts
import {
  combineCodec as combineCodec39,
  fixDecoderSize as fixDecoderSize33,
  fixEncoderSize as fixEncoderSize34,
  getBytesDecoder as getBytesDecoder33,
  getBytesEncoder as getBytesEncoder34,
  getI32Decoder as getI32Decoder4,
  getI32Encoder as getI32Encoder4,
  getStructDecoder as getStructDecoder38,
  getStructEncoder as getStructEncoder38,
  transformEncoder as transformEncoder33
} from "@solana/web3.js";
var INITIALIZE_TICK_ARRAY_DISCRIMINATOR = new Uint8Array([
  11,
  188,
  193,
  214,
  141,
  91,
  149,
  184
]);
function getInitializeTickArrayDiscriminatorBytes() {
  return fixEncoderSize34(getBytesEncoder34(), 8).encode(
    INITIALIZE_TICK_ARRAY_DISCRIMINATOR
  );
}
function getInitializeTickArrayInstructionDataEncoder() {
  return transformEncoder33(
    getStructEncoder38([
      ["discriminator", fixEncoderSize34(getBytesEncoder34(), 8)],
      ["startTickIndex", getI32Encoder4()]
    ]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_TICK_ARRAY_DISCRIMINATOR
    })
  );
}
function getInitializeTickArrayInstructionDataDecoder() {
  return getStructDecoder38([
    ["discriminator", fixDecoderSize33(getBytesDecoder33(), 8)],
    ["startTickIndex", getI32Decoder4()]
  ]);
}
function getInitializeTickArrayInstructionDataCodec() {
  return combineCodec39(
    getInitializeTickArrayInstructionDataEncoder(),
    getInitializeTickArrayInstructionDataDecoder()
  );
}
function getInitializeTickArrayInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    funder: { value: input.funder ?? null, isWritable: true },
    tickArray: { value: input.tickArray ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.tickArray),
      getAccountMeta(accounts.systemProgram)
    ],
    programAddress,
    data: getInitializeTickArrayInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeTickArrayInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      funder: getNextAccount(),
      tickArray: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getInitializeTickArrayInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/initializeTokenBadge.ts
import {
  combineCodec as combineCodec40,
  fixDecoderSize as fixDecoderSize34,
  fixEncoderSize as fixEncoderSize35,
  getBytesDecoder as getBytesDecoder34,
  getBytesEncoder as getBytesEncoder35,
  getStructDecoder as getStructDecoder39,
  getStructEncoder as getStructEncoder39,
  transformEncoder as transformEncoder34
} from "@solana/web3.js";
var INITIALIZE_TOKEN_BADGE_DISCRIMINATOR = new Uint8Array([
  253,
  77,
  205,
  95,
  27,
  224,
  89,
  223
]);
function getInitializeTokenBadgeDiscriminatorBytes() {
  return fixEncoderSize35(getBytesEncoder35(), 8).encode(
    INITIALIZE_TOKEN_BADGE_DISCRIMINATOR
  );
}
function getInitializeTokenBadgeInstructionDataEncoder() {
  return transformEncoder34(
    getStructEncoder39([["discriminator", fixEncoderSize35(getBytesEncoder35(), 8)]]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_TOKEN_BADGE_DISCRIMINATOR
    })
  );
}
function getInitializeTokenBadgeInstructionDataDecoder() {
  return getStructDecoder39([
    ["discriminator", fixDecoderSize34(getBytesDecoder34(), 8)]
  ]);
}
function getInitializeTokenBadgeInstructionDataCodec() {
  return combineCodec40(
    getInitializeTokenBadgeInstructionDataEncoder(),
    getInitializeTokenBadgeInstructionDataDecoder()
  );
}
function getInitializeTokenBadgeInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    whirlpoolsConfigExtension: {
      value: input.whirlpoolsConfigExtension ?? null,
      isWritable: false
    },
    tokenBadgeAuthority: {
      value: input.tokenBadgeAuthority ?? null,
      isWritable: false
    },
    tokenMint: { value: input.tokenMint ?? null, isWritable: false },
    tokenBadge: { value: input.tokenBadge ?? null, isWritable: true },
    funder: { value: input.funder ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.whirlpoolsConfigExtension),
      getAccountMeta(accounts.tokenBadgeAuthority),
      getAccountMeta(accounts.tokenMint),
      getAccountMeta(accounts.tokenBadge),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.systemProgram)
    ],
    programAddress,
    data: getInitializeTokenBadgeInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseInitializeTokenBadgeInstruction(instruction) {
  if (instruction.accounts.length < 7) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      whirlpoolsConfigExtension: getNextAccount(),
      tokenBadgeAuthority: getNextAccount(),
      tokenMint: getNextAccount(),
      tokenBadge: getNextAccount(),
      funder: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getInitializeTokenBadgeInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/openBundledPosition.ts
import {
  combineCodec as combineCodec41,
  fixDecoderSize as fixDecoderSize35,
  fixEncoderSize as fixEncoderSize36,
  getBytesDecoder as getBytesDecoder35,
  getBytesEncoder as getBytesEncoder36,
  getI32Decoder as getI32Decoder5,
  getI32Encoder as getI32Encoder5,
  getStructDecoder as getStructDecoder40,
  getStructEncoder as getStructEncoder40,
  getU16Decoder as getU16Decoder9,
  getU16Encoder as getU16Encoder9,
  transformEncoder as transformEncoder35
} from "@solana/web3.js";
var OPEN_BUNDLED_POSITION_DISCRIMINATOR = new Uint8Array([
  169,
  113,
  126,
  171,
  213,
  172,
  212,
  49
]);
function getOpenBundledPositionDiscriminatorBytes() {
  return fixEncoderSize36(getBytesEncoder36(), 8).encode(
    OPEN_BUNDLED_POSITION_DISCRIMINATOR
  );
}
function getOpenBundledPositionInstructionDataEncoder() {
  return transformEncoder35(
    getStructEncoder40([
      ["discriminator", fixEncoderSize36(getBytesEncoder36(), 8)],
      ["bundleIndex", getU16Encoder9()],
      ["tickLowerIndex", getI32Encoder5()],
      ["tickUpperIndex", getI32Encoder5()]
    ]),
    (value) => ({
      ...value,
      discriminator: OPEN_BUNDLED_POSITION_DISCRIMINATOR
    })
  );
}
function getOpenBundledPositionInstructionDataDecoder() {
  return getStructDecoder40([
    ["discriminator", fixDecoderSize35(getBytesDecoder35(), 8)],
    ["bundleIndex", getU16Decoder9()],
    ["tickLowerIndex", getI32Decoder5()],
    ["tickUpperIndex", getI32Decoder5()]
  ]);
}
function getOpenBundledPositionInstructionDataCodec() {
  return combineCodec41(
    getOpenBundledPositionInstructionDataEncoder(),
    getOpenBundledPositionInstructionDataDecoder()
  );
}
function getOpenBundledPositionInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    bundledPosition: { value: input.bundledPosition ?? null, isWritable: true },
    positionBundle: { value: input.positionBundle ?? null, isWritable: true },
    positionBundleTokenAccount: {
      value: input.positionBundleTokenAccount ?? null,
      isWritable: false
    },
    positionBundleAuthority: {
      value: input.positionBundleAuthority ?? null,
      isWritable: false
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    funder: { value: input.funder ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.bundledPosition),
      getAccountMeta(accounts.positionBundle),
      getAccountMeta(accounts.positionBundleTokenAccount),
      getAccountMeta(accounts.positionBundleAuthority),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent)
    ],
    programAddress,
    data: getOpenBundledPositionInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseOpenBundledPositionInstruction(instruction) {
  if (instruction.accounts.length < 8) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      bundledPosition: getNextAccount(),
      positionBundle: getNextAccount(),
      positionBundleTokenAccount: getNextAccount(),
      positionBundleAuthority: getNextAccount(),
      whirlpool: getNextAccount(),
      funder: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount()
    },
    data: getOpenBundledPositionInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/openPosition.ts
import {
  combineCodec as combineCodec42,
  fixDecoderSize as fixDecoderSize36,
  fixEncoderSize as fixEncoderSize37,
  getBytesDecoder as getBytesDecoder36,
  getBytesEncoder as getBytesEncoder37,
  getI32Decoder as getI32Decoder6,
  getI32Encoder as getI32Encoder6,
  getStructDecoder as getStructDecoder41,
  getStructEncoder as getStructEncoder41,
  getU8Decoder as getU8Decoder7,
  getU8Encoder as getU8Encoder7,
  transformEncoder as transformEncoder36
} from "@solana/web3.js";
var OPEN_POSITION_DISCRIMINATOR = new Uint8Array([
  135,
  128,
  47,
  77,
  15,
  152,
  240,
  49
]);
function getOpenPositionDiscriminatorBytes() {
  return fixEncoderSize37(getBytesEncoder37(), 8).encode(
    OPEN_POSITION_DISCRIMINATOR
  );
}
function getOpenPositionInstructionDataEncoder() {
  return transformEncoder36(
    getStructEncoder41([
      ["discriminator", fixEncoderSize37(getBytesEncoder37(), 8)],
      ["positionBump", getU8Encoder7()],
      ["tickLowerIndex", getI32Encoder6()],
      ["tickUpperIndex", getI32Encoder6()]
    ]),
    (value) => ({ ...value, discriminator: OPEN_POSITION_DISCRIMINATOR })
  );
}
function getOpenPositionInstructionDataDecoder() {
  return getStructDecoder41([
    ["discriminator", fixDecoderSize36(getBytesDecoder36(), 8)],
    ["positionBump", getU8Decoder7()],
    ["tickLowerIndex", getI32Decoder6()],
    ["tickUpperIndex", getI32Decoder6()]
  ]);
}
function getOpenPositionInstructionDataCodec() {
  return combineCodec42(
    getOpenPositionInstructionDataEncoder(),
    getOpenPositionInstructionDataDecoder()
  );
}
function getOpenPositionInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    funder: { value: input.funder ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: false },
    position: { value: input.position ?? null, isWritable: true },
    positionMint: { value: input.positionMint ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: true
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionMint),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent),
      getAccountMeta(accounts.associatedTokenProgram)
    ],
    programAddress,
    data: getOpenPositionInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseOpenPositionInstruction(instruction) {
  if (instruction.accounts.length < 10) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      funder: getNextAccount(),
      owner: getNextAccount(),
      position: getNextAccount(),
      positionMint: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      whirlpool: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount(),
      associatedTokenProgram: getNextAccount()
    },
    data: getOpenPositionInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/openPositionWithMetadata.ts
import {
  combineCodec as combineCodec43,
  fixDecoderSize as fixDecoderSize37,
  fixEncoderSize as fixEncoderSize38,
  getBytesDecoder as getBytesDecoder37,
  getBytesEncoder as getBytesEncoder38,
  getI32Decoder as getI32Decoder7,
  getI32Encoder as getI32Encoder7,
  getStructDecoder as getStructDecoder42,
  getStructEncoder as getStructEncoder42,
  getU8Decoder as getU8Decoder8,
  getU8Encoder as getU8Encoder8,
  transformEncoder as transformEncoder37
} from "@solana/web3.js";
var OPEN_POSITION_WITH_METADATA_DISCRIMINATOR = new Uint8Array([
  242,
  29,
  134,
  48,
  58,
  110,
  14,
  60
]);
function getOpenPositionWithMetadataDiscriminatorBytes() {
  return fixEncoderSize38(getBytesEncoder38(), 8).encode(
    OPEN_POSITION_WITH_METADATA_DISCRIMINATOR
  );
}
function getOpenPositionWithMetadataInstructionDataEncoder() {
  return transformEncoder37(
    getStructEncoder42([
      ["discriminator", fixEncoderSize38(getBytesEncoder38(), 8)],
      ["positionBump", getU8Encoder8()],
      ["metadataBump", getU8Encoder8()],
      ["tickLowerIndex", getI32Encoder7()],
      ["tickUpperIndex", getI32Encoder7()]
    ]),
    (value) => ({
      ...value,
      discriminator: OPEN_POSITION_WITH_METADATA_DISCRIMINATOR
    })
  );
}
function getOpenPositionWithMetadataInstructionDataDecoder() {
  return getStructDecoder42([
    ["discriminator", fixDecoderSize37(getBytesDecoder37(), 8)],
    ["positionBump", getU8Decoder8()],
    ["metadataBump", getU8Decoder8()],
    ["tickLowerIndex", getI32Decoder7()],
    ["tickUpperIndex", getI32Decoder7()]
  ]);
}
function getOpenPositionWithMetadataInstructionDataCodec() {
  return combineCodec43(
    getOpenPositionWithMetadataInstructionDataEncoder(),
    getOpenPositionWithMetadataInstructionDataDecoder()
  );
}
function getOpenPositionWithMetadataInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    funder: { value: input.funder ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: false },
    position: { value: input.position ?? null, isWritable: true },
    positionMint: { value: input.positionMint ?? null, isWritable: true },
    positionMetadataAccount: {
      value: input.positionMetadataAccount ?? null,
      isWritable: true
    },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: true
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false
    },
    metadataProgram: {
      value: input.metadataProgram ?? null,
      isWritable: false
    },
    metadataUpdateAuth: {
      value: input.metadataUpdateAuth ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionMint),
      getAccountMeta(accounts.positionMetadataAccount),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent),
      getAccountMeta(accounts.associatedTokenProgram),
      getAccountMeta(accounts.metadataProgram),
      getAccountMeta(accounts.metadataUpdateAuth)
    ],
    programAddress,
    data: getOpenPositionWithMetadataInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseOpenPositionWithMetadataInstruction(instruction) {
  if (instruction.accounts.length < 13) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      funder: getNextAccount(),
      owner: getNextAccount(),
      position: getNextAccount(),
      positionMint: getNextAccount(),
      positionMetadataAccount: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      whirlpool: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount(),
      associatedTokenProgram: getNextAccount(),
      metadataProgram: getNextAccount(),
      metadataUpdateAuth: getNextAccount()
    },
    data: getOpenPositionWithMetadataInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/openPositionWithTokenExtensions.ts
import {
  combineCodec as combineCodec44,
  fixDecoderSize as fixDecoderSize38,
  fixEncoderSize as fixEncoderSize39,
  getBooleanDecoder as getBooleanDecoder2,
  getBooleanEncoder as getBooleanEncoder2,
  getBytesDecoder as getBytesDecoder38,
  getBytesEncoder as getBytesEncoder39,
  getI32Decoder as getI32Decoder8,
  getI32Encoder as getI32Encoder8,
  getStructDecoder as getStructDecoder43,
  getStructEncoder as getStructEncoder43,
  transformEncoder as transformEncoder38
} from "@solana/web3.js";
var OPEN_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR = new Uint8Array(
  [212, 47, 95, 92, 114, 102, 131, 250]
);
function getOpenPositionWithTokenExtensionsDiscriminatorBytes() {
  return fixEncoderSize39(getBytesEncoder39(), 8).encode(
    OPEN_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR
  );
}
function getOpenPositionWithTokenExtensionsInstructionDataEncoder() {
  return transformEncoder38(
    getStructEncoder43([
      ["discriminator", fixEncoderSize39(getBytesEncoder39(), 8)],
      ["tickLowerIndex", getI32Encoder8()],
      ["tickUpperIndex", getI32Encoder8()],
      ["withTokenMetadataExtension", getBooleanEncoder2()]
    ]),
    (value) => ({
      ...value,
      discriminator: OPEN_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR
    })
  );
}
function getOpenPositionWithTokenExtensionsInstructionDataDecoder() {
  return getStructDecoder43([
    ["discriminator", fixDecoderSize38(getBytesDecoder38(), 8)],
    ["tickLowerIndex", getI32Decoder8()],
    ["tickUpperIndex", getI32Decoder8()],
    ["withTokenMetadataExtension", getBooleanDecoder2()]
  ]);
}
function getOpenPositionWithTokenExtensionsInstructionDataCodec() {
  return combineCodec44(
    getOpenPositionWithTokenExtensionsInstructionDataEncoder(),
    getOpenPositionWithTokenExtensionsInstructionDataDecoder()
  );
}
function getOpenPositionWithTokenExtensionsInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    funder: { value: input.funder ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: false },
    position: { value: input.position ?? null, isWritable: true },
    positionMint: { value: input.positionMint ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: true
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    token2022Program: {
      value: input.token2022Program ?? null,
      isWritable: false
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false
    },
    metadataUpdateAuth: {
      value: input.metadataUpdateAuth ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionMint),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.token2022Program),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.associatedTokenProgram),
      getAccountMeta(accounts.metadataUpdateAuth)
    ],
    programAddress,
    data: getOpenPositionWithTokenExtensionsInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseOpenPositionWithTokenExtensionsInstruction(instruction) {
  if (instruction.accounts.length < 10) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      funder: getNextAccount(),
      owner: getNextAccount(),
      position: getNextAccount(),
      positionMint: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      whirlpool: getNextAccount(),
      token2022Program: getNextAccount(),
      systemProgram: getNextAccount(),
      associatedTokenProgram: getNextAccount(),
      metadataUpdateAuth: getNextAccount()
    },
    data: getOpenPositionWithTokenExtensionsInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setCollectProtocolFeesAuthority.ts
import {
  combineCodec as combineCodec45,
  fixDecoderSize as fixDecoderSize39,
  fixEncoderSize as fixEncoderSize40,
  getBytesDecoder as getBytesDecoder39,
  getBytesEncoder as getBytesEncoder40,
  getStructDecoder as getStructDecoder44,
  getStructEncoder as getStructEncoder44,
  transformEncoder as transformEncoder39
} from "@solana/web3.js";
var SET_COLLECT_PROTOCOL_FEES_AUTHORITY_DISCRIMINATOR = new Uint8Array(
  [34, 150, 93, 244, 139, 225, 233, 67]
);
function getSetCollectProtocolFeesAuthorityDiscriminatorBytes() {
  return fixEncoderSize40(getBytesEncoder40(), 8).encode(
    SET_COLLECT_PROTOCOL_FEES_AUTHORITY_DISCRIMINATOR
  );
}
function getSetCollectProtocolFeesAuthorityInstructionDataEncoder() {
  return transformEncoder39(
    getStructEncoder44([["discriminator", fixEncoderSize40(getBytesEncoder40(), 8)]]),
    (value) => ({
      ...value,
      discriminator: SET_COLLECT_PROTOCOL_FEES_AUTHORITY_DISCRIMINATOR
    })
  );
}
function getSetCollectProtocolFeesAuthorityInstructionDataDecoder() {
  return getStructDecoder44([
    ["discriminator", fixDecoderSize39(getBytesDecoder39(), 8)]
  ]);
}
function getSetCollectProtocolFeesAuthorityInstructionDataCodec() {
  return combineCodec45(
    getSetCollectProtocolFeesAuthorityInstructionDataEncoder(),
    getSetCollectProtocolFeesAuthorityInstructionDataDecoder()
  );
}
function getSetCollectProtocolFeesAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: true
    },
    collectProtocolFeesAuthority: {
      value: input.collectProtocolFeesAuthority ?? null,
      isWritable: false
    },
    newCollectProtocolFeesAuthority: {
      value: input.newCollectProtocolFeesAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.collectProtocolFeesAuthority),
      getAccountMeta(accounts.newCollectProtocolFeesAuthority)
    ],
    programAddress,
    data: getSetCollectProtocolFeesAuthorityInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseSetCollectProtocolFeesAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      collectProtocolFeesAuthority: getNextAccount(),
      newCollectProtocolFeesAuthority: getNextAccount()
    },
    data: getSetCollectProtocolFeesAuthorityInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setConfigExtensionAuthority.ts
import {
  combineCodec as combineCodec46,
  fixDecoderSize as fixDecoderSize40,
  fixEncoderSize as fixEncoderSize41,
  getBytesDecoder as getBytesDecoder40,
  getBytesEncoder as getBytesEncoder41,
  getStructDecoder as getStructDecoder45,
  getStructEncoder as getStructEncoder45,
  transformEncoder as transformEncoder40
} from "@solana/web3.js";
var SET_CONFIG_EXTENSION_AUTHORITY_DISCRIMINATOR = new Uint8Array([
  44,
  94,
  241,
  116,
  24,
  188,
  60,
  143
]);
function getSetConfigExtensionAuthorityDiscriminatorBytes() {
  return fixEncoderSize41(getBytesEncoder41(), 8).encode(
    SET_CONFIG_EXTENSION_AUTHORITY_DISCRIMINATOR
  );
}
function getSetConfigExtensionAuthorityInstructionDataEncoder() {
  return transformEncoder40(
    getStructEncoder45([["discriminator", fixEncoderSize41(getBytesEncoder41(), 8)]]),
    (value) => ({
      ...value,
      discriminator: SET_CONFIG_EXTENSION_AUTHORITY_DISCRIMINATOR
    })
  );
}
function getSetConfigExtensionAuthorityInstructionDataDecoder() {
  return getStructDecoder45([
    ["discriminator", fixDecoderSize40(getBytesDecoder40(), 8)]
  ]);
}
function getSetConfigExtensionAuthorityInstructionDataCodec() {
  return combineCodec46(
    getSetConfigExtensionAuthorityInstructionDataEncoder(),
    getSetConfigExtensionAuthorityInstructionDataDecoder()
  );
}
function getSetConfigExtensionAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    whirlpoolsConfigExtension: {
      value: input.whirlpoolsConfigExtension ?? null,
      isWritable: true
    },
    configExtensionAuthority: {
      value: input.configExtensionAuthority ?? null,
      isWritable: false
    },
    newConfigExtensionAuthority: {
      value: input.newConfigExtensionAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.whirlpoolsConfigExtension),
      getAccountMeta(accounts.configExtensionAuthority),
      getAccountMeta(accounts.newConfigExtensionAuthority)
    ],
    programAddress,
    data: getSetConfigExtensionAuthorityInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseSetConfigExtensionAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      whirlpoolsConfigExtension: getNextAccount(),
      configExtensionAuthority: getNextAccount(),
      newConfigExtensionAuthority: getNextAccount()
    },
    data: getSetConfigExtensionAuthorityInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setDefaultFeeRate.ts
import {
  combineCodec as combineCodec47,
  fixDecoderSize as fixDecoderSize41,
  fixEncoderSize as fixEncoderSize42,
  getBytesDecoder as getBytesDecoder41,
  getBytesEncoder as getBytesEncoder42,
  getStructDecoder as getStructDecoder46,
  getStructEncoder as getStructEncoder46,
  getU16Decoder as getU16Decoder10,
  getU16Encoder as getU16Encoder10,
  transformEncoder as transformEncoder41
} from "@solana/web3.js";
var SET_DEFAULT_FEE_RATE_DISCRIMINATOR = new Uint8Array([
  118,
  215,
  214,
  157,
  182,
  229,
  208,
  228
]);
function getSetDefaultFeeRateDiscriminatorBytes() {
  return fixEncoderSize42(getBytesEncoder42(), 8).encode(
    SET_DEFAULT_FEE_RATE_DISCRIMINATOR
  );
}
function getSetDefaultFeeRateInstructionDataEncoder() {
  return transformEncoder41(
    getStructEncoder46([
      ["discriminator", fixEncoderSize42(getBytesEncoder42(), 8)],
      ["defaultFeeRate", getU16Encoder10()]
    ]),
    (value) => ({ ...value, discriminator: SET_DEFAULT_FEE_RATE_DISCRIMINATOR })
  );
}
function getSetDefaultFeeRateInstructionDataDecoder() {
  return getStructDecoder46([
    ["discriminator", fixDecoderSize41(getBytesDecoder41(), 8)],
    ["defaultFeeRate", getU16Decoder10()]
  ]);
}
function getSetDefaultFeeRateInstructionDataCodec() {
  return combineCodec47(
    getSetDefaultFeeRateInstructionDataEncoder(),
    getSetDefaultFeeRateInstructionDataDecoder()
  );
}
function getSetDefaultFeeRateInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    feeTier: { value: input.feeTier ?? null, isWritable: true },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.feeTier),
      getAccountMeta(accounts.feeAuthority)
    ],
    programAddress,
    data: getSetDefaultFeeRateInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetDefaultFeeRateInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      feeTier: getNextAccount(),
      feeAuthority: getNextAccount()
    },
    data: getSetDefaultFeeRateInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/setDefaultProtocolFeeRate.ts
import {
  combineCodec as combineCodec48,
  fixDecoderSize as fixDecoderSize42,
  fixEncoderSize as fixEncoderSize43,
  getBytesDecoder as getBytesDecoder42,
  getBytesEncoder as getBytesEncoder43,
  getStructDecoder as getStructDecoder47,
  getStructEncoder as getStructEncoder47,
  getU16Decoder as getU16Decoder11,
  getU16Encoder as getU16Encoder11,
  transformEncoder as transformEncoder42
} from "@solana/web3.js";
var SET_DEFAULT_PROTOCOL_FEE_RATE_DISCRIMINATOR = new Uint8Array([
  107,
  205,
  249,
  226,
  151,
  35,
  86,
  0
]);
function getSetDefaultProtocolFeeRateDiscriminatorBytes() {
  return fixEncoderSize43(getBytesEncoder43(), 8).encode(
    SET_DEFAULT_PROTOCOL_FEE_RATE_DISCRIMINATOR
  );
}
function getSetDefaultProtocolFeeRateInstructionDataEncoder() {
  return transformEncoder42(
    getStructEncoder47([
      ["discriminator", fixEncoderSize43(getBytesEncoder43(), 8)],
      ["defaultProtocolFeeRate", getU16Encoder11()]
    ]),
    (value) => ({
      ...value,
      discriminator: SET_DEFAULT_PROTOCOL_FEE_RATE_DISCRIMINATOR
    })
  );
}
function getSetDefaultProtocolFeeRateInstructionDataDecoder() {
  return getStructDecoder47([
    ["discriminator", fixDecoderSize42(getBytesDecoder42(), 8)],
    ["defaultProtocolFeeRate", getU16Decoder11()]
  ]);
}
function getSetDefaultProtocolFeeRateInstructionDataCodec() {
  return combineCodec48(
    getSetDefaultProtocolFeeRateInstructionDataEncoder(),
    getSetDefaultProtocolFeeRateInstructionDataDecoder()
  );
}
function getSetDefaultProtocolFeeRateInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: true
    },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.feeAuthority)
    ],
    programAddress,
    data: getSetDefaultProtocolFeeRateInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetDefaultProtocolFeeRateInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      feeAuthority: getNextAccount()
    },
    data: getSetDefaultProtocolFeeRateInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setFeeAuthority.ts
import {
  combineCodec as combineCodec49,
  fixDecoderSize as fixDecoderSize43,
  fixEncoderSize as fixEncoderSize44,
  getBytesDecoder as getBytesDecoder43,
  getBytesEncoder as getBytesEncoder44,
  getStructDecoder as getStructDecoder48,
  getStructEncoder as getStructEncoder48,
  transformEncoder as transformEncoder43
} from "@solana/web3.js";
var SET_FEE_AUTHORITY_DISCRIMINATOR = new Uint8Array([
  31,
  1,
  50,
  87,
  237,
  101,
  97,
  132
]);
function getSetFeeAuthorityDiscriminatorBytes() {
  return fixEncoderSize44(getBytesEncoder44(), 8).encode(
    SET_FEE_AUTHORITY_DISCRIMINATOR
  );
}
function getSetFeeAuthorityInstructionDataEncoder() {
  return transformEncoder43(
    getStructEncoder48([["discriminator", fixEncoderSize44(getBytesEncoder44(), 8)]]),
    (value) => ({ ...value, discriminator: SET_FEE_AUTHORITY_DISCRIMINATOR })
  );
}
function getSetFeeAuthorityInstructionDataDecoder() {
  return getStructDecoder48([
    ["discriminator", fixDecoderSize43(getBytesDecoder43(), 8)]
  ]);
}
function getSetFeeAuthorityInstructionDataCodec() {
  return combineCodec49(
    getSetFeeAuthorityInstructionDataEncoder(),
    getSetFeeAuthorityInstructionDataDecoder()
  );
}
function getSetFeeAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: true
    },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false },
    newFeeAuthority: {
      value: input.newFeeAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.feeAuthority),
      getAccountMeta(accounts.newFeeAuthority)
    ],
    programAddress,
    data: getSetFeeAuthorityInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseSetFeeAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      feeAuthority: getNextAccount(),
      newFeeAuthority: getNextAccount()
    },
    data: getSetFeeAuthorityInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/setFeeRate.ts
import {
  combineCodec as combineCodec50,
  fixDecoderSize as fixDecoderSize44,
  fixEncoderSize as fixEncoderSize45,
  getBytesDecoder as getBytesDecoder44,
  getBytesEncoder as getBytesEncoder45,
  getStructDecoder as getStructDecoder49,
  getStructEncoder as getStructEncoder49,
  getU16Decoder as getU16Decoder12,
  getU16Encoder as getU16Encoder12,
  transformEncoder as transformEncoder44
} from "@solana/web3.js";
var SET_FEE_RATE_DISCRIMINATOR = new Uint8Array([
  53,
  243,
  137,
  65,
  8,
  140,
  158,
  6
]);
function getSetFeeRateDiscriminatorBytes() {
  return fixEncoderSize45(getBytesEncoder45(), 8).encode(
    SET_FEE_RATE_DISCRIMINATOR
  );
}
function getSetFeeRateInstructionDataEncoder() {
  return transformEncoder44(
    getStructEncoder49([
      ["discriminator", fixEncoderSize45(getBytesEncoder45(), 8)],
      ["feeRate", getU16Encoder12()]
    ]),
    (value) => ({ ...value, discriminator: SET_FEE_RATE_DISCRIMINATOR })
  );
}
function getSetFeeRateInstructionDataDecoder() {
  return getStructDecoder49([
    ["discriminator", fixDecoderSize44(getBytesDecoder44(), 8)],
    ["feeRate", getU16Decoder12()]
  ]);
}
function getSetFeeRateInstructionDataCodec() {
  return combineCodec50(
    getSetFeeRateInstructionDataEncoder(),
    getSetFeeRateInstructionDataDecoder()
  );
}
function getSetFeeRateInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.feeAuthority)
    ],
    programAddress,
    data: getSetFeeRateInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetFeeRateInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      whirlpool: getNextAccount(),
      feeAuthority: getNextAccount()
    },
    data: getSetFeeRateInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/setProtocolFeeRate.ts
import {
  combineCodec as combineCodec51,
  fixDecoderSize as fixDecoderSize45,
  fixEncoderSize as fixEncoderSize46,
  getBytesDecoder as getBytesDecoder45,
  getBytesEncoder as getBytesEncoder46,
  getStructDecoder as getStructDecoder50,
  getStructEncoder as getStructEncoder50,
  getU16Decoder as getU16Decoder13,
  getU16Encoder as getU16Encoder13,
  transformEncoder as transformEncoder45
} from "@solana/web3.js";
var SET_PROTOCOL_FEE_RATE_DISCRIMINATOR = new Uint8Array([
  95,
  7,
  4,
  50,
  154,
  79,
  156,
  131
]);
function getSetProtocolFeeRateDiscriminatorBytes() {
  return fixEncoderSize46(getBytesEncoder46(), 8).encode(
    SET_PROTOCOL_FEE_RATE_DISCRIMINATOR
  );
}
function getSetProtocolFeeRateInstructionDataEncoder() {
  return transformEncoder45(
    getStructEncoder50([
      ["discriminator", fixEncoderSize46(getBytesEncoder46(), 8)],
      ["protocolFeeRate", getU16Encoder13()]
    ]),
    (value) => ({
      ...value,
      discriminator: SET_PROTOCOL_FEE_RATE_DISCRIMINATOR
    })
  );
}
function getSetProtocolFeeRateInstructionDataDecoder() {
  return getStructDecoder50([
    ["discriminator", fixDecoderSize45(getBytesDecoder45(), 8)],
    ["protocolFeeRate", getU16Decoder13()]
  ]);
}
function getSetProtocolFeeRateInstructionDataCodec() {
  return combineCodec51(
    getSetProtocolFeeRateInstructionDataEncoder(),
    getSetProtocolFeeRateInstructionDataDecoder()
  );
}
function getSetProtocolFeeRateInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.feeAuthority)
    ],
    programAddress,
    data: getSetProtocolFeeRateInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetProtocolFeeRateInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      whirlpool: getNextAccount(),
      feeAuthority: getNextAccount()
    },
    data: getSetProtocolFeeRateInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setRewardAuthority.ts
import {
  combineCodec as combineCodec52,
  fixDecoderSize as fixDecoderSize46,
  fixEncoderSize as fixEncoderSize47,
  getBytesDecoder as getBytesDecoder46,
  getBytesEncoder as getBytesEncoder47,
  getStructDecoder as getStructDecoder51,
  getStructEncoder as getStructEncoder51,
  getU8Decoder as getU8Decoder9,
  getU8Encoder as getU8Encoder9,
  transformEncoder as transformEncoder46
} from "@solana/web3.js";
var SET_REWARD_AUTHORITY_DISCRIMINATOR = new Uint8Array([
  34,
  39,
  183,
  252,
  83,
  28,
  85,
  127
]);
function getSetRewardAuthorityDiscriminatorBytes() {
  return fixEncoderSize47(getBytesEncoder47(), 8).encode(
    SET_REWARD_AUTHORITY_DISCRIMINATOR
  );
}
function getSetRewardAuthorityInstructionDataEncoder() {
  return transformEncoder46(
    getStructEncoder51([
      ["discriminator", fixEncoderSize47(getBytesEncoder47(), 8)],
      ["rewardIndex", getU8Encoder9()]
    ]),
    (value) => ({ ...value, discriminator: SET_REWARD_AUTHORITY_DISCRIMINATOR })
  );
}
function getSetRewardAuthorityInstructionDataDecoder() {
  return getStructDecoder51([
    ["discriminator", fixDecoderSize46(getBytesDecoder46(), 8)],
    ["rewardIndex", getU8Decoder9()]
  ]);
}
function getSetRewardAuthorityInstructionDataCodec() {
  return combineCodec52(
    getSetRewardAuthorityInstructionDataEncoder(),
    getSetRewardAuthorityInstructionDataDecoder()
  );
}
function getSetRewardAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    rewardAuthority: {
      value: input.rewardAuthority ?? null,
      isWritable: false
    },
    newRewardAuthority: {
      value: input.newRewardAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.rewardAuthority),
      getAccountMeta(accounts.newRewardAuthority)
    ],
    programAddress,
    data: getSetRewardAuthorityInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetRewardAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      rewardAuthority: getNextAccount(),
      newRewardAuthority: getNextAccount()
    },
    data: getSetRewardAuthorityInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setRewardAuthorityBySuperAuthority.ts
import {
  combineCodec as combineCodec53,
  fixDecoderSize as fixDecoderSize47,
  fixEncoderSize as fixEncoderSize48,
  getBytesDecoder as getBytesDecoder47,
  getBytesEncoder as getBytesEncoder48,
  getStructDecoder as getStructDecoder52,
  getStructEncoder as getStructEncoder52,
  getU8Decoder as getU8Decoder10,
  getU8Encoder as getU8Encoder10,
  transformEncoder as transformEncoder47
} from "@solana/web3.js";
var SET_REWARD_AUTHORITY_BY_SUPER_AUTHORITY_DISCRIMINATOR = new Uint8Array([240, 154, 201, 198, 148, 93, 56, 25]);
function getSetRewardAuthorityBySuperAuthorityDiscriminatorBytes() {
  return fixEncoderSize48(getBytesEncoder48(), 8).encode(
    SET_REWARD_AUTHORITY_BY_SUPER_AUTHORITY_DISCRIMINATOR
  );
}
function getSetRewardAuthorityBySuperAuthorityInstructionDataEncoder() {
  return transformEncoder47(
    getStructEncoder52([
      ["discriminator", fixEncoderSize48(getBytesEncoder48(), 8)],
      ["rewardIndex", getU8Encoder10()]
    ]),
    (value) => ({
      ...value,
      discriminator: SET_REWARD_AUTHORITY_BY_SUPER_AUTHORITY_DISCRIMINATOR
    })
  );
}
function getSetRewardAuthorityBySuperAuthorityInstructionDataDecoder() {
  return getStructDecoder52([
    ["discriminator", fixDecoderSize47(getBytesDecoder47(), 8)],
    ["rewardIndex", getU8Decoder10()]
  ]);
}
function getSetRewardAuthorityBySuperAuthorityInstructionDataCodec() {
  return combineCodec53(
    getSetRewardAuthorityBySuperAuthorityInstructionDataEncoder(),
    getSetRewardAuthorityBySuperAuthorityInstructionDataDecoder()
  );
}
function getSetRewardAuthorityBySuperAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    rewardEmissionsSuperAuthority: {
      value: input.rewardEmissionsSuperAuthority ?? null,
      isWritable: false
    },
    newRewardAuthority: {
      value: input.newRewardAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.rewardEmissionsSuperAuthority),
      getAccountMeta(accounts.newRewardAuthority)
    ],
    programAddress,
    data: getSetRewardAuthorityBySuperAuthorityInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetRewardAuthorityBySuperAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      whirlpool: getNextAccount(),
      rewardEmissionsSuperAuthority: getNextAccount(),
      newRewardAuthority: getNextAccount()
    },
    data: getSetRewardAuthorityBySuperAuthorityInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setRewardEmissions.ts
import {
  combineCodec as combineCodec54,
  fixDecoderSize as fixDecoderSize48,
  fixEncoderSize as fixEncoderSize49,
  getBytesDecoder as getBytesDecoder48,
  getBytesEncoder as getBytesEncoder49,
  getStructDecoder as getStructDecoder53,
  getStructEncoder as getStructEncoder53,
  getU128Decoder as getU128Decoder12,
  getU128Encoder as getU128Encoder12,
  getU8Decoder as getU8Decoder11,
  getU8Encoder as getU8Encoder11,
  transformEncoder as transformEncoder48
} from "@solana/web3.js";
var SET_REWARD_EMISSIONS_DISCRIMINATOR = new Uint8Array([
  13,
  197,
  86,
  168,
  109,
  176,
  27,
  244
]);
function getSetRewardEmissionsDiscriminatorBytes() {
  return fixEncoderSize49(getBytesEncoder49(), 8).encode(
    SET_REWARD_EMISSIONS_DISCRIMINATOR
  );
}
function getSetRewardEmissionsInstructionDataEncoder() {
  return transformEncoder48(
    getStructEncoder53([
      ["discriminator", fixEncoderSize49(getBytesEncoder49(), 8)],
      ["rewardIndex", getU8Encoder11()],
      ["emissionsPerSecondX64", getU128Encoder12()]
    ]),
    (value) => ({ ...value, discriminator: SET_REWARD_EMISSIONS_DISCRIMINATOR })
  );
}
function getSetRewardEmissionsInstructionDataDecoder() {
  return getStructDecoder53([
    ["discriminator", fixDecoderSize48(getBytesDecoder48(), 8)],
    ["rewardIndex", getU8Decoder11()],
    ["emissionsPerSecondX64", getU128Decoder12()]
  ]);
}
function getSetRewardEmissionsInstructionDataCodec() {
  return combineCodec54(
    getSetRewardEmissionsInstructionDataEncoder(),
    getSetRewardEmissionsInstructionDataDecoder()
  );
}
function getSetRewardEmissionsInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    rewardAuthority: {
      value: input.rewardAuthority ?? null,
      isWritable: false
    },
    rewardVault: { value: input.rewardVault ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.rewardAuthority),
      getAccountMeta(accounts.rewardVault)
    ],
    programAddress,
    data: getSetRewardEmissionsInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetRewardEmissionsInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      rewardAuthority: getNextAccount(),
      rewardVault: getNextAccount()
    },
    data: getSetRewardEmissionsInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setRewardEmissionsSuperAuthority.ts
import {
  combineCodec as combineCodec55,
  fixDecoderSize as fixDecoderSize49,
  fixEncoderSize as fixEncoderSize50,
  getBytesDecoder as getBytesDecoder49,
  getBytesEncoder as getBytesEncoder50,
  getStructDecoder as getStructDecoder54,
  getStructEncoder as getStructEncoder54,
  transformEncoder as transformEncoder49
} from "@solana/web3.js";
var SET_REWARD_EMISSIONS_SUPER_AUTHORITY_DISCRIMINATOR = new Uint8Array([207, 5, 200, 209, 122, 56, 82, 183]);
function getSetRewardEmissionsSuperAuthorityDiscriminatorBytes() {
  return fixEncoderSize50(getBytesEncoder50(), 8).encode(
    SET_REWARD_EMISSIONS_SUPER_AUTHORITY_DISCRIMINATOR
  );
}
function getSetRewardEmissionsSuperAuthorityInstructionDataEncoder() {
  return transformEncoder49(
    getStructEncoder54([["discriminator", fixEncoderSize50(getBytesEncoder50(), 8)]]),
    (value) => ({
      ...value,
      discriminator: SET_REWARD_EMISSIONS_SUPER_AUTHORITY_DISCRIMINATOR
    })
  );
}
function getSetRewardEmissionsSuperAuthorityInstructionDataDecoder() {
  return getStructDecoder54([
    ["discriminator", fixDecoderSize49(getBytesDecoder49(), 8)]
  ]);
}
function getSetRewardEmissionsSuperAuthorityInstructionDataCodec() {
  return combineCodec55(
    getSetRewardEmissionsSuperAuthorityInstructionDataEncoder(),
    getSetRewardEmissionsSuperAuthorityInstructionDataDecoder()
  );
}
function getSetRewardEmissionsSuperAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: true
    },
    rewardEmissionsSuperAuthority: {
      value: input.rewardEmissionsSuperAuthority ?? null,
      isWritable: false
    },
    newRewardEmissionsSuperAuthority: {
      value: input.newRewardEmissionsSuperAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.rewardEmissionsSuperAuthority),
      getAccountMeta(accounts.newRewardEmissionsSuperAuthority)
    ],
    programAddress,
    data: getSetRewardEmissionsSuperAuthorityInstructionDataEncoder().encode(
      {}
    )
  };
  return instruction;
}
function parseSetRewardEmissionsSuperAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      rewardEmissionsSuperAuthority: getNextAccount(),
      newRewardEmissionsSuperAuthority: getNextAccount()
    },
    data: getSetRewardEmissionsSuperAuthorityInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setRewardEmissionsV2.ts
import {
  combineCodec as combineCodec56,
  fixDecoderSize as fixDecoderSize50,
  fixEncoderSize as fixEncoderSize51,
  getBytesDecoder as getBytesDecoder50,
  getBytesEncoder as getBytesEncoder51,
  getStructDecoder as getStructDecoder55,
  getStructEncoder as getStructEncoder55,
  getU128Decoder as getU128Decoder13,
  getU128Encoder as getU128Encoder13,
  getU8Decoder as getU8Decoder12,
  getU8Encoder as getU8Encoder12,
  transformEncoder as transformEncoder50
} from "@solana/web3.js";
var SET_REWARD_EMISSIONS_V2_DISCRIMINATOR = new Uint8Array([
  114,
  228,
  72,
  32,
  193,
  48,
  160,
  102
]);
function getSetRewardEmissionsV2DiscriminatorBytes() {
  return fixEncoderSize51(getBytesEncoder51(), 8).encode(
    SET_REWARD_EMISSIONS_V2_DISCRIMINATOR
  );
}
function getSetRewardEmissionsV2InstructionDataEncoder() {
  return transformEncoder50(
    getStructEncoder55([
      ["discriminator", fixEncoderSize51(getBytesEncoder51(), 8)],
      ["rewardIndex", getU8Encoder12()],
      ["emissionsPerSecondX64", getU128Encoder13()]
    ]),
    (value) => ({
      ...value,
      discriminator: SET_REWARD_EMISSIONS_V2_DISCRIMINATOR
    })
  );
}
function getSetRewardEmissionsV2InstructionDataDecoder() {
  return getStructDecoder55([
    ["discriminator", fixDecoderSize50(getBytesDecoder50(), 8)],
    ["rewardIndex", getU8Decoder12()],
    ["emissionsPerSecondX64", getU128Decoder13()]
  ]);
}
function getSetRewardEmissionsV2InstructionDataCodec() {
  return combineCodec56(
    getSetRewardEmissionsV2InstructionDataEncoder(),
    getSetRewardEmissionsV2InstructionDataDecoder()
  );
}
function getSetRewardEmissionsV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    rewardAuthority: {
      value: input.rewardAuthority ?? null,
      isWritable: false
    },
    rewardVault: { value: input.rewardVault ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.rewardAuthority),
      getAccountMeta(accounts.rewardVault)
    ],
    programAddress,
    data: getSetRewardEmissionsV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetRewardEmissionsV2Instruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      rewardAuthority: getNextAccount(),
      rewardVault: getNextAccount()
    },
    data: getSetRewardEmissionsV2InstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setTokenBadgeAuthority.ts
import {
  combineCodec as combineCodec57,
  fixDecoderSize as fixDecoderSize51,
  fixEncoderSize as fixEncoderSize52,
  getBytesDecoder as getBytesDecoder51,
  getBytesEncoder as getBytesEncoder52,
  getStructDecoder as getStructDecoder56,
  getStructEncoder as getStructEncoder56,
  transformEncoder as transformEncoder51
} from "@solana/web3.js";
var SET_TOKEN_BADGE_AUTHORITY_DISCRIMINATOR = new Uint8Array([
  207,
  202,
  4,
  32,
  205,
  79,
  13,
  178
]);
function getSetTokenBadgeAuthorityDiscriminatorBytes() {
  return fixEncoderSize52(getBytesEncoder52(), 8).encode(
    SET_TOKEN_BADGE_AUTHORITY_DISCRIMINATOR
  );
}
function getSetTokenBadgeAuthorityInstructionDataEncoder() {
  return transformEncoder51(
    getStructEncoder56([["discriminator", fixEncoderSize52(getBytesEncoder52(), 8)]]),
    (value) => ({
      ...value,
      discriminator: SET_TOKEN_BADGE_AUTHORITY_DISCRIMINATOR
    })
  );
}
function getSetTokenBadgeAuthorityInstructionDataDecoder() {
  return getStructDecoder56([
    ["discriminator", fixDecoderSize51(getBytesDecoder51(), 8)]
  ]);
}
function getSetTokenBadgeAuthorityInstructionDataCodec() {
  return combineCodec57(
    getSetTokenBadgeAuthorityInstructionDataEncoder(),
    getSetTokenBadgeAuthorityInstructionDataDecoder()
  );
}
function getSetTokenBadgeAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    whirlpoolsConfigExtension: {
      value: input.whirlpoolsConfigExtension ?? null,
      isWritable: true
    },
    configExtensionAuthority: {
      value: input.configExtensionAuthority ?? null,
      isWritable: false
    },
    newTokenBadgeAuthority: {
      value: input.newTokenBadgeAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.whirlpoolsConfigExtension),
      getAccountMeta(accounts.configExtensionAuthority),
      getAccountMeta(accounts.newTokenBadgeAuthority)
    ],
    programAddress,
    data: getSetTokenBadgeAuthorityInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseSetTokenBadgeAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      whirlpoolsConfigExtension: getNextAccount(),
      configExtensionAuthority: getNextAccount(),
      newTokenBadgeAuthority: getNextAccount()
    },
    data: getSetTokenBadgeAuthorityInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/swap.ts
import {
  combineCodec as combineCodec58,
  fixDecoderSize as fixDecoderSize52,
  fixEncoderSize as fixEncoderSize53,
  getBooleanDecoder as getBooleanDecoder3,
  getBooleanEncoder as getBooleanEncoder3,
  getBytesDecoder as getBytesDecoder52,
  getBytesEncoder as getBytesEncoder53,
  getStructDecoder as getStructDecoder57,
  getStructEncoder as getStructEncoder57,
  getU128Decoder as getU128Decoder14,
  getU128Encoder as getU128Encoder14,
  getU64Decoder as getU64Decoder8,
  getU64Encoder as getU64Encoder8,
  transformEncoder as transformEncoder52
} from "@solana/web3.js";
var SWAP_DISCRIMINATOR = new Uint8Array([
  248,
  198,
  158,
  145,
  225,
  117,
  135,
  200
]);
function getSwapDiscriminatorBytes() {
  return fixEncoderSize53(getBytesEncoder53(), 8).encode(SWAP_DISCRIMINATOR);
}
function getSwapInstructionDataEncoder() {
  return transformEncoder52(
    getStructEncoder57([
      ["discriminator", fixEncoderSize53(getBytesEncoder53(), 8)],
      ["amount", getU64Encoder8()],
      ["otherAmountThreshold", getU64Encoder8()],
      ["sqrtPriceLimit", getU128Encoder14()],
      ["amountSpecifiedIsInput", getBooleanEncoder3()],
      ["aToB", getBooleanEncoder3()]
    ]),
    (value) => ({ ...value, discriminator: SWAP_DISCRIMINATOR })
  );
}
function getSwapInstructionDataDecoder() {
  return getStructDecoder57([
    ["discriminator", fixDecoderSize52(getBytesDecoder52(), 8)],
    ["amount", getU64Decoder8()],
    ["otherAmountThreshold", getU64Decoder8()],
    ["sqrtPriceLimit", getU128Decoder14()],
    ["amountSpecifiedIsInput", getBooleanDecoder3()],
    ["aToB", getBooleanDecoder3()]
  ]);
}
function getSwapInstructionDataCodec() {
  return combineCodec58(
    getSwapInstructionDataEncoder(),
    getSwapInstructionDataDecoder()
  );
}
function getSwapInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    tokenAuthority: { value: input.tokenAuthority ?? null, isWritable: false },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    tokenOwnerAccountA: {
      value: input.tokenOwnerAccountA ?? null,
      isWritable: true
    },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenOwnerAccountB: {
      value: input.tokenOwnerAccountB ?? null,
      isWritable: true
    },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tickArray0: { value: input.tickArray0 ?? null, isWritable: true },
    tickArray1: { value: input.tickArray1 ?? null, isWritable: true },
    tickArray2: { value: input.tickArray2 ?? null, isWritable: true },
    oracle: { value: input.oracle ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.tokenAuthority),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenOwnerAccountA),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenOwnerAccountB),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tickArray0),
      getAccountMeta(accounts.tickArray1),
      getAccountMeta(accounts.tickArray2),
      getAccountMeta(accounts.oracle)
    ],
    programAddress,
    data: getSwapInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSwapInstruction(instruction) {
  if (instruction.accounts.length < 11) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      tokenProgram: getNextAccount(),
      tokenAuthority: getNextAccount(),
      whirlpool: getNextAccount(),
      tokenOwnerAccountA: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenOwnerAccountB: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tickArray0: getNextAccount(),
      tickArray1: getNextAccount(),
      tickArray2: getNextAccount(),
      oracle: getNextAccount()
    },
    data: getSwapInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/swapV2.ts
import {
  combineCodec as combineCodec59,
  fixDecoderSize as fixDecoderSize53,
  fixEncoderSize as fixEncoderSize54,
  getBooleanDecoder as getBooleanDecoder4,
  getBooleanEncoder as getBooleanEncoder4,
  getBytesDecoder as getBytesDecoder53,
  getBytesEncoder as getBytesEncoder54,
  getOptionDecoder as getOptionDecoder6,
  getOptionEncoder as getOptionEncoder6,
  getStructDecoder as getStructDecoder58,
  getStructEncoder as getStructEncoder58,
  getU128Decoder as getU128Decoder15,
  getU128Encoder as getU128Encoder15,
  getU64Decoder as getU64Decoder9,
  getU64Encoder as getU64Encoder9,
  transformEncoder as transformEncoder53
} from "@solana/web3.js";
var SWAP_V2_DISCRIMINATOR = new Uint8Array([
  43,
  4,
  237,
  11,
  26,
  201,
  30,
  98
]);
function getSwapV2DiscriminatorBytes() {
  return fixEncoderSize54(getBytesEncoder54(), 8).encode(SWAP_V2_DISCRIMINATOR);
}
function getSwapV2InstructionDataEncoder() {
  return transformEncoder53(
    getStructEncoder58([
      ["discriminator", fixEncoderSize54(getBytesEncoder54(), 8)],
      ["amount", getU64Encoder9()],
      ["otherAmountThreshold", getU64Encoder9()],
      ["sqrtPriceLimit", getU128Encoder15()],
      ["amountSpecifiedIsInput", getBooleanEncoder4()],
      ["aToB", getBooleanEncoder4()],
      [
        "remainingAccountsInfo",
        getOptionEncoder6(getRemainingAccountsInfoEncoder())
      ]
    ]),
    (value) => ({ ...value, discriminator: SWAP_V2_DISCRIMINATOR })
  );
}
function getSwapV2InstructionDataDecoder() {
  return getStructDecoder58([
    ["discriminator", fixDecoderSize53(getBytesDecoder53(), 8)],
    ["amount", getU64Decoder9()],
    ["otherAmountThreshold", getU64Decoder9()],
    ["sqrtPriceLimit", getU128Decoder15()],
    ["amountSpecifiedIsInput", getBooleanDecoder4()],
    ["aToB", getBooleanDecoder4()],
    [
      "remainingAccountsInfo",
      getOptionDecoder6(getRemainingAccountsInfoDecoder())
    ]
  ]);
}
function getSwapV2InstructionDataCodec() {
  return combineCodec59(
    getSwapV2InstructionDataEncoder(),
    getSwapV2InstructionDataDecoder()
  );
}
function getSwapV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    tokenProgramA: { value: input.tokenProgramA ?? null, isWritable: false },
    tokenProgramB: { value: input.tokenProgramB ?? null, isWritable: false },
    memoProgram: { value: input.memoProgram ?? null, isWritable: false },
    tokenAuthority: { value: input.tokenAuthority ?? null, isWritable: false },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },
    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },
    tokenOwnerAccountA: {
      value: input.tokenOwnerAccountA ?? null,
      isWritable: true
    },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenOwnerAccountB: {
      value: input.tokenOwnerAccountB ?? null,
      isWritable: true
    },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tickArray0: { value: input.tickArray0 ?? null, isWritable: true },
    tickArray1: { value: input.tickArray1 ?? null, isWritable: true },
    tickArray2: { value: input.tickArray2 ?? null, isWritable: true },
    oracle: { value: input.oracle ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.tokenProgramA),
      getAccountMeta(accounts.tokenProgramB),
      getAccountMeta(accounts.memoProgram),
      getAccountMeta(accounts.tokenAuthority),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenMintA),
      getAccountMeta(accounts.tokenMintB),
      getAccountMeta(accounts.tokenOwnerAccountA),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenOwnerAccountB),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tickArray0),
      getAccountMeta(accounts.tickArray1),
      getAccountMeta(accounts.tickArray2),
      getAccountMeta(accounts.oracle)
    ],
    programAddress,
    data: getSwapV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSwapV2Instruction(instruction) {
  if (instruction.accounts.length < 15) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      tokenProgramA: getNextAccount(),
      tokenProgramB: getNextAccount(),
      memoProgram: getNextAccount(),
      tokenAuthority: getNextAccount(),
      whirlpool: getNextAccount(),
      tokenMintA: getNextAccount(),
      tokenMintB: getNextAccount(),
      tokenOwnerAccountA: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenOwnerAccountB: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tickArray0: getNextAccount(),
      tickArray1: getNextAccount(),
      tickArray2: getNextAccount(),
      oracle: getNextAccount()
    },
    data: getSwapV2InstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/twoHopSwap.ts
import {
  combineCodec as combineCodec60,
  fixDecoderSize as fixDecoderSize54,
  fixEncoderSize as fixEncoderSize55,
  getBooleanDecoder as getBooleanDecoder5,
  getBooleanEncoder as getBooleanEncoder5,
  getBytesDecoder as getBytesDecoder54,
  getBytesEncoder as getBytesEncoder55,
  getStructDecoder as getStructDecoder59,
  getStructEncoder as getStructEncoder59,
  getU128Decoder as getU128Decoder16,
  getU128Encoder as getU128Encoder16,
  getU64Decoder as getU64Decoder10,
  getU64Encoder as getU64Encoder10,
  transformEncoder as transformEncoder54
} from "@solana/web3.js";
var TWO_HOP_SWAP_DISCRIMINATOR = new Uint8Array([
  195,
  96,
  237,
  108,
  68,
  162,
  219,
  230
]);
function getTwoHopSwapDiscriminatorBytes() {
  return fixEncoderSize55(getBytesEncoder55(), 8).encode(
    TWO_HOP_SWAP_DISCRIMINATOR
  );
}
function getTwoHopSwapInstructionDataEncoder() {
  return transformEncoder54(
    getStructEncoder59([
      ["discriminator", fixEncoderSize55(getBytesEncoder55(), 8)],
      ["amount", getU64Encoder10()],
      ["otherAmountThreshold", getU64Encoder10()],
      ["amountSpecifiedIsInput", getBooleanEncoder5()],
      ["aToBOne", getBooleanEncoder5()],
      ["aToBTwo", getBooleanEncoder5()],
      ["sqrtPriceLimitOne", getU128Encoder16()],
      ["sqrtPriceLimitTwo", getU128Encoder16()]
    ]),
    (value) => ({ ...value, discriminator: TWO_HOP_SWAP_DISCRIMINATOR })
  );
}
function getTwoHopSwapInstructionDataDecoder() {
  return getStructDecoder59([
    ["discriminator", fixDecoderSize54(getBytesDecoder54(), 8)],
    ["amount", getU64Decoder10()],
    ["otherAmountThreshold", getU64Decoder10()],
    ["amountSpecifiedIsInput", getBooleanDecoder5()],
    ["aToBOne", getBooleanDecoder5()],
    ["aToBTwo", getBooleanDecoder5()],
    ["sqrtPriceLimitOne", getU128Decoder16()],
    ["sqrtPriceLimitTwo", getU128Decoder16()]
  ]);
}
function getTwoHopSwapInstructionDataCodec() {
  return combineCodec60(
    getTwoHopSwapInstructionDataEncoder(),
    getTwoHopSwapInstructionDataDecoder()
  );
}
function getTwoHopSwapInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    tokenAuthority: { value: input.tokenAuthority ?? null, isWritable: false },
    whirlpoolOne: { value: input.whirlpoolOne ?? null, isWritable: true },
    whirlpoolTwo: { value: input.whirlpoolTwo ?? null, isWritable: true },
    tokenOwnerAccountOneA: {
      value: input.tokenOwnerAccountOneA ?? null,
      isWritable: true
    },
    tokenVaultOneA: { value: input.tokenVaultOneA ?? null, isWritable: true },
    tokenOwnerAccountOneB: {
      value: input.tokenOwnerAccountOneB ?? null,
      isWritable: true
    },
    tokenVaultOneB: { value: input.tokenVaultOneB ?? null, isWritable: true },
    tokenOwnerAccountTwoA: {
      value: input.tokenOwnerAccountTwoA ?? null,
      isWritable: true
    },
    tokenVaultTwoA: { value: input.tokenVaultTwoA ?? null, isWritable: true },
    tokenOwnerAccountTwoB: {
      value: input.tokenOwnerAccountTwoB ?? null,
      isWritable: true
    },
    tokenVaultTwoB: { value: input.tokenVaultTwoB ?? null, isWritable: true },
    tickArrayOne0: { value: input.tickArrayOne0 ?? null, isWritable: true },
    tickArrayOne1: { value: input.tickArrayOne1 ?? null, isWritable: true },
    tickArrayOne2: { value: input.tickArrayOne2 ?? null, isWritable: true },
    tickArrayTwo0: { value: input.tickArrayTwo0 ?? null, isWritable: true },
    tickArrayTwo1: { value: input.tickArrayTwo1 ?? null, isWritable: true },
    tickArrayTwo2: { value: input.tickArrayTwo2 ?? null, isWritable: true },
    oracleOne: { value: input.oracleOne ?? null, isWritable: false },
    oracleTwo: { value: input.oracleTwo ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.tokenAuthority),
      getAccountMeta(accounts.whirlpoolOne),
      getAccountMeta(accounts.whirlpoolTwo),
      getAccountMeta(accounts.tokenOwnerAccountOneA),
      getAccountMeta(accounts.tokenVaultOneA),
      getAccountMeta(accounts.tokenOwnerAccountOneB),
      getAccountMeta(accounts.tokenVaultOneB),
      getAccountMeta(accounts.tokenOwnerAccountTwoA),
      getAccountMeta(accounts.tokenVaultTwoA),
      getAccountMeta(accounts.tokenOwnerAccountTwoB),
      getAccountMeta(accounts.tokenVaultTwoB),
      getAccountMeta(accounts.tickArrayOne0),
      getAccountMeta(accounts.tickArrayOne1),
      getAccountMeta(accounts.tickArrayOne2),
      getAccountMeta(accounts.tickArrayTwo0),
      getAccountMeta(accounts.tickArrayTwo1),
      getAccountMeta(accounts.tickArrayTwo2),
      getAccountMeta(accounts.oracleOne),
      getAccountMeta(accounts.oracleTwo)
    ],
    programAddress,
    data: getTwoHopSwapInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseTwoHopSwapInstruction(instruction) {
  if (instruction.accounts.length < 20) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      tokenProgram: getNextAccount(),
      tokenAuthority: getNextAccount(),
      whirlpoolOne: getNextAccount(),
      whirlpoolTwo: getNextAccount(),
      tokenOwnerAccountOneA: getNextAccount(),
      tokenVaultOneA: getNextAccount(),
      tokenOwnerAccountOneB: getNextAccount(),
      tokenVaultOneB: getNextAccount(),
      tokenOwnerAccountTwoA: getNextAccount(),
      tokenVaultTwoA: getNextAccount(),
      tokenOwnerAccountTwoB: getNextAccount(),
      tokenVaultTwoB: getNextAccount(),
      tickArrayOne0: getNextAccount(),
      tickArrayOne1: getNextAccount(),
      tickArrayOne2: getNextAccount(),
      tickArrayTwo0: getNextAccount(),
      tickArrayTwo1: getNextAccount(),
      tickArrayTwo2: getNextAccount(),
      oracleOne: getNextAccount(),
      oracleTwo: getNextAccount()
    },
    data: getTwoHopSwapInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/twoHopSwapV2.ts
import {
  combineCodec as combineCodec61,
  fixDecoderSize as fixDecoderSize55,
  fixEncoderSize as fixEncoderSize56,
  getBooleanDecoder as getBooleanDecoder6,
  getBooleanEncoder as getBooleanEncoder6,
  getBytesDecoder as getBytesDecoder55,
  getBytesEncoder as getBytesEncoder56,
  getOptionDecoder as getOptionDecoder7,
  getOptionEncoder as getOptionEncoder7,
  getStructDecoder as getStructDecoder60,
  getStructEncoder as getStructEncoder60,
  getU128Decoder as getU128Decoder17,
  getU128Encoder as getU128Encoder17,
  getU64Decoder as getU64Decoder11,
  getU64Encoder as getU64Encoder11,
  transformEncoder as transformEncoder55
} from "@solana/web3.js";
var TWO_HOP_SWAP_V2_DISCRIMINATOR = new Uint8Array([
  186,
  143,
  209,
  29,
  254,
  2,
  194,
  117
]);
function getTwoHopSwapV2DiscriminatorBytes() {
  return fixEncoderSize56(getBytesEncoder56(), 8).encode(
    TWO_HOP_SWAP_V2_DISCRIMINATOR
  );
}
function getTwoHopSwapV2InstructionDataEncoder() {
  return transformEncoder55(
    getStructEncoder60([
      ["discriminator", fixEncoderSize56(getBytesEncoder56(), 8)],
      ["amount", getU64Encoder11()],
      ["otherAmountThreshold", getU64Encoder11()],
      ["amountSpecifiedIsInput", getBooleanEncoder6()],
      ["aToBOne", getBooleanEncoder6()],
      ["aToBTwo", getBooleanEncoder6()],
      ["sqrtPriceLimitOne", getU128Encoder17()],
      ["sqrtPriceLimitTwo", getU128Encoder17()],
      [
        "remainingAccountsInfo",
        getOptionEncoder7(getRemainingAccountsInfoEncoder())
      ]
    ]),
    (value) => ({ ...value, discriminator: TWO_HOP_SWAP_V2_DISCRIMINATOR })
  );
}
function getTwoHopSwapV2InstructionDataDecoder() {
  return getStructDecoder60([
    ["discriminator", fixDecoderSize55(getBytesDecoder55(), 8)],
    ["amount", getU64Decoder11()],
    ["otherAmountThreshold", getU64Decoder11()],
    ["amountSpecifiedIsInput", getBooleanDecoder6()],
    ["aToBOne", getBooleanDecoder6()],
    ["aToBTwo", getBooleanDecoder6()],
    ["sqrtPriceLimitOne", getU128Decoder17()],
    ["sqrtPriceLimitTwo", getU128Decoder17()],
    [
      "remainingAccountsInfo",
      getOptionDecoder7(getRemainingAccountsInfoDecoder())
    ]
  ]);
}
function getTwoHopSwapV2InstructionDataCodec() {
  return combineCodec61(
    getTwoHopSwapV2InstructionDataEncoder(),
    getTwoHopSwapV2InstructionDataDecoder()
  );
}
function getTwoHopSwapV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolOne: { value: input.whirlpoolOne ?? null, isWritable: true },
    whirlpoolTwo: { value: input.whirlpoolTwo ?? null, isWritable: true },
    tokenMintInput: { value: input.tokenMintInput ?? null, isWritable: false },
    tokenMintIntermediate: {
      value: input.tokenMintIntermediate ?? null,
      isWritable: false
    },
    tokenMintOutput: {
      value: input.tokenMintOutput ?? null,
      isWritable: false
    },
    tokenProgramInput: {
      value: input.tokenProgramInput ?? null,
      isWritable: false
    },
    tokenProgramIntermediate: {
      value: input.tokenProgramIntermediate ?? null,
      isWritable: false
    },
    tokenProgramOutput: {
      value: input.tokenProgramOutput ?? null,
      isWritable: false
    },
    tokenOwnerAccountInput: {
      value: input.tokenOwnerAccountInput ?? null,
      isWritable: true
    },
    tokenVaultOneInput: {
      value: input.tokenVaultOneInput ?? null,
      isWritable: true
    },
    tokenVaultOneIntermediate: {
      value: input.tokenVaultOneIntermediate ?? null,
      isWritable: true
    },
    tokenVaultTwoIntermediate: {
      value: input.tokenVaultTwoIntermediate ?? null,
      isWritable: true
    },
    tokenVaultTwoOutput: {
      value: input.tokenVaultTwoOutput ?? null,
      isWritable: true
    },
    tokenOwnerAccountOutput: {
      value: input.tokenOwnerAccountOutput ?? null,
      isWritable: true
    },
    tokenAuthority: { value: input.tokenAuthority ?? null, isWritable: false },
    tickArrayOne0: { value: input.tickArrayOne0 ?? null, isWritable: true },
    tickArrayOne1: { value: input.tickArrayOne1 ?? null, isWritable: true },
    tickArrayOne2: { value: input.tickArrayOne2 ?? null, isWritable: true },
    tickArrayTwo0: { value: input.tickArrayTwo0 ?? null, isWritable: true },
    tickArrayTwo1: { value: input.tickArrayTwo1 ?? null, isWritable: true },
    tickArrayTwo2: { value: input.tickArrayTwo2 ?? null, isWritable: true },
    oracleOne: { value: input.oracleOne ?? null, isWritable: true },
    oracleTwo: { value: input.oracleTwo ?? null, isWritable: true },
    memoProgram: { value: input.memoProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolOne),
      getAccountMeta(accounts.whirlpoolTwo),
      getAccountMeta(accounts.tokenMintInput),
      getAccountMeta(accounts.tokenMintIntermediate),
      getAccountMeta(accounts.tokenMintOutput),
      getAccountMeta(accounts.tokenProgramInput),
      getAccountMeta(accounts.tokenProgramIntermediate),
      getAccountMeta(accounts.tokenProgramOutput),
      getAccountMeta(accounts.tokenOwnerAccountInput),
      getAccountMeta(accounts.tokenVaultOneInput),
      getAccountMeta(accounts.tokenVaultOneIntermediate),
      getAccountMeta(accounts.tokenVaultTwoIntermediate),
      getAccountMeta(accounts.tokenVaultTwoOutput),
      getAccountMeta(accounts.tokenOwnerAccountOutput),
      getAccountMeta(accounts.tokenAuthority),
      getAccountMeta(accounts.tickArrayOne0),
      getAccountMeta(accounts.tickArrayOne1),
      getAccountMeta(accounts.tickArrayOne2),
      getAccountMeta(accounts.tickArrayTwo0),
      getAccountMeta(accounts.tickArrayTwo1),
      getAccountMeta(accounts.tickArrayTwo2),
      getAccountMeta(accounts.oracleOne),
      getAccountMeta(accounts.oracleTwo),
      getAccountMeta(accounts.memoProgram)
    ],
    programAddress,
    data: getTwoHopSwapV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseTwoHopSwapV2Instruction(instruction) {
  if (instruction.accounts.length < 24) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolOne: getNextAccount(),
      whirlpoolTwo: getNextAccount(),
      tokenMintInput: getNextAccount(),
      tokenMintIntermediate: getNextAccount(),
      tokenMintOutput: getNextAccount(),
      tokenProgramInput: getNextAccount(),
      tokenProgramIntermediate: getNextAccount(),
      tokenProgramOutput: getNextAccount(),
      tokenOwnerAccountInput: getNextAccount(),
      tokenVaultOneInput: getNextAccount(),
      tokenVaultOneIntermediate: getNextAccount(),
      tokenVaultTwoIntermediate: getNextAccount(),
      tokenVaultTwoOutput: getNextAccount(),
      tokenOwnerAccountOutput: getNextAccount(),
      tokenAuthority: getNextAccount(),
      tickArrayOne0: getNextAccount(),
      tickArrayOne1: getNextAccount(),
      tickArrayOne2: getNextAccount(),
      tickArrayTwo0: getNextAccount(),
      tickArrayTwo1: getNextAccount(),
      tickArrayTwo2: getNextAccount(),
      oracleOne: getNextAccount(),
      oracleTwo: getNextAccount(),
      memoProgram: getNextAccount()
    },
    data: getTwoHopSwapV2InstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/updateFeesAndRewards.ts
import {
  combineCodec as combineCodec62,
  fixDecoderSize as fixDecoderSize56,
  fixEncoderSize as fixEncoderSize57,
  getBytesDecoder as getBytesDecoder56,
  getBytesEncoder as getBytesEncoder57,
  getStructDecoder as getStructDecoder61,
  getStructEncoder as getStructEncoder61,
  transformEncoder as transformEncoder56
} from "@solana/web3.js";
var UPDATE_FEES_AND_REWARDS_DISCRIMINATOR = new Uint8Array([
  154,
  230,
  250,
  13,
  236,
  209,
  75,
  223
]);
function getUpdateFeesAndRewardsDiscriminatorBytes() {
  return fixEncoderSize57(getBytesEncoder57(), 8).encode(
    UPDATE_FEES_AND_REWARDS_DISCRIMINATOR
  );
}
function getUpdateFeesAndRewardsInstructionDataEncoder() {
  return transformEncoder56(
    getStructEncoder61([["discriminator", fixEncoderSize57(getBytesEncoder57(), 8)]]),
    (value) => ({
      ...value,
      discriminator: UPDATE_FEES_AND_REWARDS_DISCRIMINATOR
    })
  );
}
function getUpdateFeesAndRewardsInstructionDataDecoder() {
  return getStructDecoder61([
    ["discriminator", fixDecoderSize56(getBytesDecoder56(), 8)]
  ]);
}
function getUpdateFeesAndRewardsInstructionDataCodec() {
  return combineCodec62(
    getUpdateFeesAndRewardsInstructionDataEncoder(),
    getUpdateFeesAndRewardsInstructionDataDecoder()
  );
}
function getUpdateFeesAndRewardsInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    position: { value: input.position ?? null, isWritable: true },
    tickArrayLower: { value: input.tickArrayLower ?? null, isWritable: false },
    tickArrayUpper: { value: input.tickArrayUpper ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.tickArrayLower),
      getAccountMeta(accounts.tickArrayUpper)
    ],
    programAddress,
    data: getUpdateFeesAndRewardsInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseUpdateFeesAndRewardsInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      position: getNextAccount(),
      tickArrayLower: getNextAccount(),
      tickArrayUpper: getNextAccount()
    },
    data: getUpdateFeesAndRewardsInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/gpa/feeTier.ts
import {
  getAddressEncoder as getAddressEncoder11,
  getBase58Decoder,
  getU16Encoder as getU16Encoder14
} from "@solana/web3.js";

// src/gpa/utils.ts
import { getBase64Encoder } from "@solana/web3.js";
async function fetchDecodedProgramAccounts(rpc, programAddress, filters, decoder) {
  const accountInfos = await rpc.getProgramAccounts(programAddress, {
    encoding: "base64",
    filters
  }).send();
  const encoder = getBase64Encoder();
  const datas = accountInfos.map((x) => encoder.encode(x.account.data[0]));
  const decoded = datas.map((x) => decoder.decode(x));
  return decoded.map((data, i) => ({
    ...accountInfos[i].account,
    address: accountInfos[i].pubkey,
    programAddress,
    data
  }));
}

// src/gpa/feeTier.ts
function feeTierWhirlpoolsConfigFilter(address) {
  return {
    memcmp: {
      offset: 8n,
      bytes: getBase58Decoder().decode(getAddressEncoder11().encode(address)),
      encoding: "base58"
    }
  };
}
function feeTierTickSpacingFilter(tickSpacing) {
  return {
    memcmp: {
      offset: 40n,
      bytes: getBase58Decoder().decode(getU16Encoder14().encode(tickSpacing)),
      encoding: "base58"
    }
  };
}
function feeTierFeeRateFilter(defaultFeeRate) {
  return {
    memcmp: {
      offset: 42n,
      bytes: getBase58Decoder().decode(getU16Encoder14().encode(defaultFeeRate)),
      encoding: "base58"
    }
  };
}
async function fetchAllFeeTierWithFilter(rpc, ...filters) {
  const discriminator = getBase58Decoder().decode(FEE_TIER_DISCRIMINATOR);
  const discriminatorFilter = {
    memcmp: {
      offset: 0n,
      bytes: discriminator,
      encoding: "base58"
    }
  };
  return fetchDecodedProgramAccounts(
    rpc,
    WHIRLPOOL_PROGRAM_ADDRESS,
    [discriminatorFilter, ...filters],
    getFeeTierDecoder()
  );
}

// src/gpa/position.ts
import {
  getBase58Decoder as getBase58Decoder2,
  getAddressEncoder as getAddressEncoder12,
  getI32Encoder as getI32Encoder9
} from "@solana/web3.js";
function positionWhirlpoolFilter(address) {
  return {
    memcmp: {
      offset: 8n,
      bytes: getBase58Decoder2().decode(getAddressEncoder12().encode(address)),
      encoding: "base58"
    }
  };
}
function positionMintFilter(address) {
  return {
    memcmp: {
      offset: 40n,
      bytes: getBase58Decoder2().decode(getAddressEncoder12().encode(address)),
      encoding: "base58"
    }
  };
}
function positionTickLowerIndexFilter(tickLowerIndex) {
  return {
    memcmp: {
      offset: 88n,
      bytes: getBase58Decoder2().decode(getI32Encoder9().encode(tickLowerIndex)),
      encoding: "base58"
    }
  };
}
function positionTickUpperIndexFilter(tickUpperIndex) {
  return {
    memcmp: {
      offset: 92n,
      bytes: getBase58Decoder2().decode(getI32Encoder9().encode(tickUpperIndex)),
      encoding: "base58"
    }
  };
}
async function fetchAllPositionWithFilter(rpc, ...filters) {
  const discriminator = getBase58Decoder2().decode(POSITION_DISCRIMINATOR);
  const discriminatorFilter = {
    memcmp: {
      offset: 0n,
      bytes: discriminator,
      encoding: "base58"
    }
  };
  return fetchDecodedProgramAccounts(
    rpc,
    WHIRLPOOL_PROGRAM_ADDRESS,
    [discriminatorFilter, ...filters],
    getPositionDecoder()
  );
}

// src/gpa/positionBundle.ts
import { getAddressEncoder as getAddressEncoder13, getBase58Decoder as getBase58Decoder3 } from "@solana/web3.js";
function positionBundleMintFilter(address) {
  return {
    memcmp: {
      offset: 8n,
      bytes: getBase58Decoder3().decode(getAddressEncoder13().encode(address)),
      encoding: "base58"
    }
  };
}
async function fetchAllPositionBundleWithFilter(rpc, ...filters) {
  const discriminator = getBase58Decoder3().decode(
    POSITION_BUNDLE_DISCRIMINATOR
  );
  const discriminatorFilter = {
    memcmp: {
      offset: 0n,
      bytes: discriminator,
      encoding: "base58"
    }
  };
  return fetchDecodedProgramAccounts(
    rpc,
    WHIRLPOOL_PROGRAM_ADDRESS,
    [discriminatorFilter, ...filters],
    getPositionBundleDecoder()
  );
}

// src/gpa/tickArray.ts
import {
  getAddressEncoder as getAddressEncoder14,
  getBase58Decoder as getBase58Decoder4,
  getI32Encoder as getI32Encoder10
} from "@solana/web3.js";
function tickArrayStartTickIndexFilter(startTickIndex) {
  return {
    memcmp: {
      offset: 8n,
      bytes: getBase58Decoder4().decode(getI32Encoder10().encode(startTickIndex)),
      encoding: "base58"
    }
  };
}
function tickArrayWhirlpoolFilter(address) {
  return {
    memcmp: {
      offset: 9956n,
      bytes: getBase58Decoder4().decode(getAddressEncoder14().encode(address)),
      encoding: "base58"
    }
  };
}
async function fetchAllTickArrayWithFilter(rpc, ...filters) {
  const discriminator = getBase58Decoder4().decode(TICK_ARRAY_DISCRIMINATOR);
  const discriminatorFilter = {
    memcmp: {
      offset: 0n,
      bytes: discriminator,
      encoding: "base58"
    }
  };
  return fetchDecodedProgramAccounts(
    rpc,
    WHIRLPOOL_PROGRAM_ADDRESS,
    [discriminatorFilter, ...filters],
    getTickArrayDecoder()
  );
}

// src/gpa/tokenBadge.ts
import { getBase58Decoder as getBase58Decoder5, getAddressEncoder as getAddressEncoder15 } from "@solana/web3.js";
function tokenBadgeWhirlpoolsConfigFilter(address) {
  return {
    memcmp: {
      offset: 8n,
      bytes: getBase58Decoder5().decode(getAddressEncoder15().encode(address)),
      encoding: "base58"
    }
  };
}
function tokenBadgeTokenMintFilter(address) {
  return {
    memcmp: {
      offset: 40n,
      bytes: getBase58Decoder5().decode(getAddressEncoder15().encode(address)),
      encoding: "base58"
    }
  };
}
async function fetchAllTokenBadgeWithFilter(rpc, ...filters) {
  const discriminator = getBase58Decoder5().decode(TOKEN_BADGE_DISCRIMINATOR);
  const discriminatorFilter = {
    memcmp: {
      offset: 0n,
      bytes: discriminator,
      encoding: "base58"
    }
  };
  return fetchDecodedProgramAccounts(
    rpc,
    WHIRLPOOL_PROGRAM_ADDRESS,
    [discriminatorFilter, ...filters],
    getTokenBadgeDecoder()
  );
}

// src/gpa/whirlpool.ts
import {
  getAddressEncoder as getAddressEncoder16,
  getBase58Decoder as getBase58Decoder6,
  getU16Encoder as getU16Encoder15
} from "@solana/web3.js";
function whirlpoolWhirlpoolConfigFilter(address) {
  return {
    memcmp: {
      offset: 8n,
      bytes: getBase58Decoder6().decode(getAddressEncoder16().encode(address)),
      encoding: "base58"
    }
  };
}
function whirlpoolTickSpacingFilter(tickSpacing) {
  return {
    memcmp: {
      offset: 41n,
      bytes: getBase58Decoder6().decode(getU16Encoder15().encode(tickSpacing)),
      encoding: "base58"
    }
  };
}
function whirlpoolFeeRateFilter(defaultFeeRate) {
  return {
    memcmp: {
      offset: 45n,
      bytes: getBase58Decoder6().decode(getU16Encoder15().encode(defaultFeeRate)),
      encoding: "base58"
    }
  };
}
function whirlpoolProtocolFeeRateFilter(protocolFeeRate) {
  return {
    memcmp: {
      offset: 47n,
      bytes: getBase58Decoder6().decode(getU16Encoder15().encode(protocolFeeRate)),
      encoding: "base58"
    }
  };
}
function whirlpoolTokenMintAFilter(tokenMintA) {
  return {
    memcmp: {
      offset: 101n,
      bytes: getBase58Decoder6().decode(getAddressEncoder16().encode(tokenMintA)),
      encoding: "base58"
    }
  };
}
function whirlpoolTokenVaultAFilter(tokenVaultA) {
  return {
    memcmp: {
      offset: 133n,
      bytes: getBase58Decoder6().decode(getAddressEncoder16().encode(tokenVaultA)),
      encoding: "base58"
    }
  };
}
function whirlpoolTokenMintBFilter(tokenMintB) {
  return {
    memcmp: {
      offset: 181n,
      bytes: getBase58Decoder6().decode(getAddressEncoder16().encode(tokenMintB)),
      encoding: "base58"
    }
  };
}
function whirlpoolTokenVaultBFilter(tokenVaultB) {
  return {
    memcmp: {
      offset: 213n,
      bytes: getBase58Decoder6().decode(getAddressEncoder16().encode(tokenVaultB)),
      encoding: "base58"
    }
  };
}
function whirlpoolRewardMint1Filter(rewardMint1) {
  return {
    memcmp: {
      offset: 269n,
      bytes: getBase58Decoder6().decode(getAddressEncoder16().encode(rewardMint1)),
      encoding: "base58"
    }
  };
}
function whirlpoolRewardVault1Filter(rewardVault1) {
  return {
    memcmp: {
      offset: 301n,
      bytes: getBase58Decoder6().decode(
        getAddressEncoder16().encode(rewardVault1)
      ),
      encoding: "base58"
    }
  };
}
function whirlpoolRewardMint2Filter(rewardMint2) {
  return {
    memcmp: {
      offset: 397n,
      bytes: getBase58Decoder6().decode(getAddressEncoder16().encode(rewardMint2)),
      encoding: "base58"
    }
  };
}
function whirlpoolRewardVault2Filter(rewardVault2) {
  return {
    memcmp: {
      offset: 429n,
      bytes: getBase58Decoder6().decode(
        getAddressEncoder16().encode(rewardVault2)
      ),
      encoding: "base58"
    }
  };
}
function whirlpoolRewardMint3Filter(rewardMint3) {
  return {
    memcmp: {
      offset: 525n,
      bytes: getBase58Decoder6().decode(getAddressEncoder16().encode(rewardMint3)),
      encoding: "base58"
    }
  };
}
function whirlpoolRewardVault3Filter(rewardVault3) {
  return {
    memcmp: {
      offset: 557n,
      bytes: getBase58Decoder6().decode(
        getAddressEncoder16().encode(rewardVault3)
      ),
      encoding: "base58"
    }
  };
}
async function fetchAllWhirlpoolWithFilter(rpc, ...filters) {
  const discriminator = getBase58Decoder6().decode(WHIRLPOOL_DISCRIMINATOR);
  const discriminatorFilter = {
    memcmp: {
      offset: 0n,
      bytes: discriminator,
      encoding: "base58"
    }
  };
  return fetchDecodedProgramAccounts(
    rpc,
    WHIRLPOOL_PROGRAM_ADDRESS,
    [discriminatorFilter, ...filters],
    getWhirlpoolDecoder()
  );
}

// src/gpa/whirlpoolsConfig.ts
import {
  getBase58Decoder as getBase58Decoder7,
  getAddressEncoder as getAddressEncoder17,
  getU16Encoder as getU16Encoder16
} from "@solana/web3.js";
function whirlpoolsConfigFeeAuthorityFilter(feeAuthority) {
  return {
    memcmp: {
      offset: 8n,
      bytes: getBase58Decoder7().decode(
        getAddressEncoder17().encode(feeAuthority)
      ),
      encoding: "base58"
    }
  };
}
function whirlpoolsConfigCollectProtocolFeesAuthorityFilter(collectProtocolFeesAuthority) {
  return {
    memcmp: {
      offset: 40n,
      bytes: getBase58Decoder7().decode(
        getAddressEncoder17().encode(collectProtocolFeesAuthority)
      ),
      encoding: "base58"
    }
  };
}
function whirlpoolsConfigRewardEmissionsSuperAuthorityFilter(rewardEmissionsSuperAuthority) {
  return {
    memcmp: {
      offset: 72n,
      bytes: getBase58Decoder7().decode(
        getAddressEncoder17().encode(rewardEmissionsSuperAuthority)
      ),
      encoding: "base58"
    }
  };
}
function whirlpoolsConfigDefaultProtocolFeeRateFilter(defaultFeeRate) {
  return {
    memcmp: {
      offset: 104n,
      bytes: getBase58Decoder7().decode(getU16Encoder16().encode(defaultFeeRate)),
      encoding: "base58"
    }
  };
}
async function fetchAllWhirlpoolsConfigWithFilter(rpc, ...filters) {
  const discriminator = getBase58Decoder7().decode(
    WHIRLPOOLS_CONFIG_DISCRIMINATOR
  );
  const discriminatorFilter = {
    memcmp: {
      offset: 0n,
      bytes: discriminator,
      encoding: "base58"
    }
  };
  return fetchDecodedProgramAccounts(
    rpc,
    WHIRLPOOL_PROGRAM_ADDRESS,
    [discriminatorFilter, ...filters],
    getWhirlpoolsConfigDecoder()
  );
}

// src/gpa/whirlpoolsConfigExtension.ts
import { getBase58Decoder as getBase58Decoder8, getAddressEncoder as getAddressEncoder18 } from "@solana/web3.js";
function whirlpoolsConfigExtensionWhirlpoolsConfigFilter(address) {
  return {
    memcmp: {
      offset: 8n,
      bytes: getBase58Decoder8().decode(getAddressEncoder18().encode(address)),
      encoding: "base58"
    }
  };
}
function whirlpoolsConfigExtensionConfigExtensionAuthorityFilter(configExtensionAuthority) {
  return {
    memcmp: {
      offset: 40n,
      bytes: getBase58Decoder8().decode(
        getAddressEncoder18().encode(configExtensionAuthority)
      ),
      encoding: "base58"
    }
  };
}
function whirlpoolsConfigExtensionConfigTokenBadgeAuthorityFilter(configTokenBadgeAuthority) {
  return {
    memcmp: {
      offset: 72n,
      bytes: getBase58Decoder8().decode(
        getAddressEncoder18().encode(configTokenBadgeAuthority)
      ),
      encoding: "base58"
    }
  };
}
async function fetchAllWhirlpoolsConfigExtensionWithFilter(rpc, ...filters) {
  const discriminator = getBase58Decoder8().decode(
    WHIRLPOOLS_CONFIG_EXTENSION_DISCRIMINATOR
  );
  const discriminatorFilter = {
    memcmp: {
      offset: 0n,
      bytes: discriminator,
      encoding: "base58"
    }
  };
  return fetchDecodedProgramAccounts(
    rpc,
    WHIRLPOOL_PROGRAM_ADDRESS,
    [discriminatorFilter, ...filters],
    getWhirlpoolsConfigExtensionDecoder()
  );
}

// src/pda/feeTier.ts
import {
  getAddressEncoder as getAddressEncoder19,
  getProgramDerivedAddress,
  getU16Encoder as getU16Encoder17
} from "@solana/web3.js";
async function getFeeTierAddress(whirlpoolsConfig, tickSpacing) {
  return await getProgramDerivedAddress({
    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,
    seeds: [
      "fee_tier",
      getAddressEncoder19().encode(whirlpoolsConfig),
      getU16Encoder17().encode(tickSpacing)
    ]
  });
}

// src/pda/oracle.ts
import { getAddressEncoder as getAddressEncoder20, getProgramDerivedAddress as getProgramDerivedAddress2 } from "@solana/web3.js";
async function getOracleAddress(whirlpool) {
  return await getProgramDerivedAddress2({
    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,
    seeds: ["oracle", getAddressEncoder20().encode(whirlpool)]
  });
}

// src/pda/position.ts
import { getAddressEncoder as getAddressEncoder21, getProgramDerivedAddress as getProgramDerivedAddress3 } from "@solana/web3.js";
async function getPositionAddress(positionMint) {
  return await getProgramDerivedAddress3({
    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,
    seeds: ["position", getAddressEncoder21().encode(positionMint)]
  });
}

// src/pda/positionBundle.ts
import { getAddressEncoder as getAddressEncoder22, getProgramDerivedAddress as getProgramDerivedAddress4 } from "@solana/web3.js";
async function getPositionBundleAddress(positionBundleMint) {
  return await getProgramDerivedAddress4({
    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,
    seeds: ["position_bundle", getAddressEncoder22().encode(positionBundleMint)]
  });
}
async function getBundledPositionAddress(positionBundleAddress, bundleIndex) {
  return await getProgramDerivedAddress4({
    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,
    seeds: [
      "bundled_position",
      getAddressEncoder22().encode(positionBundleAddress),
      Buffer.from(bundleIndex.toString())
    ]
  });
}

// src/pda/tickArray.ts
import { getAddressEncoder as getAddressEncoder23, getProgramDerivedAddress as getProgramDerivedAddress5 } from "@solana/web3.js";
async function getTickArrayAddress(whirlpool, startTickIndex) {
  return await getProgramDerivedAddress5({
    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,
    seeds: [
      "tick_array",
      getAddressEncoder23().encode(whirlpool),
      `${startTickIndex}`
    ]
  });
}

// src/pda/tokenBadge.ts
import { getAddressEncoder as getAddressEncoder24, getProgramDerivedAddress as getProgramDerivedAddress6 } from "@solana/web3.js";
async function getTokenBadgeAddress(whirlpoolsConfig, tokenMint) {
  return await getProgramDerivedAddress6({
    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,
    seeds: [
      "token_badge",
      getAddressEncoder24().encode(whirlpoolsConfig),
      getAddressEncoder24().encode(tokenMint)
    ]
  });
}

// src/pda/whirlpool.ts
import {
  getAddressEncoder as getAddressEncoder25,
  getProgramDerivedAddress as getProgramDerivedAddress7,
  getU16Encoder as getU16Encoder18
} from "@solana/web3.js";
async function getWhirlpoolAddress(whirlpoolsConfig, tokenMintA, tokenMintB, tickSpacing) {
  return await getProgramDerivedAddress7({
    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,
    seeds: [
      "whirlpool",
      getAddressEncoder25().encode(whirlpoolsConfig),
      getAddressEncoder25().encode(tokenMintA),
      getAddressEncoder25().encode(tokenMintB),
      getU16Encoder18().encode(tickSpacing)
    ]
  });
}

// src/pda/whirlpoolsConfigExtension.ts
import { getAddressEncoder as getAddressEncoder26, getProgramDerivedAddress as getProgramDerivedAddress8 } from "@solana/web3.js";
async function getWhirlpoolsConfigExtensionAddress(configAddress) {
  return await getProgramDerivedAddress8({
    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,
    seeds: ["config_extension", getAddressEncoder26().encode(configAddress)]
  });
}
export {
  AccountsType,
  CLOSE_BUNDLED_POSITION_DISCRIMINATOR,
  CLOSE_POSITION_DISCRIMINATOR,
  CLOSE_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR,
  COLLECT_FEES_DISCRIMINATOR,
  COLLECT_FEES_V2_DISCRIMINATOR,
  COLLECT_PROTOCOL_FEES_DISCRIMINATOR,
  COLLECT_PROTOCOL_FEES_V2_DISCRIMINATOR,
  COLLECT_REWARD_DISCRIMINATOR,
  COLLECT_REWARD_V2_DISCRIMINATOR,
  DECREASE_LIQUIDITY_DISCRIMINATOR,
  DECREASE_LIQUIDITY_V2_DISCRIMINATOR,
  DELETE_POSITION_BUNDLE_DISCRIMINATOR,
  DELETE_TOKEN_BADGE_DISCRIMINATOR,
  FEE_TIER_DISCRIMINATOR,
  INCREASE_LIQUIDITY_DISCRIMINATOR,
  INCREASE_LIQUIDITY_V2_DISCRIMINATOR,
  INITIALIZE_CONFIG_DISCRIMINATOR,
  INITIALIZE_CONFIG_EXTENSION_DISCRIMINATOR,
  INITIALIZE_FEE_TIER_DISCRIMINATOR,
  INITIALIZE_POOL_DISCRIMINATOR,
  INITIALIZE_POOL_V2_DISCRIMINATOR,
  INITIALIZE_POSITION_BUNDLE_DISCRIMINATOR,
  INITIALIZE_POSITION_BUNDLE_WITH_METADATA_DISCRIMINATOR,
  INITIALIZE_REWARD_DISCRIMINATOR,
  INITIALIZE_REWARD_V2_DISCRIMINATOR,
  INITIALIZE_TICK_ARRAY_DISCRIMINATOR,
  INITIALIZE_TOKEN_BADGE_DISCRIMINATOR,
  OPEN_BUNDLED_POSITION_DISCRIMINATOR,
  OPEN_POSITION_DISCRIMINATOR,
  OPEN_POSITION_WITH_METADATA_DISCRIMINATOR,
  OPEN_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR,
  POSITION_BUNDLE_DISCRIMINATOR,
  POSITION_DISCRIMINATOR,
  SET_COLLECT_PROTOCOL_FEES_AUTHORITY_DISCRIMINATOR,
  SET_CONFIG_EXTENSION_AUTHORITY_DISCRIMINATOR,
  SET_DEFAULT_FEE_RATE_DISCRIMINATOR,
  SET_DEFAULT_PROTOCOL_FEE_RATE_DISCRIMINATOR,
  SET_FEE_AUTHORITY_DISCRIMINATOR,
  SET_FEE_RATE_DISCRIMINATOR,
  SET_PROTOCOL_FEE_RATE_DISCRIMINATOR,
  SET_REWARD_AUTHORITY_BY_SUPER_AUTHORITY_DISCRIMINATOR,
  SET_REWARD_AUTHORITY_DISCRIMINATOR,
  SET_REWARD_EMISSIONS_DISCRIMINATOR,
  SET_REWARD_EMISSIONS_SUPER_AUTHORITY_DISCRIMINATOR,
  SET_REWARD_EMISSIONS_V2_DISCRIMINATOR,
  SET_TOKEN_BADGE_AUTHORITY_DISCRIMINATOR,
  SWAP_DISCRIMINATOR,
  SWAP_V2_DISCRIMINATOR,
  TICK_ARRAY_DISCRIMINATOR,
  TOKEN_BADGE_DISCRIMINATOR,
  TWO_HOP_SWAP_DISCRIMINATOR,
  TWO_HOP_SWAP_V2_DISCRIMINATOR,
  UPDATE_FEES_AND_REWARDS_DISCRIMINATOR,
  WHIRLPOOLS_CONFIG_DISCRIMINATOR,
  WHIRLPOOLS_CONFIG_EXTENSION_DISCRIMINATOR,
  WHIRLPOOL_DISCRIMINATOR,
  WHIRLPOOL_ERROR__AMOUNT_CALC_OVERFLOW,
  WHIRLPOOL_ERROR__AMOUNT_IN_ABOVE_MAXIMUM,
  WHIRLPOOL_ERROR__AMOUNT_OUT_BELOW_MINIMUM,
  WHIRLPOOL_ERROR__AMOUNT_REMAINING_OVERFLOW,
  WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_CLOSED,
  WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_OPENED,
  WHIRLPOOL_ERROR__CLOSE_POSITION_NOT_EMPTY,
  WHIRLPOOL_ERROR__DIFFERENT_WHIRLPOOL_TICK_ARRAY_ACCOUNT,
  WHIRLPOOL_ERROR__DIVIDE_BY_ZERO,
  WHIRLPOOL_ERROR__DUPLICATE_TWO_HOP_POOL,
  WHIRLPOOL_ERROR__FEE_RATE_MAX_EXCEEDED,
  WHIRLPOOL_ERROR__FULL_RANGE_ONLY_POOL,
  WHIRLPOOL_ERROR__INTERMEDIATE_TOKEN_AMOUNT_MISMATCH,
  WHIRLPOOL_ERROR__INVALID_BUNDLE_INDEX,
  WHIRLPOOL_ERROR__INVALID_ENUM,
  WHIRLPOOL_ERROR__INVALID_INTERMEDIARY_MINT,
  WHIRLPOOL_ERROR__INVALID_POSITION_TOKEN_AMOUNT,
  WHIRLPOOL_ERROR__INVALID_REWARD_INDEX,
  WHIRLPOOL_ERROR__INVALID_SQRT_PRICE_LIMIT_DIRECTION,
  WHIRLPOOL_ERROR__INVALID_START_TICK,
  WHIRLPOOL_ERROR__INVALID_TICK_ARRAY_SEQUENCE,
  WHIRLPOOL_ERROR__INVALID_TICK_INDEX,
  WHIRLPOOL_ERROR__INVALID_TICK_SPACING,
  WHIRLPOOL_ERROR__INVALID_TIMESTAMP,
  WHIRLPOOL_ERROR__INVALID_TIMESTAMP_CONVERSION,
  WHIRLPOOL_ERROR__INVALID_TOKEN_MINT_ORDER,
  WHIRLPOOL_ERROR__LIQUIDITY_NET_ERROR,
  WHIRLPOOL_ERROR__LIQUIDITY_OVERFLOW,
  WHIRLPOOL_ERROR__LIQUIDITY_TOO_HIGH,
  WHIRLPOOL_ERROR__LIQUIDITY_UNDERFLOW,
  WHIRLPOOL_ERROR__LIQUIDITY_ZERO,
  WHIRLPOOL_ERROR__MISSING_OR_INVALID_DELEGATE,
  WHIRLPOOL_ERROR__MULTIPLICATION_OVERFLOW,
  WHIRLPOOL_ERROR__MULTIPLICATION_SHIFT_RIGHT_OVERFLOW,
  WHIRLPOOL_ERROR__MUL_DIV_INVALID_INPUT,
  WHIRLPOOL_ERROR__MUL_DIV_OVERFLOW,
  WHIRLPOOL_ERROR__NO_EXTRA_ACCOUNTS_FOR_TRANSFER_HOOK,
  WHIRLPOOL_ERROR__NUMBER_CAST_ERROR,
  WHIRLPOOL_ERROR__NUMBER_DOWN_CAST_ERROR,
  WHIRLPOOL_ERROR__PARTIAL_FILL_ERROR,
  WHIRLPOOL_ERROR__POSITION_BUNDLE_NOT_DELETABLE,
  WHIRLPOOL_ERROR__PROTOCOL_FEE_RATE_MAX_EXCEEDED,
  WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_DUPLICATED_ACCOUNTS_TYPE,
  WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INSUFFICIENT,
  WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INVALID_SLICE,
  WHIRLPOOL_ERROR__REWARD_NOT_INITIALIZED,
  WHIRLPOOL_ERROR__REWARD_VAULT_AMOUNT_INSUFFICIENT,
  WHIRLPOOL_ERROR__SQRT_PRICE_OUT_OF_BOUNDS,
  WHIRLPOOL_ERROR__TICK_ARRAY_EXIST_IN_POOL,
  WHIRLPOOL_ERROR__TICK_ARRAY_INDEX_OUTOF_BOUNDS,
  WHIRLPOOL_ERROR__TICK_ARRAY_SEQUENCE_INVALID_INDEX,
  WHIRLPOOL_ERROR__TICK_NOT_FOUND,
  WHIRLPOOL_ERROR__TOKEN_MAX_EXCEEDED,
  WHIRLPOOL_ERROR__TOKEN_MIN_SUBCEEDED,
  WHIRLPOOL_ERROR__TOO_MANY_SUPPLEMENTAL_TICK_ARRAYS,
  WHIRLPOOL_ERROR__TRANSFER_FEE_CALCULATION_ERROR,
  WHIRLPOOL_ERROR__UNSUPPORTED_TOKEN_MINT,
  WHIRLPOOL_ERROR__ZERO_TRADABLE_AMOUNT,
  WHIRLPOOL_PROGRAM_ADDRESS,
  WhirlpoolAccount,
  WhirlpoolInstruction,
  decodeFeeTier,
  decodePosition,
  decodePositionBundle,
  decodeTickArray,
  decodeTokenBadge,
  decodeWhirlpool,
  decodeWhirlpoolsConfig,
  decodeWhirlpoolsConfigExtension,
  feeTierFeeRateFilter,
  feeTierTickSpacingFilter,
  feeTierWhirlpoolsConfigFilter,
  fetchAllFeeTier,
  fetchAllFeeTierWithFilter,
  fetchAllMaybeFeeTier,
  fetchAllMaybePosition,
  fetchAllMaybePositionBundle,
  fetchAllMaybeTickArray,
  fetchAllMaybeTokenBadge,
  fetchAllMaybeWhirlpool,
  fetchAllMaybeWhirlpoolsConfig,
  fetchAllMaybeWhirlpoolsConfigExtension,
  fetchAllPosition,
  fetchAllPositionBundle,
  fetchAllPositionBundleWithFilter,
  fetchAllPositionWithFilter,
  fetchAllTickArray,
  fetchAllTickArrayWithFilter,
  fetchAllTokenBadge,
  fetchAllTokenBadgeWithFilter,
  fetchAllWhirlpool,
  fetchAllWhirlpoolWithFilter,
  fetchAllWhirlpoolsConfig,
  fetchAllWhirlpoolsConfigExtension,
  fetchAllWhirlpoolsConfigExtensionWithFilter,
  fetchAllWhirlpoolsConfigWithFilter,
  fetchFeeTier,
  fetchMaybeFeeTier,
  fetchMaybePosition,
  fetchMaybePositionBundle,
  fetchMaybeTickArray,
  fetchMaybeTokenBadge,
  fetchMaybeWhirlpool,
  fetchMaybeWhirlpoolsConfig,
  fetchMaybeWhirlpoolsConfigExtension,
  fetchPosition,
  fetchPositionBundle,
  fetchTickArray,
  fetchTokenBadge,
  fetchWhirlpool,
  fetchWhirlpoolsConfig,
  fetchWhirlpoolsConfigExtension,
  getAccountsTypeCodec,
  getAccountsTypeDecoder,
  getAccountsTypeEncoder,
  getBundledPositionAddress,
  getCloseBundledPositionDiscriminatorBytes,
  getCloseBundledPositionInstruction,
  getCloseBundledPositionInstructionDataCodec,
  getCloseBundledPositionInstructionDataDecoder,
  getCloseBundledPositionInstructionDataEncoder,
  getClosePositionDiscriminatorBytes,
  getClosePositionInstruction,
  getClosePositionInstructionDataCodec,
  getClosePositionInstructionDataDecoder,
  getClosePositionInstructionDataEncoder,
  getClosePositionWithTokenExtensionsDiscriminatorBytes,
  getClosePositionWithTokenExtensionsInstruction,
  getClosePositionWithTokenExtensionsInstructionDataCodec,
  getClosePositionWithTokenExtensionsInstructionDataDecoder,
  getClosePositionWithTokenExtensionsInstructionDataEncoder,
  getCollectFeesDiscriminatorBytes,
  getCollectFeesInstruction,
  getCollectFeesInstructionDataCodec,
  getCollectFeesInstructionDataDecoder,
  getCollectFeesInstructionDataEncoder,
  getCollectFeesV2DiscriminatorBytes,
  getCollectFeesV2Instruction,
  getCollectFeesV2InstructionDataCodec,
  getCollectFeesV2InstructionDataDecoder,
  getCollectFeesV2InstructionDataEncoder,
  getCollectProtocolFeesDiscriminatorBytes,
  getCollectProtocolFeesInstruction,
  getCollectProtocolFeesInstructionDataCodec,
  getCollectProtocolFeesInstructionDataDecoder,
  getCollectProtocolFeesInstructionDataEncoder,
  getCollectProtocolFeesV2DiscriminatorBytes,
  getCollectProtocolFeesV2Instruction,
  getCollectProtocolFeesV2InstructionDataCodec,
  getCollectProtocolFeesV2InstructionDataDecoder,
  getCollectProtocolFeesV2InstructionDataEncoder,
  getCollectRewardDiscriminatorBytes,
  getCollectRewardInstruction,
  getCollectRewardInstructionDataCodec,
  getCollectRewardInstructionDataDecoder,
  getCollectRewardInstructionDataEncoder,
  getCollectRewardV2DiscriminatorBytes,
  getCollectRewardV2Instruction,
  getCollectRewardV2InstructionDataCodec,
  getCollectRewardV2InstructionDataDecoder,
  getCollectRewardV2InstructionDataEncoder,
  getDecreaseLiquidityDiscriminatorBytes,
  getDecreaseLiquidityInstruction,
  getDecreaseLiquidityInstructionDataCodec,
  getDecreaseLiquidityInstructionDataDecoder,
  getDecreaseLiquidityInstructionDataEncoder,
  getDecreaseLiquidityV2DiscriminatorBytes,
  getDecreaseLiquidityV2Instruction,
  getDecreaseLiquidityV2InstructionDataCodec,
  getDecreaseLiquidityV2InstructionDataDecoder,
  getDecreaseLiquidityV2InstructionDataEncoder,
  getDeletePositionBundleDiscriminatorBytes,
  getDeletePositionBundleInstruction,
  getDeletePositionBundleInstructionDataCodec,
  getDeletePositionBundleInstructionDataDecoder,
  getDeletePositionBundleInstructionDataEncoder,
  getDeleteTokenBadgeDiscriminatorBytes,
  getDeleteTokenBadgeInstruction,
  getDeleteTokenBadgeInstructionDataCodec,
  getDeleteTokenBadgeInstructionDataDecoder,
  getDeleteTokenBadgeInstructionDataEncoder,
  getFeeTierAddress,
  getFeeTierCodec,
  getFeeTierDecoder,
  getFeeTierDiscriminatorBytes,
  getFeeTierEncoder,
  getFeeTierSize,
  getIncreaseLiquidityDiscriminatorBytes,
  getIncreaseLiquidityInstruction,
  getIncreaseLiquidityInstructionDataCodec,
  getIncreaseLiquidityInstructionDataDecoder,
  getIncreaseLiquidityInstructionDataEncoder,
  getIncreaseLiquidityV2DiscriminatorBytes,
  getIncreaseLiquidityV2Instruction,
  getIncreaseLiquidityV2InstructionDataCodec,
  getIncreaseLiquidityV2InstructionDataDecoder,
  getIncreaseLiquidityV2InstructionDataEncoder,
  getInitializeConfigDiscriminatorBytes,
  getInitializeConfigExtensionDiscriminatorBytes,
  getInitializeConfigExtensionInstruction,
  getInitializeConfigExtensionInstructionDataCodec,
  getInitializeConfigExtensionInstructionDataDecoder,
  getInitializeConfigExtensionInstructionDataEncoder,
  getInitializeConfigInstruction,
  getInitializeConfigInstructionDataCodec,
  getInitializeConfigInstructionDataDecoder,
  getInitializeConfigInstructionDataEncoder,
  getInitializeFeeTierDiscriminatorBytes,
  getInitializeFeeTierInstruction,
  getInitializeFeeTierInstructionDataCodec,
  getInitializeFeeTierInstructionDataDecoder,
  getInitializeFeeTierInstructionDataEncoder,
  getInitializePoolDiscriminatorBytes,
  getInitializePoolInstruction,
  getInitializePoolInstructionDataCodec,
  getInitializePoolInstructionDataDecoder,
  getInitializePoolInstructionDataEncoder,
  getInitializePoolV2DiscriminatorBytes,
  getInitializePoolV2Instruction,
  getInitializePoolV2InstructionDataCodec,
  getInitializePoolV2InstructionDataDecoder,
  getInitializePoolV2InstructionDataEncoder,
  getInitializePositionBundleDiscriminatorBytes,
  getInitializePositionBundleInstruction,
  getInitializePositionBundleInstructionDataCodec,
  getInitializePositionBundleInstructionDataDecoder,
  getInitializePositionBundleInstructionDataEncoder,
  getInitializePositionBundleWithMetadataDiscriminatorBytes,
  getInitializePositionBundleWithMetadataInstruction,
  getInitializePositionBundleWithMetadataInstructionDataCodec,
  getInitializePositionBundleWithMetadataInstructionDataDecoder,
  getInitializePositionBundleWithMetadataInstructionDataEncoder,
  getInitializeRewardDiscriminatorBytes,
  getInitializeRewardInstruction,
  getInitializeRewardInstructionDataCodec,
  getInitializeRewardInstructionDataDecoder,
  getInitializeRewardInstructionDataEncoder,
  getInitializeRewardV2DiscriminatorBytes,
  getInitializeRewardV2Instruction,
  getInitializeRewardV2InstructionDataCodec,
  getInitializeRewardV2InstructionDataDecoder,
  getInitializeRewardV2InstructionDataEncoder,
  getInitializeTickArrayDiscriminatorBytes,
  getInitializeTickArrayInstruction,
  getInitializeTickArrayInstructionDataCodec,
  getInitializeTickArrayInstructionDataDecoder,
  getInitializeTickArrayInstructionDataEncoder,
  getInitializeTokenBadgeDiscriminatorBytes,
  getInitializeTokenBadgeInstruction,
  getInitializeTokenBadgeInstructionDataCodec,
  getInitializeTokenBadgeInstructionDataDecoder,
  getInitializeTokenBadgeInstructionDataEncoder,
  getOpenBundledPositionDiscriminatorBytes,
  getOpenBundledPositionInstruction,
  getOpenBundledPositionInstructionDataCodec,
  getOpenBundledPositionInstructionDataDecoder,
  getOpenBundledPositionInstructionDataEncoder,
  getOpenPositionDiscriminatorBytes,
  getOpenPositionInstruction,
  getOpenPositionInstructionDataCodec,
  getOpenPositionInstructionDataDecoder,
  getOpenPositionInstructionDataEncoder,
  getOpenPositionWithMetadataDiscriminatorBytes,
  getOpenPositionWithMetadataInstruction,
  getOpenPositionWithMetadataInstructionDataCodec,
  getOpenPositionWithMetadataInstructionDataDecoder,
  getOpenPositionWithMetadataInstructionDataEncoder,
  getOpenPositionWithTokenExtensionsDiscriminatorBytes,
  getOpenPositionWithTokenExtensionsInstruction,
  getOpenPositionWithTokenExtensionsInstructionDataCodec,
  getOpenPositionWithTokenExtensionsInstructionDataDecoder,
  getOpenPositionWithTokenExtensionsInstructionDataEncoder,
  getOracleAddress,
  getPositionAddress,
  getPositionBundleAddress,
  getPositionBundleCodec,
  getPositionBundleDecoder,
  getPositionBundleDiscriminatorBytes,
  getPositionBundleEncoder,
  getPositionBundleSize,
  getPositionCodec,
  getPositionDecoder,
  getPositionDiscriminatorBytes,
  getPositionEncoder,
  getPositionRewardInfoCodec,
  getPositionRewardInfoDecoder,
  getPositionRewardInfoEncoder,
  getPositionSize,
  getRemainingAccountsInfoCodec,
  getRemainingAccountsInfoDecoder,
  getRemainingAccountsInfoEncoder,
  getRemainingAccountsSliceCodec,
  getRemainingAccountsSliceDecoder,
  getRemainingAccountsSliceEncoder,
  getSetCollectProtocolFeesAuthorityDiscriminatorBytes,
  getSetCollectProtocolFeesAuthorityInstruction,
  getSetCollectProtocolFeesAuthorityInstructionDataCodec,
  getSetCollectProtocolFeesAuthorityInstructionDataDecoder,
  getSetCollectProtocolFeesAuthorityInstructionDataEncoder,
  getSetConfigExtensionAuthorityDiscriminatorBytes,
  getSetConfigExtensionAuthorityInstruction,
  getSetConfigExtensionAuthorityInstructionDataCodec,
  getSetConfigExtensionAuthorityInstructionDataDecoder,
  getSetConfigExtensionAuthorityInstructionDataEncoder,
  getSetDefaultFeeRateDiscriminatorBytes,
  getSetDefaultFeeRateInstruction,
  getSetDefaultFeeRateInstructionDataCodec,
  getSetDefaultFeeRateInstructionDataDecoder,
  getSetDefaultFeeRateInstructionDataEncoder,
  getSetDefaultProtocolFeeRateDiscriminatorBytes,
  getSetDefaultProtocolFeeRateInstruction,
  getSetDefaultProtocolFeeRateInstructionDataCodec,
  getSetDefaultProtocolFeeRateInstructionDataDecoder,
  getSetDefaultProtocolFeeRateInstructionDataEncoder,
  getSetFeeAuthorityDiscriminatorBytes,
  getSetFeeAuthorityInstruction,
  getSetFeeAuthorityInstructionDataCodec,
  getSetFeeAuthorityInstructionDataDecoder,
  getSetFeeAuthorityInstructionDataEncoder,
  getSetFeeRateDiscriminatorBytes,
  getSetFeeRateInstruction,
  getSetFeeRateInstructionDataCodec,
  getSetFeeRateInstructionDataDecoder,
  getSetFeeRateInstructionDataEncoder,
  getSetProtocolFeeRateDiscriminatorBytes,
  getSetProtocolFeeRateInstruction,
  getSetProtocolFeeRateInstructionDataCodec,
  getSetProtocolFeeRateInstructionDataDecoder,
  getSetProtocolFeeRateInstructionDataEncoder,
  getSetRewardAuthorityBySuperAuthorityDiscriminatorBytes,
  getSetRewardAuthorityBySuperAuthorityInstruction,
  getSetRewardAuthorityBySuperAuthorityInstructionDataCodec,
  getSetRewardAuthorityBySuperAuthorityInstructionDataDecoder,
  getSetRewardAuthorityBySuperAuthorityInstructionDataEncoder,
  getSetRewardAuthorityDiscriminatorBytes,
  getSetRewardAuthorityInstruction,
  getSetRewardAuthorityInstructionDataCodec,
  getSetRewardAuthorityInstructionDataDecoder,
  getSetRewardAuthorityInstructionDataEncoder,
  getSetRewardEmissionsDiscriminatorBytes,
  getSetRewardEmissionsInstruction,
  getSetRewardEmissionsInstructionDataCodec,
  getSetRewardEmissionsInstructionDataDecoder,
  getSetRewardEmissionsInstructionDataEncoder,
  getSetRewardEmissionsSuperAuthorityDiscriminatorBytes,
  getSetRewardEmissionsSuperAuthorityInstruction,
  getSetRewardEmissionsSuperAuthorityInstructionDataCodec,
  getSetRewardEmissionsSuperAuthorityInstructionDataDecoder,
  getSetRewardEmissionsSuperAuthorityInstructionDataEncoder,
  getSetRewardEmissionsV2DiscriminatorBytes,
  getSetRewardEmissionsV2Instruction,
  getSetRewardEmissionsV2InstructionDataCodec,
  getSetRewardEmissionsV2InstructionDataDecoder,
  getSetRewardEmissionsV2InstructionDataEncoder,
  getSetTokenBadgeAuthorityDiscriminatorBytes,
  getSetTokenBadgeAuthorityInstruction,
  getSetTokenBadgeAuthorityInstructionDataCodec,
  getSetTokenBadgeAuthorityInstructionDataDecoder,
  getSetTokenBadgeAuthorityInstructionDataEncoder,
  getSwapDiscriminatorBytes,
  getSwapInstruction,
  getSwapInstructionDataCodec,
  getSwapInstructionDataDecoder,
  getSwapInstructionDataEncoder,
  getSwapV2DiscriminatorBytes,
  getSwapV2Instruction,
  getSwapV2InstructionDataCodec,
  getSwapV2InstructionDataDecoder,
  getSwapV2InstructionDataEncoder,
  getTickArrayAddress,
  getTickArrayCodec,
  getTickArrayDecoder,
  getTickArrayDiscriminatorBytes,
  getTickArrayEncoder,
  getTickArraySize,
  getTickCodec,
  getTickDecoder,
  getTickEncoder,
  getTokenBadgeAddress,
  getTokenBadgeCodec,
  getTokenBadgeDecoder,
  getTokenBadgeDiscriminatorBytes,
  getTokenBadgeEncoder,
  getTokenBadgeSize,
  getTwoHopSwapDiscriminatorBytes,
  getTwoHopSwapInstruction,
  getTwoHopSwapInstructionDataCodec,
  getTwoHopSwapInstructionDataDecoder,
  getTwoHopSwapInstructionDataEncoder,
  getTwoHopSwapV2DiscriminatorBytes,
  getTwoHopSwapV2Instruction,
  getTwoHopSwapV2InstructionDataCodec,
  getTwoHopSwapV2InstructionDataDecoder,
  getTwoHopSwapV2InstructionDataEncoder,
  getUpdateFeesAndRewardsDiscriminatorBytes,
  getUpdateFeesAndRewardsInstruction,
  getUpdateFeesAndRewardsInstructionDataCodec,
  getUpdateFeesAndRewardsInstructionDataDecoder,
  getUpdateFeesAndRewardsInstructionDataEncoder,
  getWhirlpoolAddress,
  getWhirlpoolCodec,
  getWhirlpoolDecoder,
  getWhirlpoolDiscriminatorBytes,
  getWhirlpoolEncoder,
  getWhirlpoolErrorMessage,
  getWhirlpoolRewardInfoCodec,
  getWhirlpoolRewardInfoDecoder,
  getWhirlpoolRewardInfoEncoder,
  getWhirlpoolSize,
  getWhirlpoolsConfigCodec,
  getWhirlpoolsConfigDecoder,
  getWhirlpoolsConfigDiscriminatorBytes,
  getWhirlpoolsConfigEncoder,
  getWhirlpoolsConfigExtensionAddress,
  getWhirlpoolsConfigExtensionCodec,
  getWhirlpoolsConfigExtensionDecoder,
  getWhirlpoolsConfigExtensionDiscriminatorBytes,
  getWhirlpoolsConfigExtensionEncoder,
  getWhirlpoolsConfigExtensionSize,
  getWhirlpoolsConfigSize,
  identifyWhirlpoolAccount,
  identifyWhirlpoolInstruction,
  isWhirlpoolError,
  parseCloseBundledPositionInstruction,
  parseClosePositionInstruction,
  parseClosePositionWithTokenExtensionsInstruction,
  parseCollectFeesInstruction,
  parseCollectFeesV2Instruction,
  parseCollectProtocolFeesInstruction,
  parseCollectProtocolFeesV2Instruction,
  parseCollectRewardInstruction,
  parseCollectRewardV2Instruction,
  parseDecreaseLiquidityInstruction,
  parseDecreaseLiquidityV2Instruction,
  parseDeletePositionBundleInstruction,
  parseDeleteTokenBadgeInstruction,
  parseIncreaseLiquidityInstruction,
  parseIncreaseLiquidityV2Instruction,
  parseInitializeConfigExtensionInstruction,
  parseInitializeConfigInstruction,
  parseInitializeFeeTierInstruction,
  parseInitializePoolInstruction,
  parseInitializePoolV2Instruction,
  parseInitializePositionBundleInstruction,
  parseInitializePositionBundleWithMetadataInstruction,
  parseInitializeRewardInstruction,
  parseInitializeRewardV2Instruction,
  parseInitializeTickArrayInstruction,
  parseInitializeTokenBadgeInstruction,
  parseOpenBundledPositionInstruction,
  parseOpenPositionInstruction,
  parseOpenPositionWithMetadataInstruction,
  parseOpenPositionWithTokenExtensionsInstruction,
  parseSetCollectProtocolFeesAuthorityInstruction,
  parseSetConfigExtensionAuthorityInstruction,
  parseSetDefaultFeeRateInstruction,
  parseSetDefaultProtocolFeeRateInstruction,
  parseSetFeeAuthorityInstruction,
  parseSetFeeRateInstruction,
  parseSetProtocolFeeRateInstruction,
  parseSetRewardAuthorityBySuperAuthorityInstruction,
  parseSetRewardAuthorityInstruction,
  parseSetRewardEmissionsInstruction,
  parseSetRewardEmissionsSuperAuthorityInstruction,
  parseSetRewardEmissionsV2Instruction,
  parseSetTokenBadgeAuthorityInstruction,
  parseSwapInstruction,
  parseSwapV2Instruction,
  parseTwoHopSwapInstruction,
  parseTwoHopSwapV2Instruction,
  parseUpdateFeesAndRewardsInstruction,
  positionBundleMintFilter,
  positionMintFilter,
  positionTickLowerIndexFilter,
  positionTickUpperIndexFilter,
  positionWhirlpoolFilter,
  tickArrayStartTickIndexFilter,
  tickArrayWhirlpoolFilter,
  tokenBadgeTokenMintFilter,
  tokenBadgeWhirlpoolsConfigFilter,
  whirlpoolFeeRateFilter,
  whirlpoolProtocolFeeRateFilter,
  whirlpoolRewardMint1Filter,
  whirlpoolRewardMint2Filter,
  whirlpoolRewardMint3Filter,
  whirlpoolRewardVault1Filter,
  whirlpoolRewardVault2Filter,
  whirlpoolRewardVault3Filter,
  whirlpoolTickSpacingFilter,
  whirlpoolTokenMintAFilter,
  whirlpoolTokenMintBFilter,
  whirlpoolTokenVaultAFilter,
  whirlpoolTokenVaultBFilter,
  whirlpoolWhirlpoolConfigFilter,
  whirlpoolsConfigCollectProtocolFeesAuthorityFilter,
  whirlpoolsConfigDefaultProtocolFeeRateFilter,
  whirlpoolsConfigExtensionConfigExtensionAuthorityFilter,
  whirlpoolsConfigExtensionConfigTokenBadgeAuthorityFilter,
  whirlpoolsConfigExtensionWhirlpoolsConfigFilter,
  whirlpoolsConfigFeeAuthorityFilter,
  whirlpoolsConfigRewardEmissionsSuperAuthorityFilter
};
//# sourceMappingURL=index.js.map