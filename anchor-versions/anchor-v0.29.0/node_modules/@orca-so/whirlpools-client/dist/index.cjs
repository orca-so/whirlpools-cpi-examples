"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AccountsType: () => AccountsType,
  CLOSE_BUNDLED_POSITION_DISCRIMINATOR: () => CLOSE_BUNDLED_POSITION_DISCRIMINATOR,
  CLOSE_POSITION_DISCRIMINATOR: () => CLOSE_POSITION_DISCRIMINATOR,
  CLOSE_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR: () => CLOSE_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR,
  COLLECT_FEES_DISCRIMINATOR: () => COLLECT_FEES_DISCRIMINATOR,
  COLLECT_FEES_V2_DISCRIMINATOR: () => COLLECT_FEES_V2_DISCRIMINATOR,
  COLLECT_PROTOCOL_FEES_DISCRIMINATOR: () => COLLECT_PROTOCOL_FEES_DISCRIMINATOR,
  COLLECT_PROTOCOL_FEES_V2_DISCRIMINATOR: () => COLLECT_PROTOCOL_FEES_V2_DISCRIMINATOR,
  COLLECT_REWARD_DISCRIMINATOR: () => COLLECT_REWARD_DISCRIMINATOR,
  COLLECT_REWARD_V2_DISCRIMINATOR: () => COLLECT_REWARD_V2_DISCRIMINATOR,
  DECREASE_LIQUIDITY_DISCRIMINATOR: () => DECREASE_LIQUIDITY_DISCRIMINATOR,
  DECREASE_LIQUIDITY_V2_DISCRIMINATOR: () => DECREASE_LIQUIDITY_V2_DISCRIMINATOR,
  DELETE_POSITION_BUNDLE_DISCRIMINATOR: () => DELETE_POSITION_BUNDLE_DISCRIMINATOR,
  DELETE_TOKEN_BADGE_DISCRIMINATOR: () => DELETE_TOKEN_BADGE_DISCRIMINATOR,
  FEE_TIER_DISCRIMINATOR: () => FEE_TIER_DISCRIMINATOR,
  INCREASE_LIQUIDITY_DISCRIMINATOR: () => INCREASE_LIQUIDITY_DISCRIMINATOR,
  INCREASE_LIQUIDITY_V2_DISCRIMINATOR: () => INCREASE_LIQUIDITY_V2_DISCRIMINATOR,
  INITIALIZE_CONFIG_DISCRIMINATOR: () => INITIALIZE_CONFIG_DISCRIMINATOR,
  INITIALIZE_CONFIG_EXTENSION_DISCRIMINATOR: () => INITIALIZE_CONFIG_EXTENSION_DISCRIMINATOR,
  INITIALIZE_FEE_TIER_DISCRIMINATOR: () => INITIALIZE_FEE_TIER_DISCRIMINATOR,
  INITIALIZE_POOL_DISCRIMINATOR: () => INITIALIZE_POOL_DISCRIMINATOR,
  INITIALIZE_POOL_V2_DISCRIMINATOR: () => INITIALIZE_POOL_V2_DISCRIMINATOR,
  INITIALIZE_POSITION_BUNDLE_DISCRIMINATOR: () => INITIALIZE_POSITION_BUNDLE_DISCRIMINATOR,
  INITIALIZE_POSITION_BUNDLE_WITH_METADATA_DISCRIMINATOR: () => INITIALIZE_POSITION_BUNDLE_WITH_METADATA_DISCRIMINATOR,
  INITIALIZE_REWARD_DISCRIMINATOR: () => INITIALIZE_REWARD_DISCRIMINATOR,
  INITIALIZE_REWARD_V2_DISCRIMINATOR: () => INITIALIZE_REWARD_V2_DISCRIMINATOR,
  INITIALIZE_TICK_ARRAY_DISCRIMINATOR: () => INITIALIZE_TICK_ARRAY_DISCRIMINATOR,
  INITIALIZE_TOKEN_BADGE_DISCRIMINATOR: () => INITIALIZE_TOKEN_BADGE_DISCRIMINATOR,
  OPEN_BUNDLED_POSITION_DISCRIMINATOR: () => OPEN_BUNDLED_POSITION_DISCRIMINATOR,
  OPEN_POSITION_DISCRIMINATOR: () => OPEN_POSITION_DISCRIMINATOR,
  OPEN_POSITION_WITH_METADATA_DISCRIMINATOR: () => OPEN_POSITION_WITH_METADATA_DISCRIMINATOR,
  OPEN_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR: () => OPEN_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR,
  POSITION_BUNDLE_DISCRIMINATOR: () => POSITION_BUNDLE_DISCRIMINATOR,
  POSITION_DISCRIMINATOR: () => POSITION_DISCRIMINATOR,
  SET_COLLECT_PROTOCOL_FEES_AUTHORITY_DISCRIMINATOR: () => SET_COLLECT_PROTOCOL_FEES_AUTHORITY_DISCRIMINATOR,
  SET_CONFIG_EXTENSION_AUTHORITY_DISCRIMINATOR: () => SET_CONFIG_EXTENSION_AUTHORITY_DISCRIMINATOR,
  SET_DEFAULT_FEE_RATE_DISCRIMINATOR: () => SET_DEFAULT_FEE_RATE_DISCRIMINATOR,
  SET_DEFAULT_PROTOCOL_FEE_RATE_DISCRIMINATOR: () => SET_DEFAULT_PROTOCOL_FEE_RATE_DISCRIMINATOR,
  SET_FEE_AUTHORITY_DISCRIMINATOR: () => SET_FEE_AUTHORITY_DISCRIMINATOR,
  SET_FEE_RATE_DISCRIMINATOR: () => SET_FEE_RATE_DISCRIMINATOR,
  SET_PROTOCOL_FEE_RATE_DISCRIMINATOR: () => SET_PROTOCOL_FEE_RATE_DISCRIMINATOR,
  SET_REWARD_AUTHORITY_BY_SUPER_AUTHORITY_DISCRIMINATOR: () => SET_REWARD_AUTHORITY_BY_SUPER_AUTHORITY_DISCRIMINATOR,
  SET_REWARD_AUTHORITY_DISCRIMINATOR: () => SET_REWARD_AUTHORITY_DISCRIMINATOR,
  SET_REWARD_EMISSIONS_DISCRIMINATOR: () => SET_REWARD_EMISSIONS_DISCRIMINATOR,
  SET_REWARD_EMISSIONS_SUPER_AUTHORITY_DISCRIMINATOR: () => SET_REWARD_EMISSIONS_SUPER_AUTHORITY_DISCRIMINATOR,
  SET_REWARD_EMISSIONS_V2_DISCRIMINATOR: () => SET_REWARD_EMISSIONS_V2_DISCRIMINATOR,
  SET_TOKEN_BADGE_AUTHORITY_DISCRIMINATOR: () => SET_TOKEN_BADGE_AUTHORITY_DISCRIMINATOR,
  SWAP_DISCRIMINATOR: () => SWAP_DISCRIMINATOR,
  SWAP_V2_DISCRIMINATOR: () => SWAP_V2_DISCRIMINATOR,
  TICK_ARRAY_DISCRIMINATOR: () => TICK_ARRAY_DISCRIMINATOR,
  TOKEN_BADGE_DISCRIMINATOR: () => TOKEN_BADGE_DISCRIMINATOR,
  TWO_HOP_SWAP_DISCRIMINATOR: () => TWO_HOP_SWAP_DISCRIMINATOR,
  TWO_HOP_SWAP_V2_DISCRIMINATOR: () => TWO_HOP_SWAP_V2_DISCRIMINATOR,
  UPDATE_FEES_AND_REWARDS_DISCRIMINATOR: () => UPDATE_FEES_AND_REWARDS_DISCRIMINATOR,
  WHIRLPOOLS_CONFIG_DISCRIMINATOR: () => WHIRLPOOLS_CONFIG_DISCRIMINATOR,
  WHIRLPOOLS_CONFIG_EXTENSION_DISCRIMINATOR: () => WHIRLPOOLS_CONFIG_EXTENSION_DISCRIMINATOR,
  WHIRLPOOL_DISCRIMINATOR: () => WHIRLPOOL_DISCRIMINATOR,
  WHIRLPOOL_ERROR__AMOUNT_CALC_OVERFLOW: () => WHIRLPOOL_ERROR__AMOUNT_CALC_OVERFLOW,
  WHIRLPOOL_ERROR__AMOUNT_IN_ABOVE_MAXIMUM: () => WHIRLPOOL_ERROR__AMOUNT_IN_ABOVE_MAXIMUM,
  WHIRLPOOL_ERROR__AMOUNT_OUT_BELOW_MINIMUM: () => WHIRLPOOL_ERROR__AMOUNT_OUT_BELOW_MINIMUM,
  WHIRLPOOL_ERROR__AMOUNT_REMAINING_OVERFLOW: () => WHIRLPOOL_ERROR__AMOUNT_REMAINING_OVERFLOW,
  WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_CLOSED: () => WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_CLOSED,
  WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_OPENED: () => WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_OPENED,
  WHIRLPOOL_ERROR__CLOSE_POSITION_NOT_EMPTY: () => WHIRLPOOL_ERROR__CLOSE_POSITION_NOT_EMPTY,
  WHIRLPOOL_ERROR__DIFFERENT_WHIRLPOOL_TICK_ARRAY_ACCOUNT: () => WHIRLPOOL_ERROR__DIFFERENT_WHIRLPOOL_TICK_ARRAY_ACCOUNT,
  WHIRLPOOL_ERROR__DIVIDE_BY_ZERO: () => WHIRLPOOL_ERROR__DIVIDE_BY_ZERO,
  WHIRLPOOL_ERROR__DUPLICATE_TWO_HOP_POOL: () => WHIRLPOOL_ERROR__DUPLICATE_TWO_HOP_POOL,
  WHIRLPOOL_ERROR__FEE_RATE_MAX_EXCEEDED: () => WHIRLPOOL_ERROR__FEE_RATE_MAX_EXCEEDED,
  WHIRLPOOL_ERROR__FULL_RANGE_ONLY_POOL: () => WHIRLPOOL_ERROR__FULL_RANGE_ONLY_POOL,
  WHIRLPOOL_ERROR__INTERMEDIATE_TOKEN_AMOUNT_MISMATCH: () => WHIRLPOOL_ERROR__INTERMEDIATE_TOKEN_AMOUNT_MISMATCH,
  WHIRLPOOL_ERROR__INVALID_BUNDLE_INDEX: () => WHIRLPOOL_ERROR__INVALID_BUNDLE_INDEX,
  WHIRLPOOL_ERROR__INVALID_ENUM: () => WHIRLPOOL_ERROR__INVALID_ENUM,
  WHIRLPOOL_ERROR__INVALID_INTERMEDIARY_MINT: () => WHIRLPOOL_ERROR__INVALID_INTERMEDIARY_MINT,
  WHIRLPOOL_ERROR__INVALID_POSITION_TOKEN_AMOUNT: () => WHIRLPOOL_ERROR__INVALID_POSITION_TOKEN_AMOUNT,
  WHIRLPOOL_ERROR__INVALID_REWARD_INDEX: () => WHIRLPOOL_ERROR__INVALID_REWARD_INDEX,
  WHIRLPOOL_ERROR__INVALID_SQRT_PRICE_LIMIT_DIRECTION: () => WHIRLPOOL_ERROR__INVALID_SQRT_PRICE_LIMIT_DIRECTION,
  WHIRLPOOL_ERROR__INVALID_START_TICK: () => WHIRLPOOL_ERROR__INVALID_START_TICK,
  WHIRLPOOL_ERROR__INVALID_TICK_ARRAY_SEQUENCE: () => WHIRLPOOL_ERROR__INVALID_TICK_ARRAY_SEQUENCE,
  WHIRLPOOL_ERROR__INVALID_TICK_INDEX: () => WHIRLPOOL_ERROR__INVALID_TICK_INDEX,
  WHIRLPOOL_ERROR__INVALID_TICK_SPACING: () => WHIRLPOOL_ERROR__INVALID_TICK_SPACING,
  WHIRLPOOL_ERROR__INVALID_TIMESTAMP: () => WHIRLPOOL_ERROR__INVALID_TIMESTAMP,
  WHIRLPOOL_ERROR__INVALID_TIMESTAMP_CONVERSION: () => WHIRLPOOL_ERROR__INVALID_TIMESTAMP_CONVERSION,
  WHIRLPOOL_ERROR__INVALID_TOKEN_MINT_ORDER: () => WHIRLPOOL_ERROR__INVALID_TOKEN_MINT_ORDER,
  WHIRLPOOL_ERROR__LIQUIDITY_NET_ERROR: () => WHIRLPOOL_ERROR__LIQUIDITY_NET_ERROR,
  WHIRLPOOL_ERROR__LIQUIDITY_OVERFLOW: () => WHIRLPOOL_ERROR__LIQUIDITY_OVERFLOW,
  WHIRLPOOL_ERROR__LIQUIDITY_TOO_HIGH: () => WHIRLPOOL_ERROR__LIQUIDITY_TOO_HIGH,
  WHIRLPOOL_ERROR__LIQUIDITY_UNDERFLOW: () => WHIRLPOOL_ERROR__LIQUIDITY_UNDERFLOW,
  WHIRLPOOL_ERROR__LIQUIDITY_ZERO: () => WHIRLPOOL_ERROR__LIQUIDITY_ZERO,
  WHIRLPOOL_ERROR__MISSING_OR_INVALID_DELEGATE: () => WHIRLPOOL_ERROR__MISSING_OR_INVALID_DELEGATE,
  WHIRLPOOL_ERROR__MULTIPLICATION_OVERFLOW: () => WHIRLPOOL_ERROR__MULTIPLICATION_OVERFLOW,
  WHIRLPOOL_ERROR__MULTIPLICATION_SHIFT_RIGHT_OVERFLOW: () => WHIRLPOOL_ERROR__MULTIPLICATION_SHIFT_RIGHT_OVERFLOW,
  WHIRLPOOL_ERROR__MUL_DIV_INVALID_INPUT: () => WHIRLPOOL_ERROR__MUL_DIV_INVALID_INPUT,
  WHIRLPOOL_ERROR__MUL_DIV_OVERFLOW: () => WHIRLPOOL_ERROR__MUL_DIV_OVERFLOW,
  WHIRLPOOL_ERROR__NO_EXTRA_ACCOUNTS_FOR_TRANSFER_HOOK: () => WHIRLPOOL_ERROR__NO_EXTRA_ACCOUNTS_FOR_TRANSFER_HOOK,
  WHIRLPOOL_ERROR__NUMBER_CAST_ERROR: () => WHIRLPOOL_ERROR__NUMBER_CAST_ERROR,
  WHIRLPOOL_ERROR__NUMBER_DOWN_CAST_ERROR: () => WHIRLPOOL_ERROR__NUMBER_DOWN_CAST_ERROR,
  WHIRLPOOL_ERROR__PARTIAL_FILL_ERROR: () => WHIRLPOOL_ERROR__PARTIAL_FILL_ERROR,
  WHIRLPOOL_ERROR__POSITION_BUNDLE_NOT_DELETABLE: () => WHIRLPOOL_ERROR__POSITION_BUNDLE_NOT_DELETABLE,
  WHIRLPOOL_ERROR__PROTOCOL_FEE_RATE_MAX_EXCEEDED: () => WHIRLPOOL_ERROR__PROTOCOL_FEE_RATE_MAX_EXCEEDED,
  WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_DUPLICATED_ACCOUNTS_TYPE: () => WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_DUPLICATED_ACCOUNTS_TYPE,
  WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INSUFFICIENT: () => WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INSUFFICIENT,
  WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INVALID_SLICE: () => WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INVALID_SLICE,
  WHIRLPOOL_ERROR__REWARD_NOT_INITIALIZED: () => WHIRLPOOL_ERROR__REWARD_NOT_INITIALIZED,
  WHIRLPOOL_ERROR__REWARD_VAULT_AMOUNT_INSUFFICIENT: () => WHIRLPOOL_ERROR__REWARD_VAULT_AMOUNT_INSUFFICIENT,
  WHIRLPOOL_ERROR__SQRT_PRICE_OUT_OF_BOUNDS: () => WHIRLPOOL_ERROR__SQRT_PRICE_OUT_OF_BOUNDS,
  WHIRLPOOL_ERROR__TICK_ARRAY_EXIST_IN_POOL: () => WHIRLPOOL_ERROR__TICK_ARRAY_EXIST_IN_POOL,
  WHIRLPOOL_ERROR__TICK_ARRAY_INDEX_OUTOF_BOUNDS: () => WHIRLPOOL_ERROR__TICK_ARRAY_INDEX_OUTOF_BOUNDS,
  WHIRLPOOL_ERROR__TICK_ARRAY_SEQUENCE_INVALID_INDEX: () => WHIRLPOOL_ERROR__TICK_ARRAY_SEQUENCE_INVALID_INDEX,
  WHIRLPOOL_ERROR__TICK_NOT_FOUND: () => WHIRLPOOL_ERROR__TICK_NOT_FOUND,
  WHIRLPOOL_ERROR__TOKEN_MAX_EXCEEDED: () => WHIRLPOOL_ERROR__TOKEN_MAX_EXCEEDED,
  WHIRLPOOL_ERROR__TOKEN_MIN_SUBCEEDED: () => WHIRLPOOL_ERROR__TOKEN_MIN_SUBCEEDED,
  WHIRLPOOL_ERROR__TOO_MANY_SUPPLEMENTAL_TICK_ARRAYS: () => WHIRLPOOL_ERROR__TOO_MANY_SUPPLEMENTAL_TICK_ARRAYS,
  WHIRLPOOL_ERROR__TRANSFER_FEE_CALCULATION_ERROR: () => WHIRLPOOL_ERROR__TRANSFER_FEE_CALCULATION_ERROR,
  WHIRLPOOL_ERROR__UNSUPPORTED_TOKEN_MINT: () => WHIRLPOOL_ERROR__UNSUPPORTED_TOKEN_MINT,
  WHIRLPOOL_ERROR__ZERO_TRADABLE_AMOUNT: () => WHIRLPOOL_ERROR__ZERO_TRADABLE_AMOUNT,
  WHIRLPOOL_PROGRAM_ADDRESS: () => WHIRLPOOL_PROGRAM_ADDRESS,
  WhirlpoolAccount: () => WhirlpoolAccount,
  WhirlpoolInstruction: () => WhirlpoolInstruction,
  decodeFeeTier: () => decodeFeeTier,
  decodePosition: () => decodePosition,
  decodePositionBundle: () => decodePositionBundle,
  decodeTickArray: () => decodeTickArray,
  decodeTokenBadge: () => decodeTokenBadge,
  decodeWhirlpool: () => decodeWhirlpool,
  decodeWhirlpoolsConfig: () => decodeWhirlpoolsConfig,
  decodeWhirlpoolsConfigExtension: () => decodeWhirlpoolsConfigExtension,
  feeTierFeeRateFilter: () => feeTierFeeRateFilter,
  feeTierTickSpacingFilter: () => feeTierTickSpacingFilter,
  feeTierWhirlpoolsConfigFilter: () => feeTierWhirlpoolsConfigFilter,
  fetchAllFeeTier: () => fetchAllFeeTier,
  fetchAllFeeTierWithFilter: () => fetchAllFeeTierWithFilter,
  fetchAllMaybeFeeTier: () => fetchAllMaybeFeeTier,
  fetchAllMaybePosition: () => fetchAllMaybePosition,
  fetchAllMaybePositionBundle: () => fetchAllMaybePositionBundle,
  fetchAllMaybeTickArray: () => fetchAllMaybeTickArray,
  fetchAllMaybeTokenBadge: () => fetchAllMaybeTokenBadge,
  fetchAllMaybeWhirlpool: () => fetchAllMaybeWhirlpool,
  fetchAllMaybeWhirlpoolsConfig: () => fetchAllMaybeWhirlpoolsConfig,
  fetchAllMaybeWhirlpoolsConfigExtension: () => fetchAllMaybeWhirlpoolsConfigExtension,
  fetchAllPosition: () => fetchAllPosition,
  fetchAllPositionBundle: () => fetchAllPositionBundle,
  fetchAllPositionBundleWithFilter: () => fetchAllPositionBundleWithFilter,
  fetchAllPositionWithFilter: () => fetchAllPositionWithFilter,
  fetchAllTickArray: () => fetchAllTickArray,
  fetchAllTickArrayWithFilter: () => fetchAllTickArrayWithFilter,
  fetchAllTokenBadge: () => fetchAllTokenBadge,
  fetchAllTokenBadgeWithFilter: () => fetchAllTokenBadgeWithFilter,
  fetchAllWhirlpool: () => fetchAllWhirlpool,
  fetchAllWhirlpoolWithFilter: () => fetchAllWhirlpoolWithFilter,
  fetchAllWhirlpoolsConfig: () => fetchAllWhirlpoolsConfig,
  fetchAllWhirlpoolsConfigExtension: () => fetchAllWhirlpoolsConfigExtension,
  fetchAllWhirlpoolsConfigExtensionWithFilter: () => fetchAllWhirlpoolsConfigExtensionWithFilter,
  fetchAllWhirlpoolsConfigWithFilter: () => fetchAllWhirlpoolsConfigWithFilter,
  fetchFeeTier: () => fetchFeeTier,
  fetchMaybeFeeTier: () => fetchMaybeFeeTier,
  fetchMaybePosition: () => fetchMaybePosition,
  fetchMaybePositionBundle: () => fetchMaybePositionBundle,
  fetchMaybeTickArray: () => fetchMaybeTickArray,
  fetchMaybeTokenBadge: () => fetchMaybeTokenBadge,
  fetchMaybeWhirlpool: () => fetchMaybeWhirlpool,
  fetchMaybeWhirlpoolsConfig: () => fetchMaybeWhirlpoolsConfig,
  fetchMaybeWhirlpoolsConfigExtension: () => fetchMaybeWhirlpoolsConfigExtension,
  fetchPosition: () => fetchPosition,
  fetchPositionBundle: () => fetchPositionBundle,
  fetchTickArray: () => fetchTickArray,
  fetchTokenBadge: () => fetchTokenBadge,
  fetchWhirlpool: () => fetchWhirlpool,
  fetchWhirlpoolsConfig: () => fetchWhirlpoolsConfig,
  fetchWhirlpoolsConfigExtension: () => fetchWhirlpoolsConfigExtension,
  getAccountsTypeCodec: () => getAccountsTypeCodec,
  getAccountsTypeDecoder: () => getAccountsTypeDecoder,
  getAccountsTypeEncoder: () => getAccountsTypeEncoder,
  getBundledPositionAddress: () => getBundledPositionAddress,
  getCloseBundledPositionDiscriminatorBytes: () => getCloseBundledPositionDiscriminatorBytes,
  getCloseBundledPositionInstruction: () => getCloseBundledPositionInstruction,
  getCloseBundledPositionInstructionDataCodec: () => getCloseBundledPositionInstructionDataCodec,
  getCloseBundledPositionInstructionDataDecoder: () => getCloseBundledPositionInstructionDataDecoder,
  getCloseBundledPositionInstructionDataEncoder: () => getCloseBundledPositionInstructionDataEncoder,
  getClosePositionDiscriminatorBytes: () => getClosePositionDiscriminatorBytes,
  getClosePositionInstruction: () => getClosePositionInstruction,
  getClosePositionInstructionDataCodec: () => getClosePositionInstructionDataCodec,
  getClosePositionInstructionDataDecoder: () => getClosePositionInstructionDataDecoder,
  getClosePositionInstructionDataEncoder: () => getClosePositionInstructionDataEncoder,
  getClosePositionWithTokenExtensionsDiscriminatorBytes: () => getClosePositionWithTokenExtensionsDiscriminatorBytes,
  getClosePositionWithTokenExtensionsInstruction: () => getClosePositionWithTokenExtensionsInstruction,
  getClosePositionWithTokenExtensionsInstructionDataCodec: () => getClosePositionWithTokenExtensionsInstructionDataCodec,
  getClosePositionWithTokenExtensionsInstructionDataDecoder: () => getClosePositionWithTokenExtensionsInstructionDataDecoder,
  getClosePositionWithTokenExtensionsInstructionDataEncoder: () => getClosePositionWithTokenExtensionsInstructionDataEncoder,
  getCollectFeesDiscriminatorBytes: () => getCollectFeesDiscriminatorBytes,
  getCollectFeesInstruction: () => getCollectFeesInstruction,
  getCollectFeesInstructionDataCodec: () => getCollectFeesInstructionDataCodec,
  getCollectFeesInstructionDataDecoder: () => getCollectFeesInstructionDataDecoder,
  getCollectFeesInstructionDataEncoder: () => getCollectFeesInstructionDataEncoder,
  getCollectFeesV2DiscriminatorBytes: () => getCollectFeesV2DiscriminatorBytes,
  getCollectFeesV2Instruction: () => getCollectFeesV2Instruction,
  getCollectFeesV2InstructionDataCodec: () => getCollectFeesV2InstructionDataCodec,
  getCollectFeesV2InstructionDataDecoder: () => getCollectFeesV2InstructionDataDecoder,
  getCollectFeesV2InstructionDataEncoder: () => getCollectFeesV2InstructionDataEncoder,
  getCollectProtocolFeesDiscriminatorBytes: () => getCollectProtocolFeesDiscriminatorBytes,
  getCollectProtocolFeesInstruction: () => getCollectProtocolFeesInstruction,
  getCollectProtocolFeesInstructionDataCodec: () => getCollectProtocolFeesInstructionDataCodec,
  getCollectProtocolFeesInstructionDataDecoder: () => getCollectProtocolFeesInstructionDataDecoder,
  getCollectProtocolFeesInstructionDataEncoder: () => getCollectProtocolFeesInstructionDataEncoder,
  getCollectProtocolFeesV2DiscriminatorBytes: () => getCollectProtocolFeesV2DiscriminatorBytes,
  getCollectProtocolFeesV2Instruction: () => getCollectProtocolFeesV2Instruction,
  getCollectProtocolFeesV2InstructionDataCodec: () => getCollectProtocolFeesV2InstructionDataCodec,
  getCollectProtocolFeesV2InstructionDataDecoder: () => getCollectProtocolFeesV2InstructionDataDecoder,
  getCollectProtocolFeesV2InstructionDataEncoder: () => getCollectProtocolFeesV2InstructionDataEncoder,
  getCollectRewardDiscriminatorBytes: () => getCollectRewardDiscriminatorBytes,
  getCollectRewardInstruction: () => getCollectRewardInstruction,
  getCollectRewardInstructionDataCodec: () => getCollectRewardInstructionDataCodec,
  getCollectRewardInstructionDataDecoder: () => getCollectRewardInstructionDataDecoder,
  getCollectRewardInstructionDataEncoder: () => getCollectRewardInstructionDataEncoder,
  getCollectRewardV2DiscriminatorBytes: () => getCollectRewardV2DiscriminatorBytes,
  getCollectRewardV2Instruction: () => getCollectRewardV2Instruction,
  getCollectRewardV2InstructionDataCodec: () => getCollectRewardV2InstructionDataCodec,
  getCollectRewardV2InstructionDataDecoder: () => getCollectRewardV2InstructionDataDecoder,
  getCollectRewardV2InstructionDataEncoder: () => getCollectRewardV2InstructionDataEncoder,
  getDecreaseLiquidityDiscriminatorBytes: () => getDecreaseLiquidityDiscriminatorBytes,
  getDecreaseLiquidityInstruction: () => getDecreaseLiquidityInstruction,
  getDecreaseLiquidityInstructionDataCodec: () => getDecreaseLiquidityInstructionDataCodec,
  getDecreaseLiquidityInstructionDataDecoder: () => getDecreaseLiquidityInstructionDataDecoder,
  getDecreaseLiquidityInstructionDataEncoder: () => getDecreaseLiquidityInstructionDataEncoder,
  getDecreaseLiquidityV2DiscriminatorBytes: () => getDecreaseLiquidityV2DiscriminatorBytes,
  getDecreaseLiquidityV2Instruction: () => getDecreaseLiquidityV2Instruction,
  getDecreaseLiquidityV2InstructionDataCodec: () => getDecreaseLiquidityV2InstructionDataCodec,
  getDecreaseLiquidityV2InstructionDataDecoder: () => getDecreaseLiquidityV2InstructionDataDecoder,
  getDecreaseLiquidityV2InstructionDataEncoder: () => getDecreaseLiquidityV2InstructionDataEncoder,
  getDeletePositionBundleDiscriminatorBytes: () => getDeletePositionBundleDiscriminatorBytes,
  getDeletePositionBundleInstruction: () => getDeletePositionBundleInstruction,
  getDeletePositionBundleInstructionDataCodec: () => getDeletePositionBundleInstructionDataCodec,
  getDeletePositionBundleInstructionDataDecoder: () => getDeletePositionBundleInstructionDataDecoder,
  getDeletePositionBundleInstructionDataEncoder: () => getDeletePositionBundleInstructionDataEncoder,
  getDeleteTokenBadgeDiscriminatorBytes: () => getDeleteTokenBadgeDiscriminatorBytes,
  getDeleteTokenBadgeInstruction: () => getDeleteTokenBadgeInstruction,
  getDeleteTokenBadgeInstructionDataCodec: () => getDeleteTokenBadgeInstructionDataCodec,
  getDeleteTokenBadgeInstructionDataDecoder: () => getDeleteTokenBadgeInstructionDataDecoder,
  getDeleteTokenBadgeInstructionDataEncoder: () => getDeleteTokenBadgeInstructionDataEncoder,
  getFeeTierAddress: () => getFeeTierAddress,
  getFeeTierCodec: () => getFeeTierCodec,
  getFeeTierDecoder: () => getFeeTierDecoder,
  getFeeTierDiscriminatorBytes: () => getFeeTierDiscriminatorBytes,
  getFeeTierEncoder: () => getFeeTierEncoder,
  getFeeTierSize: () => getFeeTierSize,
  getIncreaseLiquidityDiscriminatorBytes: () => getIncreaseLiquidityDiscriminatorBytes,
  getIncreaseLiquidityInstruction: () => getIncreaseLiquidityInstruction,
  getIncreaseLiquidityInstructionDataCodec: () => getIncreaseLiquidityInstructionDataCodec,
  getIncreaseLiquidityInstructionDataDecoder: () => getIncreaseLiquidityInstructionDataDecoder,
  getIncreaseLiquidityInstructionDataEncoder: () => getIncreaseLiquidityInstructionDataEncoder,
  getIncreaseLiquidityV2DiscriminatorBytes: () => getIncreaseLiquidityV2DiscriminatorBytes,
  getIncreaseLiquidityV2Instruction: () => getIncreaseLiquidityV2Instruction,
  getIncreaseLiquidityV2InstructionDataCodec: () => getIncreaseLiquidityV2InstructionDataCodec,
  getIncreaseLiquidityV2InstructionDataDecoder: () => getIncreaseLiquidityV2InstructionDataDecoder,
  getIncreaseLiquidityV2InstructionDataEncoder: () => getIncreaseLiquidityV2InstructionDataEncoder,
  getInitializeConfigDiscriminatorBytes: () => getInitializeConfigDiscriminatorBytes,
  getInitializeConfigExtensionDiscriminatorBytes: () => getInitializeConfigExtensionDiscriminatorBytes,
  getInitializeConfigExtensionInstruction: () => getInitializeConfigExtensionInstruction,
  getInitializeConfigExtensionInstructionDataCodec: () => getInitializeConfigExtensionInstructionDataCodec,
  getInitializeConfigExtensionInstructionDataDecoder: () => getInitializeConfigExtensionInstructionDataDecoder,
  getInitializeConfigExtensionInstructionDataEncoder: () => getInitializeConfigExtensionInstructionDataEncoder,
  getInitializeConfigInstruction: () => getInitializeConfigInstruction,
  getInitializeConfigInstructionDataCodec: () => getInitializeConfigInstructionDataCodec,
  getInitializeConfigInstructionDataDecoder: () => getInitializeConfigInstructionDataDecoder,
  getInitializeConfigInstructionDataEncoder: () => getInitializeConfigInstructionDataEncoder,
  getInitializeFeeTierDiscriminatorBytes: () => getInitializeFeeTierDiscriminatorBytes,
  getInitializeFeeTierInstruction: () => getInitializeFeeTierInstruction,
  getInitializeFeeTierInstructionDataCodec: () => getInitializeFeeTierInstructionDataCodec,
  getInitializeFeeTierInstructionDataDecoder: () => getInitializeFeeTierInstructionDataDecoder,
  getInitializeFeeTierInstructionDataEncoder: () => getInitializeFeeTierInstructionDataEncoder,
  getInitializePoolDiscriminatorBytes: () => getInitializePoolDiscriminatorBytes,
  getInitializePoolInstruction: () => getInitializePoolInstruction,
  getInitializePoolInstructionDataCodec: () => getInitializePoolInstructionDataCodec,
  getInitializePoolInstructionDataDecoder: () => getInitializePoolInstructionDataDecoder,
  getInitializePoolInstructionDataEncoder: () => getInitializePoolInstructionDataEncoder,
  getInitializePoolV2DiscriminatorBytes: () => getInitializePoolV2DiscriminatorBytes,
  getInitializePoolV2Instruction: () => getInitializePoolV2Instruction,
  getInitializePoolV2InstructionDataCodec: () => getInitializePoolV2InstructionDataCodec,
  getInitializePoolV2InstructionDataDecoder: () => getInitializePoolV2InstructionDataDecoder,
  getInitializePoolV2InstructionDataEncoder: () => getInitializePoolV2InstructionDataEncoder,
  getInitializePositionBundleDiscriminatorBytes: () => getInitializePositionBundleDiscriminatorBytes,
  getInitializePositionBundleInstruction: () => getInitializePositionBundleInstruction,
  getInitializePositionBundleInstructionDataCodec: () => getInitializePositionBundleInstructionDataCodec,
  getInitializePositionBundleInstructionDataDecoder: () => getInitializePositionBundleInstructionDataDecoder,
  getInitializePositionBundleInstructionDataEncoder: () => getInitializePositionBundleInstructionDataEncoder,
  getInitializePositionBundleWithMetadataDiscriminatorBytes: () => getInitializePositionBundleWithMetadataDiscriminatorBytes,
  getInitializePositionBundleWithMetadataInstruction: () => getInitializePositionBundleWithMetadataInstruction,
  getInitializePositionBundleWithMetadataInstructionDataCodec: () => getInitializePositionBundleWithMetadataInstructionDataCodec,
  getInitializePositionBundleWithMetadataInstructionDataDecoder: () => getInitializePositionBundleWithMetadataInstructionDataDecoder,
  getInitializePositionBundleWithMetadataInstructionDataEncoder: () => getInitializePositionBundleWithMetadataInstructionDataEncoder,
  getInitializeRewardDiscriminatorBytes: () => getInitializeRewardDiscriminatorBytes,
  getInitializeRewardInstruction: () => getInitializeRewardInstruction,
  getInitializeRewardInstructionDataCodec: () => getInitializeRewardInstructionDataCodec,
  getInitializeRewardInstructionDataDecoder: () => getInitializeRewardInstructionDataDecoder,
  getInitializeRewardInstructionDataEncoder: () => getInitializeRewardInstructionDataEncoder,
  getInitializeRewardV2DiscriminatorBytes: () => getInitializeRewardV2DiscriminatorBytes,
  getInitializeRewardV2Instruction: () => getInitializeRewardV2Instruction,
  getInitializeRewardV2InstructionDataCodec: () => getInitializeRewardV2InstructionDataCodec,
  getInitializeRewardV2InstructionDataDecoder: () => getInitializeRewardV2InstructionDataDecoder,
  getInitializeRewardV2InstructionDataEncoder: () => getInitializeRewardV2InstructionDataEncoder,
  getInitializeTickArrayDiscriminatorBytes: () => getInitializeTickArrayDiscriminatorBytes,
  getInitializeTickArrayInstruction: () => getInitializeTickArrayInstruction,
  getInitializeTickArrayInstructionDataCodec: () => getInitializeTickArrayInstructionDataCodec,
  getInitializeTickArrayInstructionDataDecoder: () => getInitializeTickArrayInstructionDataDecoder,
  getInitializeTickArrayInstructionDataEncoder: () => getInitializeTickArrayInstructionDataEncoder,
  getInitializeTokenBadgeDiscriminatorBytes: () => getInitializeTokenBadgeDiscriminatorBytes,
  getInitializeTokenBadgeInstruction: () => getInitializeTokenBadgeInstruction,
  getInitializeTokenBadgeInstructionDataCodec: () => getInitializeTokenBadgeInstructionDataCodec,
  getInitializeTokenBadgeInstructionDataDecoder: () => getInitializeTokenBadgeInstructionDataDecoder,
  getInitializeTokenBadgeInstructionDataEncoder: () => getInitializeTokenBadgeInstructionDataEncoder,
  getOpenBundledPositionDiscriminatorBytes: () => getOpenBundledPositionDiscriminatorBytes,
  getOpenBundledPositionInstruction: () => getOpenBundledPositionInstruction,
  getOpenBundledPositionInstructionDataCodec: () => getOpenBundledPositionInstructionDataCodec,
  getOpenBundledPositionInstructionDataDecoder: () => getOpenBundledPositionInstructionDataDecoder,
  getOpenBundledPositionInstructionDataEncoder: () => getOpenBundledPositionInstructionDataEncoder,
  getOpenPositionDiscriminatorBytes: () => getOpenPositionDiscriminatorBytes,
  getOpenPositionInstruction: () => getOpenPositionInstruction,
  getOpenPositionInstructionDataCodec: () => getOpenPositionInstructionDataCodec,
  getOpenPositionInstructionDataDecoder: () => getOpenPositionInstructionDataDecoder,
  getOpenPositionInstructionDataEncoder: () => getOpenPositionInstructionDataEncoder,
  getOpenPositionWithMetadataDiscriminatorBytes: () => getOpenPositionWithMetadataDiscriminatorBytes,
  getOpenPositionWithMetadataInstruction: () => getOpenPositionWithMetadataInstruction,
  getOpenPositionWithMetadataInstructionDataCodec: () => getOpenPositionWithMetadataInstructionDataCodec,
  getOpenPositionWithMetadataInstructionDataDecoder: () => getOpenPositionWithMetadataInstructionDataDecoder,
  getOpenPositionWithMetadataInstructionDataEncoder: () => getOpenPositionWithMetadataInstructionDataEncoder,
  getOpenPositionWithTokenExtensionsDiscriminatorBytes: () => getOpenPositionWithTokenExtensionsDiscriminatorBytes,
  getOpenPositionWithTokenExtensionsInstruction: () => getOpenPositionWithTokenExtensionsInstruction,
  getOpenPositionWithTokenExtensionsInstructionDataCodec: () => getOpenPositionWithTokenExtensionsInstructionDataCodec,
  getOpenPositionWithTokenExtensionsInstructionDataDecoder: () => getOpenPositionWithTokenExtensionsInstructionDataDecoder,
  getOpenPositionWithTokenExtensionsInstructionDataEncoder: () => getOpenPositionWithTokenExtensionsInstructionDataEncoder,
  getOracleAddress: () => getOracleAddress,
  getPositionAddress: () => getPositionAddress,
  getPositionBundleAddress: () => getPositionBundleAddress,
  getPositionBundleCodec: () => getPositionBundleCodec,
  getPositionBundleDecoder: () => getPositionBundleDecoder,
  getPositionBundleDiscriminatorBytes: () => getPositionBundleDiscriminatorBytes,
  getPositionBundleEncoder: () => getPositionBundleEncoder,
  getPositionBundleSize: () => getPositionBundleSize,
  getPositionCodec: () => getPositionCodec,
  getPositionDecoder: () => getPositionDecoder,
  getPositionDiscriminatorBytes: () => getPositionDiscriminatorBytes,
  getPositionEncoder: () => getPositionEncoder,
  getPositionRewardInfoCodec: () => getPositionRewardInfoCodec,
  getPositionRewardInfoDecoder: () => getPositionRewardInfoDecoder,
  getPositionRewardInfoEncoder: () => getPositionRewardInfoEncoder,
  getPositionSize: () => getPositionSize,
  getRemainingAccountsInfoCodec: () => getRemainingAccountsInfoCodec,
  getRemainingAccountsInfoDecoder: () => getRemainingAccountsInfoDecoder,
  getRemainingAccountsInfoEncoder: () => getRemainingAccountsInfoEncoder,
  getRemainingAccountsSliceCodec: () => getRemainingAccountsSliceCodec,
  getRemainingAccountsSliceDecoder: () => getRemainingAccountsSliceDecoder,
  getRemainingAccountsSliceEncoder: () => getRemainingAccountsSliceEncoder,
  getSetCollectProtocolFeesAuthorityDiscriminatorBytes: () => getSetCollectProtocolFeesAuthorityDiscriminatorBytes,
  getSetCollectProtocolFeesAuthorityInstruction: () => getSetCollectProtocolFeesAuthorityInstruction,
  getSetCollectProtocolFeesAuthorityInstructionDataCodec: () => getSetCollectProtocolFeesAuthorityInstructionDataCodec,
  getSetCollectProtocolFeesAuthorityInstructionDataDecoder: () => getSetCollectProtocolFeesAuthorityInstructionDataDecoder,
  getSetCollectProtocolFeesAuthorityInstructionDataEncoder: () => getSetCollectProtocolFeesAuthorityInstructionDataEncoder,
  getSetConfigExtensionAuthorityDiscriminatorBytes: () => getSetConfigExtensionAuthorityDiscriminatorBytes,
  getSetConfigExtensionAuthorityInstruction: () => getSetConfigExtensionAuthorityInstruction,
  getSetConfigExtensionAuthorityInstructionDataCodec: () => getSetConfigExtensionAuthorityInstructionDataCodec,
  getSetConfigExtensionAuthorityInstructionDataDecoder: () => getSetConfigExtensionAuthorityInstructionDataDecoder,
  getSetConfigExtensionAuthorityInstructionDataEncoder: () => getSetConfigExtensionAuthorityInstructionDataEncoder,
  getSetDefaultFeeRateDiscriminatorBytes: () => getSetDefaultFeeRateDiscriminatorBytes,
  getSetDefaultFeeRateInstruction: () => getSetDefaultFeeRateInstruction,
  getSetDefaultFeeRateInstructionDataCodec: () => getSetDefaultFeeRateInstructionDataCodec,
  getSetDefaultFeeRateInstructionDataDecoder: () => getSetDefaultFeeRateInstructionDataDecoder,
  getSetDefaultFeeRateInstructionDataEncoder: () => getSetDefaultFeeRateInstructionDataEncoder,
  getSetDefaultProtocolFeeRateDiscriminatorBytes: () => getSetDefaultProtocolFeeRateDiscriminatorBytes,
  getSetDefaultProtocolFeeRateInstruction: () => getSetDefaultProtocolFeeRateInstruction,
  getSetDefaultProtocolFeeRateInstructionDataCodec: () => getSetDefaultProtocolFeeRateInstructionDataCodec,
  getSetDefaultProtocolFeeRateInstructionDataDecoder: () => getSetDefaultProtocolFeeRateInstructionDataDecoder,
  getSetDefaultProtocolFeeRateInstructionDataEncoder: () => getSetDefaultProtocolFeeRateInstructionDataEncoder,
  getSetFeeAuthorityDiscriminatorBytes: () => getSetFeeAuthorityDiscriminatorBytes,
  getSetFeeAuthorityInstruction: () => getSetFeeAuthorityInstruction,
  getSetFeeAuthorityInstructionDataCodec: () => getSetFeeAuthorityInstructionDataCodec,
  getSetFeeAuthorityInstructionDataDecoder: () => getSetFeeAuthorityInstructionDataDecoder,
  getSetFeeAuthorityInstructionDataEncoder: () => getSetFeeAuthorityInstructionDataEncoder,
  getSetFeeRateDiscriminatorBytes: () => getSetFeeRateDiscriminatorBytes,
  getSetFeeRateInstruction: () => getSetFeeRateInstruction,
  getSetFeeRateInstructionDataCodec: () => getSetFeeRateInstructionDataCodec,
  getSetFeeRateInstructionDataDecoder: () => getSetFeeRateInstructionDataDecoder,
  getSetFeeRateInstructionDataEncoder: () => getSetFeeRateInstructionDataEncoder,
  getSetProtocolFeeRateDiscriminatorBytes: () => getSetProtocolFeeRateDiscriminatorBytes,
  getSetProtocolFeeRateInstruction: () => getSetProtocolFeeRateInstruction,
  getSetProtocolFeeRateInstructionDataCodec: () => getSetProtocolFeeRateInstructionDataCodec,
  getSetProtocolFeeRateInstructionDataDecoder: () => getSetProtocolFeeRateInstructionDataDecoder,
  getSetProtocolFeeRateInstructionDataEncoder: () => getSetProtocolFeeRateInstructionDataEncoder,
  getSetRewardAuthorityBySuperAuthorityDiscriminatorBytes: () => getSetRewardAuthorityBySuperAuthorityDiscriminatorBytes,
  getSetRewardAuthorityBySuperAuthorityInstruction: () => getSetRewardAuthorityBySuperAuthorityInstruction,
  getSetRewardAuthorityBySuperAuthorityInstructionDataCodec: () => getSetRewardAuthorityBySuperAuthorityInstructionDataCodec,
  getSetRewardAuthorityBySuperAuthorityInstructionDataDecoder: () => getSetRewardAuthorityBySuperAuthorityInstructionDataDecoder,
  getSetRewardAuthorityBySuperAuthorityInstructionDataEncoder: () => getSetRewardAuthorityBySuperAuthorityInstructionDataEncoder,
  getSetRewardAuthorityDiscriminatorBytes: () => getSetRewardAuthorityDiscriminatorBytes,
  getSetRewardAuthorityInstruction: () => getSetRewardAuthorityInstruction,
  getSetRewardAuthorityInstructionDataCodec: () => getSetRewardAuthorityInstructionDataCodec,
  getSetRewardAuthorityInstructionDataDecoder: () => getSetRewardAuthorityInstructionDataDecoder,
  getSetRewardAuthorityInstructionDataEncoder: () => getSetRewardAuthorityInstructionDataEncoder,
  getSetRewardEmissionsDiscriminatorBytes: () => getSetRewardEmissionsDiscriminatorBytes,
  getSetRewardEmissionsInstruction: () => getSetRewardEmissionsInstruction,
  getSetRewardEmissionsInstructionDataCodec: () => getSetRewardEmissionsInstructionDataCodec,
  getSetRewardEmissionsInstructionDataDecoder: () => getSetRewardEmissionsInstructionDataDecoder,
  getSetRewardEmissionsInstructionDataEncoder: () => getSetRewardEmissionsInstructionDataEncoder,
  getSetRewardEmissionsSuperAuthorityDiscriminatorBytes: () => getSetRewardEmissionsSuperAuthorityDiscriminatorBytes,
  getSetRewardEmissionsSuperAuthorityInstruction: () => getSetRewardEmissionsSuperAuthorityInstruction,
  getSetRewardEmissionsSuperAuthorityInstructionDataCodec: () => getSetRewardEmissionsSuperAuthorityInstructionDataCodec,
  getSetRewardEmissionsSuperAuthorityInstructionDataDecoder: () => getSetRewardEmissionsSuperAuthorityInstructionDataDecoder,
  getSetRewardEmissionsSuperAuthorityInstructionDataEncoder: () => getSetRewardEmissionsSuperAuthorityInstructionDataEncoder,
  getSetRewardEmissionsV2DiscriminatorBytes: () => getSetRewardEmissionsV2DiscriminatorBytes,
  getSetRewardEmissionsV2Instruction: () => getSetRewardEmissionsV2Instruction,
  getSetRewardEmissionsV2InstructionDataCodec: () => getSetRewardEmissionsV2InstructionDataCodec,
  getSetRewardEmissionsV2InstructionDataDecoder: () => getSetRewardEmissionsV2InstructionDataDecoder,
  getSetRewardEmissionsV2InstructionDataEncoder: () => getSetRewardEmissionsV2InstructionDataEncoder,
  getSetTokenBadgeAuthorityDiscriminatorBytes: () => getSetTokenBadgeAuthorityDiscriminatorBytes,
  getSetTokenBadgeAuthorityInstruction: () => getSetTokenBadgeAuthorityInstruction,
  getSetTokenBadgeAuthorityInstructionDataCodec: () => getSetTokenBadgeAuthorityInstructionDataCodec,
  getSetTokenBadgeAuthorityInstructionDataDecoder: () => getSetTokenBadgeAuthorityInstructionDataDecoder,
  getSetTokenBadgeAuthorityInstructionDataEncoder: () => getSetTokenBadgeAuthorityInstructionDataEncoder,
  getSwapDiscriminatorBytes: () => getSwapDiscriminatorBytes,
  getSwapInstruction: () => getSwapInstruction,
  getSwapInstructionDataCodec: () => getSwapInstructionDataCodec,
  getSwapInstructionDataDecoder: () => getSwapInstructionDataDecoder,
  getSwapInstructionDataEncoder: () => getSwapInstructionDataEncoder,
  getSwapV2DiscriminatorBytes: () => getSwapV2DiscriminatorBytes,
  getSwapV2Instruction: () => getSwapV2Instruction,
  getSwapV2InstructionDataCodec: () => getSwapV2InstructionDataCodec,
  getSwapV2InstructionDataDecoder: () => getSwapV2InstructionDataDecoder,
  getSwapV2InstructionDataEncoder: () => getSwapV2InstructionDataEncoder,
  getTickArrayAddress: () => getTickArrayAddress,
  getTickArrayCodec: () => getTickArrayCodec,
  getTickArrayDecoder: () => getTickArrayDecoder,
  getTickArrayDiscriminatorBytes: () => getTickArrayDiscriminatorBytes,
  getTickArrayEncoder: () => getTickArrayEncoder,
  getTickArraySize: () => getTickArraySize,
  getTickCodec: () => getTickCodec,
  getTickDecoder: () => getTickDecoder,
  getTickEncoder: () => getTickEncoder,
  getTokenBadgeAddress: () => getTokenBadgeAddress,
  getTokenBadgeCodec: () => getTokenBadgeCodec,
  getTokenBadgeDecoder: () => getTokenBadgeDecoder,
  getTokenBadgeDiscriminatorBytes: () => getTokenBadgeDiscriminatorBytes,
  getTokenBadgeEncoder: () => getTokenBadgeEncoder,
  getTokenBadgeSize: () => getTokenBadgeSize,
  getTwoHopSwapDiscriminatorBytes: () => getTwoHopSwapDiscriminatorBytes,
  getTwoHopSwapInstruction: () => getTwoHopSwapInstruction,
  getTwoHopSwapInstructionDataCodec: () => getTwoHopSwapInstructionDataCodec,
  getTwoHopSwapInstructionDataDecoder: () => getTwoHopSwapInstructionDataDecoder,
  getTwoHopSwapInstructionDataEncoder: () => getTwoHopSwapInstructionDataEncoder,
  getTwoHopSwapV2DiscriminatorBytes: () => getTwoHopSwapV2DiscriminatorBytes,
  getTwoHopSwapV2Instruction: () => getTwoHopSwapV2Instruction,
  getTwoHopSwapV2InstructionDataCodec: () => getTwoHopSwapV2InstructionDataCodec,
  getTwoHopSwapV2InstructionDataDecoder: () => getTwoHopSwapV2InstructionDataDecoder,
  getTwoHopSwapV2InstructionDataEncoder: () => getTwoHopSwapV2InstructionDataEncoder,
  getUpdateFeesAndRewardsDiscriminatorBytes: () => getUpdateFeesAndRewardsDiscriminatorBytes,
  getUpdateFeesAndRewardsInstruction: () => getUpdateFeesAndRewardsInstruction,
  getUpdateFeesAndRewardsInstructionDataCodec: () => getUpdateFeesAndRewardsInstructionDataCodec,
  getUpdateFeesAndRewardsInstructionDataDecoder: () => getUpdateFeesAndRewardsInstructionDataDecoder,
  getUpdateFeesAndRewardsInstructionDataEncoder: () => getUpdateFeesAndRewardsInstructionDataEncoder,
  getWhirlpoolAddress: () => getWhirlpoolAddress,
  getWhirlpoolCodec: () => getWhirlpoolCodec,
  getWhirlpoolDecoder: () => getWhirlpoolDecoder,
  getWhirlpoolDiscriminatorBytes: () => getWhirlpoolDiscriminatorBytes,
  getWhirlpoolEncoder: () => getWhirlpoolEncoder,
  getWhirlpoolErrorMessage: () => getWhirlpoolErrorMessage,
  getWhirlpoolRewardInfoCodec: () => getWhirlpoolRewardInfoCodec,
  getWhirlpoolRewardInfoDecoder: () => getWhirlpoolRewardInfoDecoder,
  getWhirlpoolRewardInfoEncoder: () => getWhirlpoolRewardInfoEncoder,
  getWhirlpoolSize: () => getWhirlpoolSize,
  getWhirlpoolsConfigCodec: () => getWhirlpoolsConfigCodec,
  getWhirlpoolsConfigDecoder: () => getWhirlpoolsConfigDecoder,
  getWhirlpoolsConfigDiscriminatorBytes: () => getWhirlpoolsConfigDiscriminatorBytes,
  getWhirlpoolsConfigEncoder: () => getWhirlpoolsConfigEncoder,
  getWhirlpoolsConfigExtensionAddress: () => getWhirlpoolsConfigExtensionAddress,
  getWhirlpoolsConfigExtensionCodec: () => getWhirlpoolsConfigExtensionCodec,
  getWhirlpoolsConfigExtensionDecoder: () => getWhirlpoolsConfigExtensionDecoder,
  getWhirlpoolsConfigExtensionDiscriminatorBytes: () => getWhirlpoolsConfigExtensionDiscriminatorBytes,
  getWhirlpoolsConfigExtensionEncoder: () => getWhirlpoolsConfigExtensionEncoder,
  getWhirlpoolsConfigExtensionSize: () => getWhirlpoolsConfigExtensionSize,
  getWhirlpoolsConfigSize: () => getWhirlpoolsConfigSize,
  identifyWhirlpoolAccount: () => identifyWhirlpoolAccount,
  identifyWhirlpoolInstruction: () => identifyWhirlpoolInstruction,
  isWhirlpoolError: () => isWhirlpoolError,
  parseCloseBundledPositionInstruction: () => parseCloseBundledPositionInstruction,
  parseClosePositionInstruction: () => parseClosePositionInstruction,
  parseClosePositionWithTokenExtensionsInstruction: () => parseClosePositionWithTokenExtensionsInstruction,
  parseCollectFeesInstruction: () => parseCollectFeesInstruction,
  parseCollectFeesV2Instruction: () => parseCollectFeesV2Instruction,
  parseCollectProtocolFeesInstruction: () => parseCollectProtocolFeesInstruction,
  parseCollectProtocolFeesV2Instruction: () => parseCollectProtocolFeesV2Instruction,
  parseCollectRewardInstruction: () => parseCollectRewardInstruction,
  parseCollectRewardV2Instruction: () => parseCollectRewardV2Instruction,
  parseDecreaseLiquidityInstruction: () => parseDecreaseLiquidityInstruction,
  parseDecreaseLiquidityV2Instruction: () => parseDecreaseLiquidityV2Instruction,
  parseDeletePositionBundleInstruction: () => parseDeletePositionBundleInstruction,
  parseDeleteTokenBadgeInstruction: () => parseDeleteTokenBadgeInstruction,
  parseIncreaseLiquidityInstruction: () => parseIncreaseLiquidityInstruction,
  parseIncreaseLiquidityV2Instruction: () => parseIncreaseLiquidityV2Instruction,
  parseInitializeConfigExtensionInstruction: () => parseInitializeConfigExtensionInstruction,
  parseInitializeConfigInstruction: () => parseInitializeConfigInstruction,
  parseInitializeFeeTierInstruction: () => parseInitializeFeeTierInstruction,
  parseInitializePoolInstruction: () => parseInitializePoolInstruction,
  parseInitializePoolV2Instruction: () => parseInitializePoolV2Instruction,
  parseInitializePositionBundleInstruction: () => parseInitializePositionBundleInstruction,
  parseInitializePositionBundleWithMetadataInstruction: () => parseInitializePositionBundleWithMetadataInstruction,
  parseInitializeRewardInstruction: () => parseInitializeRewardInstruction,
  parseInitializeRewardV2Instruction: () => parseInitializeRewardV2Instruction,
  parseInitializeTickArrayInstruction: () => parseInitializeTickArrayInstruction,
  parseInitializeTokenBadgeInstruction: () => parseInitializeTokenBadgeInstruction,
  parseOpenBundledPositionInstruction: () => parseOpenBundledPositionInstruction,
  parseOpenPositionInstruction: () => parseOpenPositionInstruction,
  parseOpenPositionWithMetadataInstruction: () => parseOpenPositionWithMetadataInstruction,
  parseOpenPositionWithTokenExtensionsInstruction: () => parseOpenPositionWithTokenExtensionsInstruction,
  parseSetCollectProtocolFeesAuthorityInstruction: () => parseSetCollectProtocolFeesAuthorityInstruction,
  parseSetConfigExtensionAuthorityInstruction: () => parseSetConfigExtensionAuthorityInstruction,
  parseSetDefaultFeeRateInstruction: () => parseSetDefaultFeeRateInstruction,
  parseSetDefaultProtocolFeeRateInstruction: () => parseSetDefaultProtocolFeeRateInstruction,
  parseSetFeeAuthorityInstruction: () => parseSetFeeAuthorityInstruction,
  parseSetFeeRateInstruction: () => parseSetFeeRateInstruction,
  parseSetProtocolFeeRateInstruction: () => parseSetProtocolFeeRateInstruction,
  parseSetRewardAuthorityBySuperAuthorityInstruction: () => parseSetRewardAuthorityBySuperAuthorityInstruction,
  parseSetRewardAuthorityInstruction: () => parseSetRewardAuthorityInstruction,
  parseSetRewardEmissionsInstruction: () => parseSetRewardEmissionsInstruction,
  parseSetRewardEmissionsSuperAuthorityInstruction: () => parseSetRewardEmissionsSuperAuthorityInstruction,
  parseSetRewardEmissionsV2Instruction: () => parseSetRewardEmissionsV2Instruction,
  parseSetTokenBadgeAuthorityInstruction: () => parseSetTokenBadgeAuthorityInstruction,
  parseSwapInstruction: () => parseSwapInstruction,
  parseSwapV2Instruction: () => parseSwapV2Instruction,
  parseTwoHopSwapInstruction: () => parseTwoHopSwapInstruction,
  parseTwoHopSwapV2Instruction: () => parseTwoHopSwapV2Instruction,
  parseUpdateFeesAndRewardsInstruction: () => parseUpdateFeesAndRewardsInstruction,
  positionBundleMintFilter: () => positionBundleMintFilter,
  positionMintFilter: () => positionMintFilter,
  positionTickLowerIndexFilter: () => positionTickLowerIndexFilter,
  positionTickUpperIndexFilter: () => positionTickUpperIndexFilter,
  positionWhirlpoolFilter: () => positionWhirlpoolFilter,
  tickArrayStartTickIndexFilter: () => tickArrayStartTickIndexFilter,
  tickArrayWhirlpoolFilter: () => tickArrayWhirlpoolFilter,
  tokenBadgeTokenMintFilter: () => tokenBadgeTokenMintFilter,
  tokenBadgeWhirlpoolsConfigFilter: () => tokenBadgeWhirlpoolsConfigFilter,
  whirlpoolFeeRateFilter: () => whirlpoolFeeRateFilter,
  whirlpoolProtocolFeeRateFilter: () => whirlpoolProtocolFeeRateFilter,
  whirlpoolRewardMint1Filter: () => whirlpoolRewardMint1Filter,
  whirlpoolRewardMint2Filter: () => whirlpoolRewardMint2Filter,
  whirlpoolRewardMint3Filter: () => whirlpoolRewardMint3Filter,
  whirlpoolRewardVault1Filter: () => whirlpoolRewardVault1Filter,
  whirlpoolRewardVault2Filter: () => whirlpoolRewardVault2Filter,
  whirlpoolRewardVault3Filter: () => whirlpoolRewardVault3Filter,
  whirlpoolTickSpacingFilter: () => whirlpoolTickSpacingFilter,
  whirlpoolTokenMintAFilter: () => whirlpoolTokenMintAFilter,
  whirlpoolTokenMintBFilter: () => whirlpoolTokenMintBFilter,
  whirlpoolTokenVaultAFilter: () => whirlpoolTokenVaultAFilter,
  whirlpoolTokenVaultBFilter: () => whirlpoolTokenVaultBFilter,
  whirlpoolWhirlpoolConfigFilter: () => whirlpoolWhirlpoolConfigFilter,
  whirlpoolsConfigCollectProtocolFeesAuthorityFilter: () => whirlpoolsConfigCollectProtocolFeesAuthorityFilter,
  whirlpoolsConfigDefaultProtocolFeeRateFilter: () => whirlpoolsConfigDefaultProtocolFeeRateFilter,
  whirlpoolsConfigExtensionConfigExtensionAuthorityFilter: () => whirlpoolsConfigExtensionConfigExtensionAuthorityFilter,
  whirlpoolsConfigExtensionConfigTokenBadgeAuthorityFilter: () => whirlpoolsConfigExtensionConfigTokenBadgeAuthorityFilter,
  whirlpoolsConfigExtensionWhirlpoolsConfigFilter: () => whirlpoolsConfigExtensionWhirlpoolsConfigFilter,
  whirlpoolsConfigFeeAuthorityFilter: () => whirlpoolsConfigFeeAuthorityFilter,
  whirlpoolsConfigRewardEmissionsSuperAuthorityFilter: () => whirlpoolsConfigRewardEmissionsSuperAuthorityFilter
});
module.exports = __toCommonJS(src_exports);

// src/generated/accounts/feeTier.ts
var import_web3 = require("@solana/web3.js");
var FEE_TIER_DISCRIMINATOR = new Uint8Array([
  56,
  75,
  159,
  76,
  142,
  68,
  190,
  105
]);
function getFeeTierDiscriminatorBytes() {
  return (0, import_web3.fixEncoderSize)((0, import_web3.getBytesEncoder)(), 8).encode(FEE_TIER_DISCRIMINATOR);
}
function getFeeTierEncoder() {
  return (0, import_web3.transformEncoder)(
    (0, import_web3.getStructEncoder)([
      ["discriminator", (0, import_web3.fixEncoderSize)((0, import_web3.getBytesEncoder)(), 8)],
      ["whirlpoolsConfig", (0, import_web3.getAddressEncoder)()],
      ["tickSpacing", (0, import_web3.getU16Encoder)()],
      ["defaultFeeRate", (0, import_web3.getU16Encoder)()]
    ]),
    (value) => ({ ...value, discriminator: FEE_TIER_DISCRIMINATOR })
  );
}
function getFeeTierDecoder() {
  return (0, import_web3.getStructDecoder)([
    ["discriminator", (0, import_web3.fixDecoderSize)((0, import_web3.getBytesDecoder)(), 8)],
    ["whirlpoolsConfig", (0, import_web3.getAddressDecoder)()],
    ["tickSpacing", (0, import_web3.getU16Decoder)()],
    ["defaultFeeRate", (0, import_web3.getU16Decoder)()]
  ]);
}
function getFeeTierCodec() {
  return (0, import_web3.combineCodec)(getFeeTierEncoder(), getFeeTierDecoder());
}
function decodeFeeTier(encodedAccount) {
  return (0, import_web3.decodeAccount)(
    encodedAccount,
    getFeeTierDecoder()
  );
}
async function fetchFeeTier(rpc, address, config) {
  const maybeAccount = await fetchMaybeFeeTier(rpc, address, config);
  (0, import_web3.assertAccountExists)(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeFeeTier(rpc, address, config) {
  const maybeAccount = await (0, import_web3.fetchEncodedAccount)(rpc, address, config);
  return decodeFeeTier(maybeAccount);
}
async function fetchAllFeeTier(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeFeeTier(rpc, addresses, config);
  (0, import_web3.assertAccountsExist)(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeFeeTier(rpc, addresses, config) {
  const maybeAccounts = await (0, import_web3.fetchEncodedAccounts)(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeFeeTier(maybeAccount));
}
function getFeeTierSize() {
  return 44;
}

// src/generated/accounts/position.ts
var import_web38 = require("@solana/web3.js");

// src/generated/types/accountsType.ts
var import_web32 = require("@solana/web3.js");
var AccountsType = /* @__PURE__ */ ((AccountsType2) => {
  AccountsType2[AccountsType2["TransferHookA"] = 0] = "TransferHookA";
  AccountsType2[AccountsType2["TransferHookB"] = 1] = "TransferHookB";
  AccountsType2[AccountsType2["TransferHookReward"] = 2] = "TransferHookReward";
  AccountsType2[AccountsType2["TransferHookInput"] = 3] = "TransferHookInput";
  AccountsType2[AccountsType2["TransferHookIntermediate"] = 4] = "TransferHookIntermediate";
  AccountsType2[AccountsType2["TransferHookOutput"] = 5] = "TransferHookOutput";
  AccountsType2[AccountsType2["SupplementalTickArrays"] = 6] = "SupplementalTickArrays";
  AccountsType2[AccountsType2["SupplementalTickArraysOne"] = 7] = "SupplementalTickArraysOne";
  AccountsType2[AccountsType2["SupplementalTickArraysTwo"] = 8] = "SupplementalTickArraysTwo";
  return AccountsType2;
})(AccountsType || {});
function getAccountsTypeEncoder() {
  return (0, import_web32.getEnumEncoder)(AccountsType);
}
function getAccountsTypeDecoder() {
  return (0, import_web32.getEnumDecoder)(AccountsType);
}
function getAccountsTypeCodec() {
  return (0, import_web32.combineCodec)(getAccountsTypeEncoder(), getAccountsTypeDecoder());
}

// src/generated/types/positionRewardInfo.ts
var import_web33 = require("@solana/web3.js");
function getPositionRewardInfoEncoder() {
  return (0, import_web33.getStructEncoder)([
    ["growthInsideCheckpoint", (0, import_web33.getU128Encoder)()],
    ["amountOwed", (0, import_web33.getU64Encoder)()]
  ]);
}
function getPositionRewardInfoDecoder() {
  return (0, import_web33.getStructDecoder)([
    ["growthInsideCheckpoint", (0, import_web33.getU128Decoder)()],
    ["amountOwed", (0, import_web33.getU64Decoder)()]
  ]);
}
function getPositionRewardInfoCodec() {
  return (0, import_web33.combineCodec)(
    getPositionRewardInfoEncoder(),
    getPositionRewardInfoDecoder()
  );
}

// src/generated/types/remainingAccountsInfo.ts
var import_web34 = require("@solana/web3.js");
function getRemainingAccountsInfoEncoder() {
  return (0, import_web34.getStructEncoder)([
    ["slices", (0, import_web34.getArrayEncoder)(getRemainingAccountsSliceEncoder())]
  ]);
}
function getRemainingAccountsInfoDecoder() {
  return (0, import_web34.getStructDecoder)([
    ["slices", (0, import_web34.getArrayDecoder)(getRemainingAccountsSliceDecoder())]
  ]);
}
function getRemainingAccountsInfoCodec() {
  return (0, import_web34.combineCodec)(
    getRemainingAccountsInfoEncoder(),
    getRemainingAccountsInfoDecoder()
  );
}

// src/generated/types/remainingAccountsSlice.ts
var import_web35 = require("@solana/web3.js");
function getRemainingAccountsSliceEncoder() {
  return (0, import_web35.getStructEncoder)([
    ["accountsType", getAccountsTypeEncoder()],
    ["length", (0, import_web35.getU8Encoder)()]
  ]);
}
function getRemainingAccountsSliceDecoder() {
  return (0, import_web35.getStructDecoder)([
    ["accountsType", getAccountsTypeDecoder()],
    ["length", (0, import_web35.getU8Decoder)()]
  ]);
}
function getRemainingAccountsSliceCodec() {
  return (0, import_web35.combineCodec)(
    getRemainingAccountsSliceEncoder(),
    getRemainingAccountsSliceDecoder()
  );
}

// src/generated/types/tick.ts
var import_web36 = require("@solana/web3.js");
function getTickEncoder() {
  return (0, import_web36.getStructEncoder)([
    ["initialized", (0, import_web36.getBooleanEncoder)()],
    ["liquidityNet", (0, import_web36.getI128Encoder)()],
    ["liquidityGross", (0, import_web36.getU128Encoder)()],
    ["feeGrowthOutsideA", (0, import_web36.getU128Encoder)()],
    ["feeGrowthOutsideB", (0, import_web36.getU128Encoder)()],
    ["rewardGrowthsOutside", (0, import_web36.getArrayEncoder)((0, import_web36.getU128Encoder)(), { size: 3 })]
  ]);
}
function getTickDecoder() {
  return (0, import_web36.getStructDecoder)([
    ["initialized", (0, import_web36.getBooleanDecoder)()],
    ["liquidityNet", (0, import_web36.getI128Decoder)()],
    ["liquidityGross", (0, import_web36.getU128Decoder)()],
    ["feeGrowthOutsideA", (0, import_web36.getU128Decoder)()],
    ["feeGrowthOutsideB", (0, import_web36.getU128Decoder)()],
    ["rewardGrowthsOutside", (0, import_web36.getArrayDecoder)((0, import_web36.getU128Decoder)(), { size: 3 })]
  ]);
}
function getTickCodec() {
  return (0, import_web36.combineCodec)(getTickEncoder(), getTickDecoder());
}

// src/generated/types/whirlpoolRewardInfo.ts
var import_web37 = require("@solana/web3.js");
function getWhirlpoolRewardInfoEncoder() {
  return (0, import_web37.getStructEncoder)([
    ["mint", (0, import_web37.getAddressEncoder)()],
    ["vault", (0, import_web37.getAddressEncoder)()],
    ["authority", (0, import_web37.getAddressEncoder)()],
    ["emissionsPerSecondX64", (0, import_web37.getU128Encoder)()],
    ["growthGlobalX64", (0, import_web37.getU128Encoder)()]
  ]);
}
function getWhirlpoolRewardInfoDecoder() {
  return (0, import_web37.getStructDecoder)([
    ["mint", (0, import_web37.getAddressDecoder)()],
    ["vault", (0, import_web37.getAddressDecoder)()],
    ["authority", (0, import_web37.getAddressDecoder)()],
    ["emissionsPerSecondX64", (0, import_web37.getU128Decoder)()],
    ["growthGlobalX64", (0, import_web37.getU128Decoder)()]
  ]);
}
function getWhirlpoolRewardInfoCodec() {
  return (0, import_web37.combineCodec)(
    getWhirlpoolRewardInfoEncoder(),
    getWhirlpoolRewardInfoDecoder()
  );
}

// src/generated/accounts/position.ts
var POSITION_DISCRIMINATOR = new Uint8Array([
  170,
  188,
  143,
  228,
  122,
  64,
  247,
  208
]);
function getPositionDiscriminatorBytes() {
  return (0, import_web38.fixEncoderSize)((0, import_web38.getBytesEncoder)(), 8).encode(POSITION_DISCRIMINATOR);
}
function getPositionEncoder() {
  return (0, import_web38.transformEncoder)(
    (0, import_web38.getStructEncoder)([
      ["discriminator", (0, import_web38.fixEncoderSize)((0, import_web38.getBytesEncoder)(), 8)],
      ["whirlpool", (0, import_web38.getAddressEncoder)()],
      ["positionMint", (0, import_web38.getAddressEncoder)()],
      ["liquidity", (0, import_web38.getU128Encoder)()],
      ["tickLowerIndex", (0, import_web38.getI32Encoder)()],
      ["tickUpperIndex", (0, import_web38.getI32Encoder)()],
      ["feeGrowthCheckpointA", (0, import_web38.getU128Encoder)()],
      ["feeOwedA", (0, import_web38.getU64Encoder)()],
      ["feeGrowthCheckpointB", (0, import_web38.getU128Encoder)()],
      ["feeOwedB", (0, import_web38.getU64Encoder)()],
      [
        "rewardInfos",
        (0, import_web38.getArrayEncoder)(getPositionRewardInfoEncoder(), { size: 3 })
      ]
    ]),
    (value) => ({ ...value, discriminator: POSITION_DISCRIMINATOR })
  );
}
function getPositionDecoder() {
  return (0, import_web38.getStructDecoder)([
    ["discriminator", (0, import_web38.fixDecoderSize)((0, import_web38.getBytesDecoder)(), 8)],
    ["whirlpool", (0, import_web38.getAddressDecoder)()],
    ["positionMint", (0, import_web38.getAddressDecoder)()],
    ["liquidity", (0, import_web38.getU128Decoder)()],
    ["tickLowerIndex", (0, import_web38.getI32Decoder)()],
    ["tickUpperIndex", (0, import_web38.getI32Decoder)()],
    ["feeGrowthCheckpointA", (0, import_web38.getU128Decoder)()],
    ["feeOwedA", (0, import_web38.getU64Decoder)()],
    ["feeGrowthCheckpointB", (0, import_web38.getU128Decoder)()],
    ["feeOwedB", (0, import_web38.getU64Decoder)()],
    [
      "rewardInfos",
      (0, import_web38.getArrayDecoder)(getPositionRewardInfoDecoder(), { size: 3 })
    ]
  ]);
}
function getPositionCodec() {
  return (0, import_web38.combineCodec)(getPositionEncoder(), getPositionDecoder());
}
function decodePosition(encodedAccount) {
  return (0, import_web38.decodeAccount)(
    encodedAccount,
    getPositionDecoder()
  );
}
async function fetchPosition(rpc, address, config) {
  const maybeAccount = await fetchMaybePosition(rpc, address, config);
  (0, import_web38.assertAccountExists)(maybeAccount);
  return maybeAccount;
}
async function fetchMaybePosition(rpc, address, config) {
  const maybeAccount = await (0, import_web38.fetchEncodedAccount)(rpc, address, config);
  return decodePosition(maybeAccount);
}
async function fetchAllPosition(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybePosition(rpc, addresses, config);
  (0, import_web38.assertAccountsExist)(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybePosition(rpc, addresses, config) {
  const maybeAccounts = await (0, import_web38.fetchEncodedAccounts)(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodePosition(maybeAccount));
}
function getPositionSize() {
  return 216;
}

// src/generated/accounts/positionBundle.ts
var import_web39 = require("@solana/web3.js");
var POSITION_BUNDLE_DISCRIMINATOR = new Uint8Array([
  129,
  169,
  175,
  65,
  185,
  95,
  32,
  100
]);
function getPositionBundleDiscriminatorBytes() {
  return (0, import_web39.fixEncoderSize)((0, import_web39.getBytesEncoder)(), 8).encode(
    POSITION_BUNDLE_DISCRIMINATOR
  );
}
function getPositionBundleEncoder() {
  return (0, import_web39.transformEncoder)(
    (0, import_web39.getStructEncoder)([
      ["discriminator", (0, import_web39.fixEncoderSize)((0, import_web39.getBytesEncoder)(), 8)],
      ["positionBundleMint", (0, import_web39.getAddressEncoder)()],
      ["positionBitmap", (0, import_web39.fixEncoderSize)((0, import_web39.getBytesEncoder)(), 32)]
    ]),
    (value) => ({ ...value, discriminator: POSITION_BUNDLE_DISCRIMINATOR })
  );
}
function getPositionBundleDecoder() {
  return (0, import_web39.getStructDecoder)([
    ["discriminator", (0, import_web39.fixDecoderSize)((0, import_web39.getBytesDecoder)(), 8)],
    ["positionBundleMint", (0, import_web39.getAddressDecoder)()],
    ["positionBitmap", (0, import_web39.fixDecoderSize)((0, import_web39.getBytesDecoder)(), 32)]
  ]);
}
function getPositionBundleCodec() {
  return (0, import_web39.combineCodec)(getPositionBundleEncoder(), getPositionBundleDecoder());
}
function decodePositionBundle(encodedAccount) {
  return (0, import_web39.decodeAccount)(
    encodedAccount,
    getPositionBundleDecoder()
  );
}
async function fetchPositionBundle(rpc, address, config) {
  const maybeAccount = await fetchMaybePositionBundle(rpc, address, config);
  (0, import_web39.assertAccountExists)(maybeAccount);
  return maybeAccount;
}
async function fetchMaybePositionBundle(rpc, address, config) {
  const maybeAccount = await (0, import_web39.fetchEncodedAccount)(rpc, address, config);
  return decodePositionBundle(maybeAccount);
}
async function fetchAllPositionBundle(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybePositionBundle(
    rpc,
    addresses,
    config
  );
  (0, import_web39.assertAccountsExist)(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybePositionBundle(rpc, addresses, config) {
  const maybeAccounts = await (0, import_web39.fetchEncodedAccounts)(rpc, addresses, config);
  return maybeAccounts.map(
    (maybeAccount) => decodePositionBundle(maybeAccount)
  );
}
function getPositionBundleSize() {
  return 72;
}

// src/generated/accounts/tickArray.ts
var import_web310 = require("@solana/web3.js");
var TICK_ARRAY_DISCRIMINATOR = new Uint8Array([
  69,
  97,
  189,
  190,
  110,
  7,
  66,
  187
]);
function getTickArrayDiscriminatorBytes() {
  return (0, import_web310.fixEncoderSize)((0, import_web310.getBytesEncoder)(), 8).encode(TICK_ARRAY_DISCRIMINATOR);
}
function getTickArrayEncoder() {
  return (0, import_web310.transformEncoder)(
    (0, import_web310.getStructEncoder)([
      ["discriminator", (0, import_web310.fixEncoderSize)((0, import_web310.getBytesEncoder)(), 8)],
      ["startTickIndex", (0, import_web310.getI32Encoder)()],
      ["ticks", (0, import_web310.getArrayEncoder)(getTickEncoder(), { size: 88 })],
      ["whirlpool", (0, import_web310.getAddressEncoder)()]
    ]),
    (value) => ({ ...value, discriminator: TICK_ARRAY_DISCRIMINATOR })
  );
}
function getTickArrayDecoder() {
  return (0, import_web310.getStructDecoder)([
    ["discriminator", (0, import_web310.fixDecoderSize)((0, import_web310.getBytesDecoder)(), 8)],
    ["startTickIndex", (0, import_web310.getI32Decoder)()],
    ["ticks", (0, import_web310.getArrayDecoder)(getTickDecoder(), { size: 88 })],
    ["whirlpool", (0, import_web310.getAddressDecoder)()]
  ]);
}
function getTickArrayCodec() {
  return (0, import_web310.combineCodec)(getTickArrayEncoder(), getTickArrayDecoder());
}
function decodeTickArray(encodedAccount) {
  return (0, import_web310.decodeAccount)(
    encodedAccount,
    getTickArrayDecoder()
  );
}
async function fetchTickArray(rpc, address, config) {
  const maybeAccount = await fetchMaybeTickArray(rpc, address, config);
  (0, import_web310.assertAccountExists)(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeTickArray(rpc, address, config) {
  const maybeAccount = await (0, import_web310.fetchEncodedAccount)(rpc, address, config);
  return decodeTickArray(maybeAccount);
}
async function fetchAllTickArray(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeTickArray(rpc, addresses, config);
  (0, import_web310.assertAccountsExist)(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeTickArray(rpc, addresses, config) {
  const maybeAccounts = await (0, import_web310.fetchEncodedAccounts)(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeTickArray(maybeAccount));
}
function getTickArraySize() {
  return 9988;
}

// src/generated/accounts/tokenBadge.ts
var import_web311 = require("@solana/web3.js");
var TOKEN_BADGE_DISCRIMINATOR = new Uint8Array([
  116,
  219,
  204,
  229,
  249,
  116,
  255,
  150
]);
function getTokenBadgeDiscriminatorBytes() {
  return (0, import_web311.fixEncoderSize)((0, import_web311.getBytesEncoder)(), 8).encode(TOKEN_BADGE_DISCRIMINATOR);
}
function getTokenBadgeEncoder() {
  return (0, import_web311.transformEncoder)(
    (0, import_web311.getStructEncoder)([
      ["discriminator", (0, import_web311.fixEncoderSize)((0, import_web311.getBytesEncoder)(), 8)],
      ["whirlpoolsConfig", (0, import_web311.getAddressEncoder)()],
      ["tokenMint", (0, import_web311.getAddressEncoder)()]
    ]),
    (value) => ({ ...value, discriminator: TOKEN_BADGE_DISCRIMINATOR })
  );
}
function getTokenBadgeDecoder() {
  return (0, import_web311.getStructDecoder)([
    ["discriminator", (0, import_web311.fixDecoderSize)((0, import_web311.getBytesDecoder)(), 8)],
    ["whirlpoolsConfig", (0, import_web311.getAddressDecoder)()],
    ["tokenMint", (0, import_web311.getAddressDecoder)()]
  ]);
}
function getTokenBadgeCodec() {
  return (0, import_web311.combineCodec)(getTokenBadgeEncoder(), getTokenBadgeDecoder());
}
function decodeTokenBadge(encodedAccount) {
  return (0, import_web311.decodeAccount)(
    encodedAccount,
    getTokenBadgeDecoder()
  );
}
async function fetchTokenBadge(rpc, address, config) {
  const maybeAccount = await fetchMaybeTokenBadge(rpc, address, config);
  (0, import_web311.assertAccountExists)(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeTokenBadge(rpc, address, config) {
  const maybeAccount = await (0, import_web311.fetchEncodedAccount)(rpc, address, config);
  return decodeTokenBadge(maybeAccount);
}
async function fetchAllTokenBadge(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeTokenBadge(rpc, addresses, config);
  (0, import_web311.assertAccountsExist)(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeTokenBadge(rpc, addresses, config) {
  const maybeAccounts = await (0, import_web311.fetchEncodedAccounts)(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeTokenBadge(maybeAccount));
}
function getTokenBadgeSize() {
  return 72;
}

// src/generated/accounts/whirlpool.ts
var import_web312 = require("@solana/web3.js");
var WHIRLPOOL_DISCRIMINATOR = new Uint8Array([
  63,
  149,
  209,
  12,
  225,
  128,
  99,
  9
]);
function getWhirlpoolDiscriminatorBytes() {
  return (0, import_web312.fixEncoderSize)((0, import_web312.getBytesEncoder)(), 8).encode(WHIRLPOOL_DISCRIMINATOR);
}
function getWhirlpoolEncoder() {
  return (0, import_web312.transformEncoder)(
    (0, import_web312.getStructEncoder)([
      ["discriminator", (0, import_web312.fixEncoderSize)((0, import_web312.getBytesEncoder)(), 8)],
      ["whirlpoolsConfig", (0, import_web312.getAddressEncoder)()],
      ["whirlpoolBump", (0, import_web312.fixEncoderSize)((0, import_web312.getBytesEncoder)(), 1)],
      ["tickSpacing", (0, import_web312.getU16Encoder)()],
      ["tickSpacingSeed", (0, import_web312.fixEncoderSize)((0, import_web312.getBytesEncoder)(), 2)],
      ["feeRate", (0, import_web312.getU16Encoder)()],
      ["protocolFeeRate", (0, import_web312.getU16Encoder)()],
      ["liquidity", (0, import_web312.getU128Encoder)()],
      ["sqrtPrice", (0, import_web312.getU128Encoder)()],
      ["tickCurrentIndex", (0, import_web312.getI32Encoder)()],
      ["protocolFeeOwedA", (0, import_web312.getU64Encoder)()],
      ["protocolFeeOwedB", (0, import_web312.getU64Encoder)()],
      ["tokenMintA", (0, import_web312.getAddressEncoder)()],
      ["tokenVaultA", (0, import_web312.getAddressEncoder)()],
      ["feeGrowthGlobalA", (0, import_web312.getU128Encoder)()],
      ["tokenMintB", (0, import_web312.getAddressEncoder)()],
      ["tokenVaultB", (0, import_web312.getAddressEncoder)()],
      ["feeGrowthGlobalB", (0, import_web312.getU128Encoder)()],
      ["rewardLastUpdatedTimestamp", (0, import_web312.getU64Encoder)()],
      [
        "rewardInfos",
        (0, import_web312.getArrayEncoder)(getWhirlpoolRewardInfoEncoder(), { size: 3 })
      ]
    ]),
    (value) => ({ ...value, discriminator: WHIRLPOOL_DISCRIMINATOR })
  );
}
function getWhirlpoolDecoder() {
  return (0, import_web312.getStructDecoder)([
    ["discriminator", (0, import_web312.fixDecoderSize)((0, import_web312.getBytesDecoder)(), 8)],
    ["whirlpoolsConfig", (0, import_web312.getAddressDecoder)()],
    ["whirlpoolBump", (0, import_web312.fixDecoderSize)((0, import_web312.getBytesDecoder)(), 1)],
    ["tickSpacing", (0, import_web312.getU16Decoder)()],
    ["tickSpacingSeed", (0, import_web312.fixDecoderSize)((0, import_web312.getBytesDecoder)(), 2)],
    ["feeRate", (0, import_web312.getU16Decoder)()],
    ["protocolFeeRate", (0, import_web312.getU16Decoder)()],
    ["liquidity", (0, import_web312.getU128Decoder)()],
    ["sqrtPrice", (0, import_web312.getU128Decoder)()],
    ["tickCurrentIndex", (0, import_web312.getI32Decoder)()],
    ["protocolFeeOwedA", (0, import_web312.getU64Decoder)()],
    ["protocolFeeOwedB", (0, import_web312.getU64Decoder)()],
    ["tokenMintA", (0, import_web312.getAddressDecoder)()],
    ["tokenVaultA", (0, import_web312.getAddressDecoder)()],
    ["feeGrowthGlobalA", (0, import_web312.getU128Decoder)()],
    ["tokenMintB", (0, import_web312.getAddressDecoder)()],
    ["tokenVaultB", (0, import_web312.getAddressDecoder)()],
    ["feeGrowthGlobalB", (0, import_web312.getU128Decoder)()],
    ["rewardLastUpdatedTimestamp", (0, import_web312.getU64Decoder)()],
    [
      "rewardInfos",
      (0, import_web312.getArrayDecoder)(getWhirlpoolRewardInfoDecoder(), { size: 3 })
    ]
  ]);
}
function getWhirlpoolCodec() {
  return (0, import_web312.combineCodec)(getWhirlpoolEncoder(), getWhirlpoolDecoder());
}
function decodeWhirlpool(encodedAccount) {
  return (0, import_web312.decodeAccount)(
    encodedAccount,
    getWhirlpoolDecoder()
  );
}
async function fetchWhirlpool(rpc, address, config) {
  const maybeAccount = await fetchMaybeWhirlpool(rpc, address, config);
  (0, import_web312.assertAccountExists)(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeWhirlpool(rpc, address, config) {
  const maybeAccount = await (0, import_web312.fetchEncodedAccount)(rpc, address, config);
  return decodeWhirlpool(maybeAccount);
}
async function fetchAllWhirlpool(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeWhirlpool(rpc, addresses, config);
  (0, import_web312.assertAccountsExist)(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeWhirlpool(rpc, addresses, config) {
  const maybeAccounts = await (0, import_web312.fetchEncodedAccounts)(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeWhirlpool(maybeAccount));
}
function getWhirlpoolSize() {
  return 653;
}

// src/generated/accounts/whirlpoolsConfig.ts
var import_web313 = require("@solana/web3.js");
var WHIRLPOOLS_CONFIG_DISCRIMINATOR = new Uint8Array([
  157,
  20,
  49,
  224,
  217,
  87,
  193,
  254
]);
function getWhirlpoolsConfigDiscriminatorBytes() {
  return (0, import_web313.fixEncoderSize)((0, import_web313.getBytesEncoder)(), 8).encode(
    WHIRLPOOLS_CONFIG_DISCRIMINATOR
  );
}
function getWhirlpoolsConfigEncoder() {
  return (0, import_web313.transformEncoder)(
    (0, import_web313.getStructEncoder)([
      ["discriminator", (0, import_web313.fixEncoderSize)((0, import_web313.getBytesEncoder)(), 8)],
      ["feeAuthority", (0, import_web313.getAddressEncoder)()],
      ["collectProtocolFeesAuthority", (0, import_web313.getAddressEncoder)()],
      ["rewardEmissionsSuperAuthority", (0, import_web313.getAddressEncoder)()],
      ["defaultProtocolFeeRate", (0, import_web313.getU16Encoder)()]
    ]),
    (value) => ({ ...value, discriminator: WHIRLPOOLS_CONFIG_DISCRIMINATOR })
  );
}
function getWhirlpoolsConfigDecoder() {
  return (0, import_web313.getStructDecoder)([
    ["discriminator", (0, import_web313.fixDecoderSize)((0, import_web313.getBytesDecoder)(), 8)],
    ["feeAuthority", (0, import_web313.getAddressDecoder)()],
    ["collectProtocolFeesAuthority", (0, import_web313.getAddressDecoder)()],
    ["rewardEmissionsSuperAuthority", (0, import_web313.getAddressDecoder)()],
    ["defaultProtocolFeeRate", (0, import_web313.getU16Decoder)()]
  ]);
}
function getWhirlpoolsConfigCodec() {
  return (0, import_web313.combineCodec)(
    getWhirlpoolsConfigEncoder(),
    getWhirlpoolsConfigDecoder()
  );
}
function decodeWhirlpoolsConfig(encodedAccount) {
  return (0, import_web313.decodeAccount)(
    encodedAccount,
    getWhirlpoolsConfigDecoder()
  );
}
async function fetchWhirlpoolsConfig(rpc, address, config) {
  const maybeAccount = await fetchMaybeWhirlpoolsConfig(rpc, address, config);
  (0, import_web313.assertAccountExists)(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeWhirlpoolsConfig(rpc, address, config) {
  const maybeAccount = await (0, import_web313.fetchEncodedAccount)(rpc, address, config);
  return decodeWhirlpoolsConfig(maybeAccount);
}
async function fetchAllWhirlpoolsConfig(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeWhirlpoolsConfig(
    rpc,
    addresses,
    config
  );
  (0, import_web313.assertAccountsExist)(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeWhirlpoolsConfig(rpc, addresses, config) {
  const maybeAccounts = await (0, import_web313.fetchEncodedAccounts)(rpc, addresses, config);
  return maybeAccounts.map(
    (maybeAccount) => decodeWhirlpoolsConfig(maybeAccount)
  );
}
function getWhirlpoolsConfigSize() {
  return 106;
}

// src/generated/accounts/whirlpoolsConfigExtension.ts
var import_web314 = require("@solana/web3.js");
var WHIRLPOOLS_CONFIG_EXTENSION_DISCRIMINATOR = new Uint8Array([
  2,
  99,
  215,
  163,
  240,
  26,
  153,
  58
]);
function getWhirlpoolsConfigExtensionDiscriminatorBytes() {
  return (0, import_web314.fixEncoderSize)((0, import_web314.getBytesEncoder)(), 8).encode(
    WHIRLPOOLS_CONFIG_EXTENSION_DISCRIMINATOR
  );
}
function getWhirlpoolsConfigExtensionEncoder() {
  return (0, import_web314.transformEncoder)(
    (0, import_web314.getStructEncoder)([
      ["discriminator", (0, import_web314.fixEncoderSize)((0, import_web314.getBytesEncoder)(), 8)],
      ["whirlpoolsConfig", (0, import_web314.getAddressEncoder)()],
      ["configExtensionAuthority", (0, import_web314.getAddressEncoder)()],
      ["tokenBadgeAuthority", (0, import_web314.getAddressEncoder)()]
    ]),
    (value) => ({
      ...value,
      discriminator: WHIRLPOOLS_CONFIG_EXTENSION_DISCRIMINATOR
    })
  );
}
function getWhirlpoolsConfigExtensionDecoder() {
  return (0, import_web314.getStructDecoder)([
    ["discriminator", (0, import_web314.fixDecoderSize)((0, import_web314.getBytesDecoder)(), 8)],
    ["whirlpoolsConfig", (0, import_web314.getAddressDecoder)()],
    ["configExtensionAuthority", (0, import_web314.getAddressDecoder)()],
    ["tokenBadgeAuthority", (0, import_web314.getAddressDecoder)()]
  ]);
}
function getWhirlpoolsConfigExtensionCodec() {
  return (0, import_web314.combineCodec)(
    getWhirlpoolsConfigExtensionEncoder(),
    getWhirlpoolsConfigExtensionDecoder()
  );
}
function decodeWhirlpoolsConfigExtension(encodedAccount) {
  return (0, import_web314.decodeAccount)(
    encodedAccount,
    getWhirlpoolsConfigExtensionDecoder()
  );
}
async function fetchWhirlpoolsConfigExtension(rpc, address, config) {
  const maybeAccount = await fetchMaybeWhirlpoolsConfigExtension(
    rpc,
    address,
    config
  );
  (0, import_web314.assertAccountExists)(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeWhirlpoolsConfigExtension(rpc, address, config) {
  const maybeAccount = await (0, import_web314.fetchEncodedAccount)(rpc, address, config);
  return decodeWhirlpoolsConfigExtension(maybeAccount);
}
async function fetchAllWhirlpoolsConfigExtension(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeWhirlpoolsConfigExtension(
    rpc,
    addresses,
    config
  );
  (0, import_web314.assertAccountsExist)(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeWhirlpoolsConfigExtension(rpc, addresses, config) {
  const maybeAccounts = await (0, import_web314.fetchEncodedAccounts)(rpc, addresses, config);
  return maybeAccounts.map(
    (maybeAccount) => decodeWhirlpoolsConfigExtension(maybeAccount)
  );
}
function getWhirlpoolsConfigExtensionSize() {
  return 104;
}

// src/generated/errors/whirlpool.ts
var import_web316 = require("@solana/web3.js");

// src/generated/programs/whirlpool.ts
var import_web315 = require("@solana/web3.js");
var WHIRLPOOL_PROGRAM_ADDRESS = "whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc";
var WhirlpoolAccount = /* @__PURE__ */ ((WhirlpoolAccount2) => {
  WhirlpoolAccount2[WhirlpoolAccount2["WhirlpoolsConfig"] = 0] = "WhirlpoolsConfig";
  WhirlpoolAccount2[WhirlpoolAccount2["WhirlpoolsConfigExtension"] = 1] = "WhirlpoolsConfigExtension";
  WhirlpoolAccount2[WhirlpoolAccount2["FeeTier"] = 2] = "FeeTier";
  WhirlpoolAccount2[WhirlpoolAccount2["Position"] = 3] = "Position";
  WhirlpoolAccount2[WhirlpoolAccount2["PositionBundle"] = 4] = "PositionBundle";
  WhirlpoolAccount2[WhirlpoolAccount2["TickArray"] = 5] = "TickArray";
  WhirlpoolAccount2[WhirlpoolAccount2["TokenBadge"] = 6] = "TokenBadge";
  WhirlpoolAccount2[WhirlpoolAccount2["Whirlpool"] = 7] = "Whirlpool";
  return WhirlpoolAccount2;
})(WhirlpoolAccount || {});
function identifyWhirlpoolAccount(account) {
  const data = "data" in account ? account.data : account;
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([157, 20, 49, 224, 217, 87, 193, 254])
    ),
    0
  )) {
    return 0 /* WhirlpoolsConfig */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([2, 99, 215, 163, 240, 26, 153, 58])
    ),
    0
  )) {
    return 1 /* WhirlpoolsConfigExtension */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([56, 75, 159, 76, 142, 68, 190, 105])
    ),
    0
  )) {
    return 2 /* FeeTier */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([170, 188, 143, 228, 122, 64, 247, 208])
    ),
    0
  )) {
    return 3 /* Position */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([129, 169, 175, 65, 185, 95, 32, 100])
    ),
    0
  )) {
    return 4 /* PositionBundle */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([69, 97, 189, 190, 110, 7, 66, 187])
    ),
    0
  )) {
    return 5 /* TickArray */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([116, 219, 204, 229, 249, 116, 255, 150])
    ),
    0
  )) {
    return 6 /* TokenBadge */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([63, 149, 209, 12, 225, 128, 99, 9])
    ),
    0
  )) {
    return 7 /* Whirlpool */;
  }
  throw new Error(
    "The provided account could not be identified as a whirlpool account."
  );
}
var WhirlpoolInstruction = /* @__PURE__ */ ((WhirlpoolInstruction2) => {
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializeConfig"] = 0] = "InitializeConfig";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializePool"] = 1] = "InitializePool";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializeTickArray"] = 2] = "InitializeTickArray";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializeFeeTier"] = 3] = "InitializeFeeTier";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializeReward"] = 4] = "InitializeReward";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetRewardEmissions"] = 5] = "SetRewardEmissions";
  WhirlpoolInstruction2[WhirlpoolInstruction2["OpenPosition"] = 6] = "OpenPosition";
  WhirlpoolInstruction2[WhirlpoolInstruction2["OpenPositionWithMetadata"] = 7] = "OpenPositionWithMetadata";
  WhirlpoolInstruction2[WhirlpoolInstruction2["IncreaseLiquidity"] = 8] = "IncreaseLiquidity";
  WhirlpoolInstruction2[WhirlpoolInstruction2["DecreaseLiquidity"] = 9] = "DecreaseLiquidity";
  WhirlpoolInstruction2[WhirlpoolInstruction2["UpdateFeesAndRewards"] = 10] = "UpdateFeesAndRewards";
  WhirlpoolInstruction2[WhirlpoolInstruction2["CollectFees"] = 11] = "CollectFees";
  WhirlpoolInstruction2[WhirlpoolInstruction2["CollectReward"] = 12] = "CollectReward";
  WhirlpoolInstruction2[WhirlpoolInstruction2["CollectProtocolFees"] = 13] = "CollectProtocolFees";
  WhirlpoolInstruction2[WhirlpoolInstruction2["Swap"] = 14] = "Swap";
  WhirlpoolInstruction2[WhirlpoolInstruction2["ClosePosition"] = 15] = "ClosePosition";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetDefaultFeeRate"] = 16] = "SetDefaultFeeRate";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetDefaultProtocolFeeRate"] = 17] = "SetDefaultProtocolFeeRate";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetFeeRate"] = 18] = "SetFeeRate";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetProtocolFeeRate"] = 19] = "SetProtocolFeeRate";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetFeeAuthority"] = 20] = "SetFeeAuthority";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetCollectProtocolFeesAuthority"] = 21] = "SetCollectProtocolFeesAuthority";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetRewardAuthority"] = 22] = "SetRewardAuthority";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetRewardAuthorityBySuperAuthority"] = 23] = "SetRewardAuthorityBySuperAuthority";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetRewardEmissionsSuperAuthority"] = 24] = "SetRewardEmissionsSuperAuthority";
  WhirlpoolInstruction2[WhirlpoolInstruction2["TwoHopSwap"] = 25] = "TwoHopSwap";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializePositionBundle"] = 26] = "InitializePositionBundle";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializePositionBundleWithMetadata"] = 27] = "InitializePositionBundleWithMetadata";
  WhirlpoolInstruction2[WhirlpoolInstruction2["DeletePositionBundle"] = 28] = "DeletePositionBundle";
  WhirlpoolInstruction2[WhirlpoolInstruction2["OpenBundledPosition"] = 29] = "OpenBundledPosition";
  WhirlpoolInstruction2[WhirlpoolInstruction2["CloseBundledPosition"] = 30] = "CloseBundledPosition";
  WhirlpoolInstruction2[WhirlpoolInstruction2["OpenPositionWithTokenExtensions"] = 31] = "OpenPositionWithTokenExtensions";
  WhirlpoolInstruction2[WhirlpoolInstruction2["ClosePositionWithTokenExtensions"] = 32] = "ClosePositionWithTokenExtensions";
  WhirlpoolInstruction2[WhirlpoolInstruction2["CollectFeesV2"] = 33] = "CollectFeesV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["CollectProtocolFeesV2"] = 34] = "CollectProtocolFeesV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["CollectRewardV2"] = 35] = "CollectRewardV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["DecreaseLiquidityV2"] = 36] = "DecreaseLiquidityV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["IncreaseLiquidityV2"] = 37] = "IncreaseLiquidityV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializePoolV2"] = 38] = "InitializePoolV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializeRewardV2"] = 39] = "InitializeRewardV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetRewardEmissionsV2"] = 40] = "SetRewardEmissionsV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SwapV2"] = 41] = "SwapV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["TwoHopSwapV2"] = 42] = "TwoHopSwapV2";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializeConfigExtension"] = 43] = "InitializeConfigExtension";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetConfigExtensionAuthority"] = 44] = "SetConfigExtensionAuthority";
  WhirlpoolInstruction2[WhirlpoolInstruction2["SetTokenBadgeAuthority"] = 45] = "SetTokenBadgeAuthority";
  WhirlpoolInstruction2[WhirlpoolInstruction2["InitializeTokenBadge"] = 46] = "InitializeTokenBadge";
  WhirlpoolInstruction2[WhirlpoolInstruction2["DeleteTokenBadge"] = 47] = "DeleteTokenBadge";
  return WhirlpoolInstruction2;
})(WhirlpoolInstruction || {});
function identifyWhirlpoolInstruction(instruction) {
  const data = "data" in instruction ? instruction.data : instruction;
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([208, 127, 21, 1, 194, 190, 196, 70])
    ),
    0
  )) {
    return 0 /* InitializeConfig */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([95, 180, 10, 172, 84, 174, 232, 40])
    ),
    0
  )) {
    return 1 /* InitializePool */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([11, 188, 193, 214, 141, 91, 149, 184])
    ),
    0
  )) {
    return 2 /* InitializeTickArray */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([183, 74, 156, 160, 112, 2, 42, 30])
    ),
    0
  )) {
    return 3 /* InitializeFeeTier */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([95, 135, 192, 196, 242, 129, 230, 68])
    ),
    0
  )) {
    return 4 /* InitializeReward */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([13, 197, 86, 168, 109, 176, 27, 244])
    ),
    0
  )) {
    return 5 /* SetRewardEmissions */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([135, 128, 47, 77, 15, 152, 240, 49])
    ),
    0
  )) {
    return 6 /* OpenPosition */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([242, 29, 134, 48, 58, 110, 14, 60])
    ),
    0
  )) {
    return 7 /* OpenPositionWithMetadata */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([46, 156, 243, 118, 13, 205, 251, 178])
    ),
    0
  )) {
    return 8 /* IncreaseLiquidity */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([160, 38, 208, 111, 104, 91, 44, 1])
    ),
    0
  )) {
    return 9 /* DecreaseLiquidity */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([154, 230, 250, 13, 236, 209, 75, 223])
    ),
    0
  )) {
    return 10 /* UpdateFeesAndRewards */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([164, 152, 207, 99, 30, 186, 19, 182])
    ),
    0
  )) {
    return 11 /* CollectFees */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([70, 5, 132, 87, 86, 235, 177, 34])
    ),
    0
  )) {
    return 12 /* CollectReward */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([22, 67, 23, 98, 150, 178, 70, 220])
    ),
    0
  )) {
    return 13 /* CollectProtocolFees */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([248, 198, 158, 145, 225, 117, 135, 200])
    ),
    0
  )) {
    return 14 /* Swap */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([123, 134, 81, 0, 49, 68, 98, 98])
    ),
    0
  )) {
    return 15 /* ClosePosition */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([118, 215, 214, 157, 182, 229, 208, 228])
    ),
    0
  )) {
    return 16 /* SetDefaultFeeRate */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([107, 205, 249, 226, 151, 35, 86, 0])
    ),
    0
  )) {
    return 17 /* SetDefaultProtocolFeeRate */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([53, 243, 137, 65, 8, 140, 158, 6])
    ),
    0
  )) {
    return 18 /* SetFeeRate */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([95, 7, 4, 50, 154, 79, 156, 131])
    ),
    0
  )) {
    return 19 /* SetProtocolFeeRate */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([31, 1, 50, 87, 237, 101, 97, 132])
    ),
    0
  )) {
    return 20 /* SetFeeAuthority */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([34, 150, 93, 244, 139, 225, 233, 67])
    ),
    0
  )) {
    return 21 /* SetCollectProtocolFeesAuthority */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([34, 39, 183, 252, 83, 28, 85, 127])
    ),
    0
  )) {
    return 22 /* SetRewardAuthority */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([240, 154, 201, 198, 148, 93, 56, 25])
    ),
    0
  )) {
    return 23 /* SetRewardAuthorityBySuperAuthority */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([207, 5, 200, 209, 122, 56, 82, 183])
    ),
    0
  )) {
    return 24 /* SetRewardEmissionsSuperAuthority */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([195, 96, 237, 108, 68, 162, 219, 230])
    ),
    0
  )) {
    return 25 /* TwoHopSwap */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([117, 45, 241, 149, 24, 18, 194, 65])
    ),
    0
  )) {
    return 26 /* InitializePositionBundle */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([93, 124, 16, 179, 249, 131, 115, 245])
    ),
    0
  )) {
    return 27 /* InitializePositionBundleWithMetadata */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([100, 25, 99, 2, 217, 239, 124, 173])
    ),
    0
  )) {
    return 28 /* DeletePositionBundle */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([169, 113, 126, 171, 213, 172, 212, 49])
    ),
    0
  )) {
    return 29 /* OpenBundledPosition */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([41, 36, 216, 245, 27, 85, 103, 67])
    ),
    0
  )) {
    return 30 /* CloseBundledPosition */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([212, 47, 95, 92, 114, 102, 131, 250])
    ),
    0
  )) {
    return 31 /* OpenPositionWithTokenExtensions */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([1, 182, 135, 59, 155, 25, 99, 223])
    ),
    0
  )) {
    return 32 /* ClosePositionWithTokenExtensions */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([207, 117, 95, 191, 229, 180, 226, 15])
    ),
    0
  )) {
    return 33 /* CollectFeesV2 */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([103, 128, 222, 134, 114, 200, 22, 200])
    ),
    0
  )) {
    return 34 /* CollectProtocolFeesV2 */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([177, 107, 37, 180, 160, 19, 49, 209])
    ),
    0
  )) {
    return 35 /* CollectRewardV2 */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([58, 127, 188, 62, 79, 82, 196, 96])
    ),
    0
  )) {
    return 36 /* DecreaseLiquidityV2 */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([133, 29, 89, 223, 69, 238, 176, 10])
    ),
    0
  )) {
    return 37 /* IncreaseLiquidityV2 */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([207, 45, 87, 242, 27, 63, 204, 67])
    ),
    0
  )) {
    return 38 /* InitializePoolV2 */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([91, 1, 77, 50, 235, 229, 133, 49])
    ),
    0
  )) {
    return 39 /* InitializeRewardV2 */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([114, 228, 72, 32, 193, 48, 160, 102])
    ),
    0
  )) {
    return 40 /* SetRewardEmissionsV2 */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([43, 4, 237, 11, 26, 201, 30, 98])
    ),
    0
  )) {
    return 41 /* SwapV2 */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([186, 143, 209, 29, 254, 2, 194, 117])
    ),
    0
  )) {
    return 42 /* TwoHopSwapV2 */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([55, 9, 53, 9, 114, 57, 209, 52])
    ),
    0
  )) {
    return 43 /* InitializeConfigExtension */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([44, 94, 241, 116, 24, 188, 60, 143])
    ),
    0
  )) {
    return 44 /* SetConfigExtensionAuthority */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([207, 202, 4, 32, 205, 79, 13, 178])
    ),
    0
  )) {
    return 45 /* SetTokenBadgeAuthority */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([253, 77, 205, 95, 27, 224, 89, 223])
    ),
    0
  )) {
    return 46 /* InitializeTokenBadge */;
  }
  if ((0, import_web315.containsBytes)(
    data,
    (0, import_web315.fixEncoderSize)((0, import_web315.getBytesEncoder)(), 8).encode(
      new Uint8Array([53, 146, 68, 8, 18, 117, 17, 185])
    ),
    0
  )) {
    return 47 /* DeleteTokenBadge */;
  }
  throw new Error(
    "The provided instruction could not be identified as a whirlpool instruction."
  );
}

// src/generated/errors/whirlpool.ts
var WHIRLPOOL_ERROR__INVALID_ENUM = 6e3;
var WHIRLPOOL_ERROR__INVALID_START_TICK = 6001;
var WHIRLPOOL_ERROR__TICK_ARRAY_EXIST_IN_POOL = 6002;
var WHIRLPOOL_ERROR__TICK_ARRAY_INDEX_OUTOF_BOUNDS = 6003;
var WHIRLPOOL_ERROR__INVALID_TICK_SPACING = 6004;
var WHIRLPOOL_ERROR__CLOSE_POSITION_NOT_EMPTY = 6005;
var WHIRLPOOL_ERROR__DIVIDE_BY_ZERO = 6006;
var WHIRLPOOL_ERROR__NUMBER_CAST_ERROR = 6007;
var WHIRLPOOL_ERROR__NUMBER_DOWN_CAST_ERROR = 6008;
var WHIRLPOOL_ERROR__TICK_NOT_FOUND = 6009;
var WHIRLPOOL_ERROR__INVALID_TICK_INDEX = 6010;
var WHIRLPOOL_ERROR__SQRT_PRICE_OUT_OF_BOUNDS = 6011;
var WHIRLPOOL_ERROR__LIQUIDITY_ZERO = 6012;
var WHIRLPOOL_ERROR__LIQUIDITY_TOO_HIGH = 6013;
var WHIRLPOOL_ERROR__LIQUIDITY_OVERFLOW = 6014;
var WHIRLPOOL_ERROR__LIQUIDITY_UNDERFLOW = 6015;
var WHIRLPOOL_ERROR__LIQUIDITY_NET_ERROR = 6016;
var WHIRLPOOL_ERROR__TOKEN_MAX_EXCEEDED = 6017;
var WHIRLPOOL_ERROR__TOKEN_MIN_SUBCEEDED = 6018;
var WHIRLPOOL_ERROR__MISSING_OR_INVALID_DELEGATE = 6019;
var WHIRLPOOL_ERROR__INVALID_POSITION_TOKEN_AMOUNT = 6020;
var WHIRLPOOL_ERROR__INVALID_TIMESTAMP_CONVERSION = 6021;
var WHIRLPOOL_ERROR__INVALID_TIMESTAMP = 6022;
var WHIRLPOOL_ERROR__INVALID_TICK_ARRAY_SEQUENCE = 6023;
var WHIRLPOOL_ERROR__INVALID_TOKEN_MINT_ORDER = 6024;
var WHIRLPOOL_ERROR__REWARD_NOT_INITIALIZED = 6025;
var WHIRLPOOL_ERROR__INVALID_REWARD_INDEX = 6026;
var WHIRLPOOL_ERROR__REWARD_VAULT_AMOUNT_INSUFFICIENT = 6027;
var WHIRLPOOL_ERROR__FEE_RATE_MAX_EXCEEDED = 6028;
var WHIRLPOOL_ERROR__PROTOCOL_FEE_RATE_MAX_EXCEEDED = 6029;
var WHIRLPOOL_ERROR__MULTIPLICATION_SHIFT_RIGHT_OVERFLOW = 6030;
var WHIRLPOOL_ERROR__MUL_DIV_OVERFLOW = 6031;
var WHIRLPOOL_ERROR__MUL_DIV_INVALID_INPUT = 6032;
var WHIRLPOOL_ERROR__MULTIPLICATION_OVERFLOW = 6033;
var WHIRLPOOL_ERROR__INVALID_SQRT_PRICE_LIMIT_DIRECTION = 6034;
var WHIRLPOOL_ERROR__ZERO_TRADABLE_AMOUNT = 6035;
var WHIRLPOOL_ERROR__AMOUNT_OUT_BELOW_MINIMUM = 6036;
var WHIRLPOOL_ERROR__AMOUNT_IN_ABOVE_MAXIMUM = 6037;
var WHIRLPOOL_ERROR__TICK_ARRAY_SEQUENCE_INVALID_INDEX = 6038;
var WHIRLPOOL_ERROR__AMOUNT_CALC_OVERFLOW = 6039;
var WHIRLPOOL_ERROR__AMOUNT_REMAINING_OVERFLOW = 6040;
var WHIRLPOOL_ERROR__INVALID_INTERMEDIARY_MINT = 6041;
var WHIRLPOOL_ERROR__DUPLICATE_TWO_HOP_POOL = 6042;
var WHIRLPOOL_ERROR__INVALID_BUNDLE_INDEX = 6043;
var WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_OPENED = 6044;
var WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_CLOSED = 6045;
var WHIRLPOOL_ERROR__POSITION_BUNDLE_NOT_DELETABLE = 6046;
var WHIRLPOOL_ERROR__UNSUPPORTED_TOKEN_MINT = 6047;
var WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INVALID_SLICE = 6048;
var WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INSUFFICIENT = 6049;
var WHIRLPOOL_ERROR__NO_EXTRA_ACCOUNTS_FOR_TRANSFER_HOOK = 6050;
var WHIRLPOOL_ERROR__INTERMEDIATE_TOKEN_AMOUNT_MISMATCH = 6051;
var WHIRLPOOL_ERROR__TRANSFER_FEE_CALCULATION_ERROR = 6052;
var WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_DUPLICATED_ACCOUNTS_TYPE = 6053;
var WHIRLPOOL_ERROR__FULL_RANGE_ONLY_POOL = 6054;
var WHIRLPOOL_ERROR__TOO_MANY_SUPPLEMENTAL_TICK_ARRAYS = 6055;
var WHIRLPOOL_ERROR__DIFFERENT_WHIRLPOOL_TICK_ARRAY_ACCOUNT = 6056;
var WHIRLPOOL_ERROR__PARTIAL_FILL_ERROR = 6057;
var whirlpoolErrorMessages;
if (process.env.NODE_ENV !== "production") {
  whirlpoolErrorMessages = {
    [WHIRLPOOL_ERROR__AMOUNT_CALC_OVERFLOW]: `Amount calculated overflows`,
    [WHIRLPOOL_ERROR__AMOUNT_IN_ABOVE_MAXIMUM]: `Amount in above maximum threshold`,
    [WHIRLPOOL_ERROR__AMOUNT_OUT_BELOW_MINIMUM]: `Amount out below minimum threshold`,
    [WHIRLPOOL_ERROR__AMOUNT_REMAINING_OVERFLOW]: `Amount remaining overflows`,
    [WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_CLOSED]: `Position has already been closed`,
    [WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_OPENED]: `Position has already been opened`,
    [WHIRLPOOL_ERROR__CLOSE_POSITION_NOT_EMPTY]: `Position is not empty It cannot be closed`,
    [WHIRLPOOL_ERROR__DIFFERENT_WHIRLPOOL_TICK_ARRAY_ACCOUNT]: `TickArray account for different whirlpool provided`,
    [WHIRLPOOL_ERROR__DIVIDE_BY_ZERO]: `Unable to divide by zero`,
    [WHIRLPOOL_ERROR__DUPLICATE_TWO_HOP_POOL]: `Duplicate two hop pool`,
    [WHIRLPOOL_ERROR__FEE_RATE_MAX_EXCEEDED]: `Exceeded max fee rate`,
    [WHIRLPOOL_ERROR__FULL_RANGE_ONLY_POOL]: `This whirlpool only supports full-range positions`,
    [WHIRLPOOL_ERROR__INTERMEDIATE_TOKEN_AMOUNT_MISMATCH]: `Output and input amount mismatch`,
    [WHIRLPOOL_ERROR__INVALID_BUNDLE_INDEX]: `Bundle index is out of bounds`,
    [WHIRLPOOL_ERROR__INVALID_ENUM]: `Enum value could not be converted`,
    [WHIRLPOOL_ERROR__INVALID_INTERMEDIARY_MINT]: `Invalid intermediary mint`,
    [WHIRLPOOL_ERROR__INVALID_POSITION_TOKEN_AMOUNT]: `Position token amount must be 1`,
    [WHIRLPOOL_ERROR__INVALID_REWARD_INDEX]: `Invalid reward index`,
    [WHIRLPOOL_ERROR__INVALID_SQRT_PRICE_LIMIT_DIRECTION]: `Provided SqrtPriceLimit not in the same direction as the swap.`,
    [WHIRLPOOL_ERROR__INVALID_START_TICK]: `Invalid start tick index provided.`,
    [WHIRLPOOL_ERROR__INVALID_TICK_ARRAY_SEQUENCE]: `Invalid tick array sequence provided for instruction.`,
    [WHIRLPOOL_ERROR__INVALID_TICK_INDEX]: `Provided tick index is either out of bounds or uninitializable`,
    [WHIRLPOOL_ERROR__INVALID_TICK_SPACING]: `Tick-spacing is not supported`,
    [WHIRLPOOL_ERROR__INVALID_TIMESTAMP]: `Timestamp should be greater than the last updated timestamp`,
    [WHIRLPOOL_ERROR__INVALID_TIMESTAMP_CONVERSION]: `Timestamp should be convertible from i64 to u64`,
    [WHIRLPOOL_ERROR__INVALID_TOKEN_MINT_ORDER]: `Token Mint in wrong order`,
    [WHIRLPOOL_ERROR__LIQUIDITY_NET_ERROR]: `Tick liquidity net underflowed or overflowed`,
    [WHIRLPOOL_ERROR__LIQUIDITY_OVERFLOW]: `Liquidity overflow`,
    [WHIRLPOOL_ERROR__LIQUIDITY_TOO_HIGH]: `Liquidity amount must be less than i64::MAX`,
    [WHIRLPOOL_ERROR__LIQUIDITY_UNDERFLOW]: `Liquidity underflow`,
    [WHIRLPOOL_ERROR__LIQUIDITY_ZERO]: `Liquidity amount must be greater than zero`,
    [WHIRLPOOL_ERROR__MISSING_OR_INVALID_DELEGATE]: `Position token account has a missing or invalid delegate`,
    [WHIRLPOOL_ERROR__MUL_DIV_INVALID_INPUT]: `Invalid div_u256 input`,
    [WHIRLPOOL_ERROR__MUL_DIV_OVERFLOW]: `Muldiv overflow`,
    [WHIRLPOOL_ERROR__MULTIPLICATION_OVERFLOW]: `Multiplication overflow`,
    [WHIRLPOOL_ERROR__MULTIPLICATION_SHIFT_RIGHT_OVERFLOW]: `Multiplication with shift right overflow`,
    [WHIRLPOOL_ERROR__NO_EXTRA_ACCOUNTS_FOR_TRANSFER_HOOK]: `Unable to call transfer hook without extra accounts`,
    [WHIRLPOOL_ERROR__NUMBER_CAST_ERROR]: `Unable to cast number into BigInt`,
    [WHIRLPOOL_ERROR__NUMBER_DOWN_CAST_ERROR]: `Unable to down cast number`,
    [WHIRLPOOL_ERROR__PARTIAL_FILL_ERROR]: `Trade resulted in partial fill`,
    [WHIRLPOOL_ERROR__POSITION_BUNDLE_NOT_DELETABLE]: `Unable to delete PositionBundle with open positions`,
    [WHIRLPOOL_ERROR__PROTOCOL_FEE_RATE_MAX_EXCEEDED]: `Exceeded max protocol fee rate`,
    [WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_DUPLICATED_ACCOUNTS_TYPE]: `Same accounts type is provided more than once`,
    [WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INSUFFICIENT]: `Insufficient remaining accounts`,
    [WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INVALID_SLICE]: `Invalid remaining accounts`,
    [WHIRLPOOL_ERROR__REWARD_NOT_INITIALIZED]: `Reward not initialized`,
    [WHIRLPOOL_ERROR__REWARD_VAULT_AMOUNT_INSUFFICIENT]: `Reward vault requires amount to support emissions for at least one day`,
    [WHIRLPOOL_ERROR__SQRT_PRICE_OUT_OF_BOUNDS]: `Provided sqrt price out of bounds`,
    [WHIRLPOOL_ERROR__TICK_ARRAY_EXIST_IN_POOL]: `Tick-array already exists in this whirlpool`,
    [WHIRLPOOL_ERROR__TICK_ARRAY_INDEX_OUTOF_BOUNDS]: `Attempt to search for a tick-array failed`,
    [WHIRLPOOL_ERROR__TICK_ARRAY_SEQUENCE_INVALID_INDEX]: `Invalid index for tick array sequence`,
    [WHIRLPOOL_ERROR__TICK_NOT_FOUND]: `Tick not found within tick array`,
    [WHIRLPOOL_ERROR__TOKEN_MAX_EXCEEDED]: `Exceeded token max`,
    [WHIRLPOOL_ERROR__TOKEN_MIN_SUBCEEDED]: `Did not meet token min`,
    [WHIRLPOOL_ERROR__TOO_MANY_SUPPLEMENTAL_TICK_ARRAYS]: `Too many supplemental tick arrays provided`,
    [WHIRLPOOL_ERROR__TRANSFER_FEE_CALCULATION_ERROR]: `Transfer fee calculation failed`,
    [WHIRLPOOL_ERROR__UNSUPPORTED_TOKEN_MINT]: `Token mint has unsupported attributes`,
    [WHIRLPOOL_ERROR__ZERO_TRADABLE_AMOUNT]: `There are no tradable amount to swap.`
  };
}
function getWhirlpoolErrorMessage(code) {
  if (process.env.NODE_ENV !== "production") {
    return whirlpoolErrorMessages[code];
  }
  return "Error message not available in production bundles.";
}
function isWhirlpoolError(error, transactionMessage, code) {
  return (0, import_web316.isProgramError)(
    error,
    transactionMessage,
    WHIRLPOOL_PROGRAM_ADDRESS,
    code
  );
}

// src/generated/instructions/closeBundledPosition.ts
var import_web318 = require("@solana/web3.js");

// src/generated/shared/index.ts
var import_web317 = require("@solana/web3.js");
function expectAddress(value) {
  if (!value) {
    throw new Error("Expected a Address.");
  }
  if (typeof value === "object" && "address" in value) {
    return value.address;
  }
  if (Array.isArray(value)) {
    return value[0];
  }
  return value;
}
function getAccountMetaFactory(programAddress, optionalAccountStrategy) {
  return (account) => {
    if (!account.value) {
      if (optionalAccountStrategy === "omitted") return;
      return Object.freeze({
        address: programAddress,
        role: import_web317.AccountRole.READONLY
      });
    }
    const writableRole = account.isWritable ? import_web317.AccountRole.WRITABLE : import_web317.AccountRole.READONLY;
    return Object.freeze({
      address: expectAddress(account.value),
      role: isTransactionSigner(account.value) ? (0, import_web317.upgradeRoleToSigner)(writableRole) : writableRole,
      ...isTransactionSigner(account.value) ? { signer: account.value } : {}
    });
  };
}
function isTransactionSigner(value) {
  return !!value && typeof value === "object" && "address" in value && (0, import_web317.isTransactionSigner)(value);
}

// src/generated/instructions/closeBundledPosition.ts
var CLOSE_BUNDLED_POSITION_DISCRIMINATOR = new Uint8Array([
  41,
  36,
  216,
  245,
  27,
  85,
  103,
  67
]);
function getCloseBundledPositionDiscriminatorBytes() {
  return (0, import_web318.fixEncoderSize)((0, import_web318.getBytesEncoder)(), 8).encode(
    CLOSE_BUNDLED_POSITION_DISCRIMINATOR
  );
}
function getCloseBundledPositionInstructionDataEncoder() {
  return (0, import_web318.transformEncoder)(
    (0, import_web318.getStructEncoder)([
      ["discriminator", (0, import_web318.fixEncoderSize)((0, import_web318.getBytesEncoder)(), 8)],
      ["bundleIndex", (0, import_web318.getU16Encoder)()]
    ]),
    (value) => ({
      ...value,
      discriminator: CLOSE_BUNDLED_POSITION_DISCRIMINATOR
    })
  );
}
function getCloseBundledPositionInstructionDataDecoder() {
  return (0, import_web318.getStructDecoder)([
    ["discriminator", (0, import_web318.fixDecoderSize)((0, import_web318.getBytesDecoder)(), 8)],
    ["bundleIndex", (0, import_web318.getU16Decoder)()]
  ]);
}
function getCloseBundledPositionInstructionDataCodec() {
  return (0, import_web318.combineCodec)(
    getCloseBundledPositionInstructionDataEncoder(),
    getCloseBundledPositionInstructionDataDecoder()
  );
}
function getCloseBundledPositionInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    bundledPosition: { value: input.bundledPosition ?? null, isWritable: true },
    positionBundle: { value: input.positionBundle ?? null, isWritable: true },
    positionBundleTokenAccount: {
      value: input.positionBundleTokenAccount ?? null,
      isWritable: false
    },
    positionBundleAuthority: {
      value: input.positionBundleAuthority ?? null,
      isWritable: false
    },
    receiver: { value: input.receiver ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.bundledPosition),
      getAccountMeta(accounts.positionBundle),
      getAccountMeta(accounts.positionBundleTokenAccount),
      getAccountMeta(accounts.positionBundleAuthority),
      getAccountMeta(accounts.receiver)
    ],
    programAddress,
    data: getCloseBundledPositionInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseCloseBundledPositionInstruction(instruction) {
  if (instruction.accounts.length < 5) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      bundledPosition: getNextAccount(),
      positionBundle: getNextAccount(),
      positionBundleTokenAccount: getNextAccount(),
      positionBundleAuthority: getNextAccount(),
      receiver: getNextAccount()
    },
    data: getCloseBundledPositionInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/closePosition.ts
var import_web319 = require("@solana/web3.js");
var CLOSE_POSITION_DISCRIMINATOR = new Uint8Array([
  123,
  134,
  81,
  0,
  49,
  68,
  98,
  98
]);
function getClosePositionDiscriminatorBytes() {
  return (0, import_web319.fixEncoderSize)((0, import_web319.getBytesEncoder)(), 8).encode(
    CLOSE_POSITION_DISCRIMINATOR
  );
}
function getClosePositionInstructionDataEncoder() {
  return (0, import_web319.transformEncoder)(
    (0, import_web319.getStructEncoder)([["discriminator", (0, import_web319.fixEncoderSize)((0, import_web319.getBytesEncoder)(), 8)]]),
    (value) => ({ ...value, discriminator: CLOSE_POSITION_DISCRIMINATOR })
  );
}
function getClosePositionInstructionDataDecoder() {
  return (0, import_web319.getStructDecoder)([
    ["discriminator", (0, import_web319.fixDecoderSize)((0, import_web319.getBytesDecoder)(), 8)]
  ]);
}
function getClosePositionInstructionDataCodec() {
  return (0, import_web319.combineCodec)(
    getClosePositionInstructionDataEncoder(),
    getClosePositionInstructionDataDecoder()
  );
}
function getClosePositionInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    receiver: { value: input.receiver ?? null, isWritable: true },
    position: { value: input.position ?? null, isWritable: true },
    positionMint: { value: input.positionMint ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: true
    },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.receiver),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionMint),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.tokenProgram)
    ],
    programAddress,
    data: getClosePositionInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseClosePositionInstruction(instruction) {
  if (instruction.accounts.length < 6) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      positionAuthority: getNextAccount(),
      receiver: getNextAccount(),
      position: getNextAccount(),
      positionMint: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      tokenProgram: getNextAccount()
    },
    data: getClosePositionInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/closePositionWithTokenExtensions.ts
var import_web320 = require("@solana/web3.js");
var CLOSE_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR = new Uint8Array([1, 182, 135, 59, 155, 25, 99, 223]);
function getClosePositionWithTokenExtensionsDiscriminatorBytes() {
  return (0, import_web320.fixEncoderSize)((0, import_web320.getBytesEncoder)(), 8).encode(
    CLOSE_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR
  );
}
function getClosePositionWithTokenExtensionsInstructionDataEncoder() {
  return (0, import_web320.transformEncoder)(
    (0, import_web320.getStructEncoder)([["discriminator", (0, import_web320.fixEncoderSize)((0, import_web320.getBytesEncoder)(), 8)]]),
    (value) => ({
      ...value,
      discriminator: CLOSE_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR
    })
  );
}
function getClosePositionWithTokenExtensionsInstructionDataDecoder() {
  return (0, import_web320.getStructDecoder)([
    ["discriminator", (0, import_web320.fixDecoderSize)((0, import_web320.getBytesDecoder)(), 8)]
  ]);
}
function getClosePositionWithTokenExtensionsInstructionDataCodec() {
  return (0, import_web320.combineCodec)(
    getClosePositionWithTokenExtensionsInstructionDataEncoder(),
    getClosePositionWithTokenExtensionsInstructionDataDecoder()
  );
}
function getClosePositionWithTokenExtensionsInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    receiver: { value: input.receiver ?? null, isWritable: true },
    position: { value: input.position ?? null, isWritable: true },
    positionMint: { value: input.positionMint ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: true
    },
    token2022Program: {
      value: input.token2022Program ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.receiver),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionMint),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.token2022Program)
    ],
    programAddress,
    data: getClosePositionWithTokenExtensionsInstructionDataEncoder().encode(
      {}
    )
  };
  return instruction;
}
function parseClosePositionWithTokenExtensionsInstruction(instruction) {
  if (instruction.accounts.length < 6) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      positionAuthority: getNextAccount(),
      receiver: getNextAccount(),
      position: getNextAccount(),
      positionMint: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      token2022Program: getNextAccount()
    },
    data: getClosePositionWithTokenExtensionsInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/collectFees.ts
var import_web321 = require("@solana/web3.js");
var COLLECT_FEES_DISCRIMINATOR = new Uint8Array([
  164,
  152,
  207,
  99,
  30,
  186,
  19,
  182
]);
function getCollectFeesDiscriminatorBytes() {
  return (0, import_web321.fixEncoderSize)((0, import_web321.getBytesEncoder)(), 8).encode(
    COLLECT_FEES_DISCRIMINATOR
  );
}
function getCollectFeesInstructionDataEncoder() {
  return (0, import_web321.transformEncoder)(
    (0, import_web321.getStructEncoder)([["discriminator", (0, import_web321.fixEncoderSize)((0, import_web321.getBytesEncoder)(), 8)]]),
    (value) => ({ ...value, discriminator: COLLECT_FEES_DISCRIMINATOR })
  );
}
function getCollectFeesInstructionDataDecoder() {
  return (0, import_web321.getStructDecoder)([
    ["discriminator", (0, import_web321.fixDecoderSize)((0, import_web321.getBytesDecoder)(), 8)]
  ]);
}
function getCollectFeesInstructionDataCodec() {
  return (0, import_web321.combineCodec)(
    getCollectFeesInstructionDataEncoder(),
    getCollectFeesInstructionDataDecoder()
  );
}
function getCollectFeesInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    position: { value: input.position ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: false
    },
    tokenOwnerAccountA: {
      value: input.tokenOwnerAccountA ?? null,
      isWritable: true
    },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenOwnerAccountB: {
      value: input.tokenOwnerAccountB ?? null,
      isWritable: true
    },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.tokenOwnerAccountA),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenOwnerAccountB),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tokenProgram)
    ],
    programAddress,
    data: getCollectFeesInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseCollectFeesInstruction(instruction) {
  if (instruction.accounts.length < 9) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      positionAuthority: getNextAccount(),
      position: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      tokenOwnerAccountA: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenOwnerAccountB: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tokenProgram: getNextAccount()
    },
    data: getCollectFeesInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/collectFeesV2.ts
var import_web322 = require("@solana/web3.js");
var COLLECT_FEES_V2_DISCRIMINATOR = new Uint8Array([
  207,
  117,
  95,
  191,
  229,
  180,
  226,
  15
]);
function getCollectFeesV2DiscriminatorBytes() {
  return (0, import_web322.fixEncoderSize)((0, import_web322.getBytesEncoder)(), 8).encode(
    COLLECT_FEES_V2_DISCRIMINATOR
  );
}
function getCollectFeesV2InstructionDataEncoder() {
  return (0, import_web322.transformEncoder)(
    (0, import_web322.getStructEncoder)([
      ["discriminator", (0, import_web322.fixEncoderSize)((0, import_web322.getBytesEncoder)(), 8)],
      [
        "remainingAccountsInfo",
        (0, import_web322.getOptionEncoder)(getRemainingAccountsInfoEncoder())
      ]
    ]),
    (value) => ({ ...value, discriminator: COLLECT_FEES_V2_DISCRIMINATOR })
  );
}
function getCollectFeesV2InstructionDataDecoder() {
  return (0, import_web322.getStructDecoder)([
    ["discriminator", (0, import_web322.fixDecoderSize)((0, import_web322.getBytesDecoder)(), 8)],
    [
      "remainingAccountsInfo",
      (0, import_web322.getOptionDecoder)(getRemainingAccountsInfoDecoder())
    ]
  ]);
}
function getCollectFeesV2InstructionDataCodec() {
  return (0, import_web322.combineCodec)(
    getCollectFeesV2InstructionDataEncoder(),
    getCollectFeesV2InstructionDataDecoder()
  );
}
function getCollectFeesV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    position: { value: input.position ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: false
    },
    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },
    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },
    tokenOwnerAccountA: {
      value: input.tokenOwnerAccountA ?? null,
      isWritable: true
    },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenOwnerAccountB: {
      value: input.tokenOwnerAccountB ?? null,
      isWritable: true
    },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tokenProgramA: { value: input.tokenProgramA ?? null, isWritable: false },
    tokenProgramB: { value: input.tokenProgramB ?? null, isWritable: false },
    memoProgram: { value: input.memoProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.tokenMintA),
      getAccountMeta(accounts.tokenMintB),
      getAccountMeta(accounts.tokenOwnerAccountA),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenOwnerAccountB),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tokenProgramA),
      getAccountMeta(accounts.tokenProgramB),
      getAccountMeta(accounts.memoProgram)
    ],
    programAddress,
    data: getCollectFeesV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseCollectFeesV2Instruction(instruction) {
  if (instruction.accounts.length < 13) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      positionAuthority: getNextAccount(),
      position: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      tokenMintA: getNextAccount(),
      tokenMintB: getNextAccount(),
      tokenOwnerAccountA: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenOwnerAccountB: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tokenProgramA: getNextAccount(),
      tokenProgramB: getNextAccount(),
      memoProgram: getNextAccount()
    },
    data: getCollectFeesV2InstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/collectProtocolFees.ts
var import_web323 = require("@solana/web3.js");
var COLLECT_PROTOCOL_FEES_DISCRIMINATOR = new Uint8Array([
  22,
  67,
  23,
  98,
  150,
  178,
  70,
  220
]);
function getCollectProtocolFeesDiscriminatorBytes() {
  return (0, import_web323.fixEncoderSize)((0, import_web323.getBytesEncoder)(), 8).encode(
    COLLECT_PROTOCOL_FEES_DISCRIMINATOR
  );
}
function getCollectProtocolFeesInstructionDataEncoder() {
  return (0, import_web323.transformEncoder)(
    (0, import_web323.getStructEncoder)([["discriminator", (0, import_web323.fixEncoderSize)((0, import_web323.getBytesEncoder)(), 8)]]),
    (value) => ({
      ...value,
      discriminator: COLLECT_PROTOCOL_FEES_DISCRIMINATOR
    })
  );
}
function getCollectProtocolFeesInstructionDataDecoder() {
  return (0, import_web323.getStructDecoder)([
    ["discriminator", (0, import_web323.fixDecoderSize)((0, import_web323.getBytesDecoder)(), 8)]
  ]);
}
function getCollectProtocolFeesInstructionDataCodec() {
  return (0, import_web323.combineCodec)(
    getCollectProtocolFeesInstructionDataEncoder(),
    getCollectProtocolFeesInstructionDataDecoder()
  );
}
function getCollectProtocolFeesInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    collectProtocolFeesAuthority: {
      value: input.collectProtocolFeesAuthority ?? null,
      isWritable: false
    },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tokenDestinationA: {
      value: input.tokenDestinationA ?? null,
      isWritable: true
    },
    tokenDestinationB: {
      value: input.tokenDestinationB ?? null,
      isWritable: true
    },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.collectProtocolFeesAuthority),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tokenDestinationA),
      getAccountMeta(accounts.tokenDestinationB),
      getAccountMeta(accounts.tokenProgram)
    ],
    programAddress,
    data: getCollectProtocolFeesInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseCollectProtocolFeesInstruction(instruction) {
  if (instruction.accounts.length < 8) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      whirlpool: getNextAccount(),
      collectProtocolFeesAuthority: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tokenDestinationA: getNextAccount(),
      tokenDestinationB: getNextAccount(),
      tokenProgram: getNextAccount()
    },
    data: getCollectProtocolFeesInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/collectProtocolFeesV2.ts
var import_web324 = require("@solana/web3.js");
var COLLECT_PROTOCOL_FEES_V2_DISCRIMINATOR = new Uint8Array([
  103,
  128,
  222,
  134,
  114,
  200,
  22,
  200
]);
function getCollectProtocolFeesV2DiscriminatorBytes() {
  return (0, import_web324.fixEncoderSize)((0, import_web324.getBytesEncoder)(), 8).encode(
    COLLECT_PROTOCOL_FEES_V2_DISCRIMINATOR
  );
}
function getCollectProtocolFeesV2InstructionDataEncoder() {
  return (0, import_web324.transformEncoder)(
    (0, import_web324.getStructEncoder)([
      ["discriminator", (0, import_web324.fixEncoderSize)((0, import_web324.getBytesEncoder)(), 8)],
      [
        "remainingAccountsInfo",
        (0, import_web324.getOptionEncoder)(getRemainingAccountsInfoEncoder())
      ]
    ]),
    (value) => ({
      ...value,
      discriminator: COLLECT_PROTOCOL_FEES_V2_DISCRIMINATOR
    })
  );
}
function getCollectProtocolFeesV2InstructionDataDecoder() {
  return (0, import_web324.getStructDecoder)([
    ["discriminator", (0, import_web324.fixDecoderSize)((0, import_web324.getBytesDecoder)(), 8)],
    [
      "remainingAccountsInfo",
      (0, import_web324.getOptionDecoder)(getRemainingAccountsInfoDecoder())
    ]
  ]);
}
function getCollectProtocolFeesV2InstructionDataCodec() {
  return (0, import_web324.combineCodec)(
    getCollectProtocolFeesV2InstructionDataEncoder(),
    getCollectProtocolFeesV2InstructionDataDecoder()
  );
}
function getCollectProtocolFeesV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    collectProtocolFeesAuthority: {
      value: input.collectProtocolFeesAuthority ?? null,
      isWritable: false
    },
    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },
    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tokenDestinationA: {
      value: input.tokenDestinationA ?? null,
      isWritable: true
    },
    tokenDestinationB: {
      value: input.tokenDestinationB ?? null,
      isWritable: true
    },
    tokenProgramA: { value: input.tokenProgramA ?? null, isWritable: false },
    tokenProgramB: { value: input.tokenProgramB ?? null, isWritable: false },
    memoProgram: { value: input.memoProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.collectProtocolFeesAuthority),
      getAccountMeta(accounts.tokenMintA),
      getAccountMeta(accounts.tokenMintB),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tokenDestinationA),
      getAccountMeta(accounts.tokenDestinationB),
      getAccountMeta(accounts.tokenProgramA),
      getAccountMeta(accounts.tokenProgramB),
      getAccountMeta(accounts.memoProgram)
    ],
    programAddress,
    data: getCollectProtocolFeesV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseCollectProtocolFeesV2Instruction(instruction) {
  if (instruction.accounts.length < 12) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      whirlpool: getNextAccount(),
      collectProtocolFeesAuthority: getNextAccount(),
      tokenMintA: getNextAccount(),
      tokenMintB: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tokenDestinationA: getNextAccount(),
      tokenDestinationB: getNextAccount(),
      tokenProgramA: getNextAccount(),
      tokenProgramB: getNextAccount(),
      memoProgram: getNextAccount()
    },
    data: getCollectProtocolFeesV2InstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/collectReward.ts
var import_web325 = require("@solana/web3.js");
var COLLECT_REWARD_DISCRIMINATOR = new Uint8Array([
  70,
  5,
  132,
  87,
  86,
  235,
  177,
  34
]);
function getCollectRewardDiscriminatorBytes() {
  return (0, import_web325.fixEncoderSize)((0, import_web325.getBytesEncoder)(), 8).encode(
    COLLECT_REWARD_DISCRIMINATOR
  );
}
function getCollectRewardInstructionDataEncoder() {
  return (0, import_web325.transformEncoder)(
    (0, import_web325.getStructEncoder)([
      ["discriminator", (0, import_web325.fixEncoderSize)((0, import_web325.getBytesEncoder)(), 8)],
      ["rewardIndex", (0, import_web325.getU8Encoder)()]
    ]),
    (value) => ({ ...value, discriminator: COLLECT_REWARD_DISCRIMINATOR })
  );
}
function getCollectRewardInstructionDataDecoder() {
  return (0, import_web325.getStructDecoder)([
    ["discriminator", (0, import_web325.fixDecoderSize)((0, import_web325.getBytesDecoder)(), 8)],
    ["rewardIndex", (0, import_web325.getU8Decoder)()]
  ]);
}
function getCollectRewardInstructionDataCodec() {
  return (0, import_web325.combineCodec)(
    getCollectRewardInstructionDataEncoder(),
    getCollectRewardInstructionDataDecoder()
  );
}
function getCollectRewardInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    position: { value: input.position ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: false
    },
    rewardOwnerAccount: {
      value: input.rewardOwnerAccount ?? null,
      isWritable: true
    },
    rewardVault: { value: input.rewardVault ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.rewardOwnerAccount),
      getAccountMeta(accounts.rewardVault),
      getAccountMeta(accounts.tokenProgram)
    ],
    programAddress,
    data: getCollectRewardInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseCollectRewardInstruction(instruction) {
  if (instruction.accounts.length < 7) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      positionAuthority: getNextAccount(),
      position: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      rewardOwnerAccount: getNextAccount(),
      rewardVault: getNextAccount(),
      tokenProgram: getNextAccount()
    },
    data: getCollectRewardInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/collectRewardV2.ts
var import_web326 = require("@solana/web3.js");
var COLLECT_REWARD_V2_DISCRIMINATOR = new Uint8Array([
  177,
  107,
  37,
  180,
  160,
  19,
  49,
  209
]);
function getCollectRewardV2DiscriminatorBytes() {
  return (0, import_web326.fixEncoderSize)((0, import_web326.getBytesEncoder)(), 8).encode(
    COLLECT_REWARD_V2_DISCRIMINATOR
  );
}
function getCollectRewardV2InstructionDataEncoder() {
  return (0, import_web326.transformEncoder)(
    (0, import_web326.getStructEncoder)([
      ["discriminator", (0, import_web326.fixEncoderSize)((0, import_web326.getBytesEncoder)(), 8)],
      ["rewardIndex", (0, import_web326.getU8Encoder)()],
      [
        "remainingAccountsInfo",
        (0, import_web326.getOptionEncoder)(getRemainingAccountsInfoEncoder())
      ]
    ]),
    (value) => ({ ...value, discriminator: COLLECT_REWARD_V2_DISCRIMINATOR })
  );
}
function getCollectRewardV2InstructionDataDecoder() {
  return (0, import_web326.getStructDecoder)([
    ["discriminator", (0, import_web326.fixDecoderSize)((0, import_web326.getBytesDecoder)(), 8)],
    ["rewardIndex", (0, import_web326.getU8Decoder)()],
    [
      "remainingAccountsInfo",
      (0, import_web326.getOptionDecoder)(getRemainingAccountsInfoDecoder())
    ]
  ]);
}
function getCollectRewardV2InstructionDataCodec() {
  return (0, import_web326.combineCodec)(
    getCollectRewardV2InstructionDataEncoder(),
    getCollectRewardV2InstructionDataDecoder()
  );
}
function getCollectRewardV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    position: { value: input.position ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: false
    },
    rewardOwnerAccount: {
      value: input.rewardOwnerAccount ?? null,
      isWritable: true
    },
    rewardMint: { value: input.rewardMint ?? null, isWritable: false },
    rewardVault: { value: input.rewardVault ?? null, isWritable: true },
    rewardTokenProgram: {
      value: input.rewardTokenProgram ?? null,
      isWritable: false
    },
    memoProgram: { value: input.memoProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.rewardOwnerAccount),
      getAccountMeta(accounts.rewardMint),
      getAccountMeta(accounts.rewardVault),
      getAccountMeta(accounts.rewardTokenProgram),
      getAccountMeta(accounts.memoProgram)
    ],
    programAddress,
    data: getCollectRewardV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseCollectRewardV2Instruction(instruction) {
  if (instruction.accounts.length < 9) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      positionAuthority: getNextAccount(),
      position: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      rewardOwnerAccount: getNextAccount(),
      rewardMint: getNextAccount(),
      rewardVault: getNextAccount(),
      rewardTokenProgram: getNextAccount(),
      memoProgram: getNextAccount()
    },
    data: getCollectRewardV2InstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/decreaseLiquidity.ts
var import_web327 = require("@solana/web3.js");
var DECREASE_LIQUIDITY_DISCRIMINATOR = new Uint8Array([
  160,
  38,
  208,
  111,
  104,
  91,
  44,
  1
]);
function getDecreaseLiquidityDiscriminatorBytes() {
  return (0, import_web327.fixEncoderSize)((0, import_web327.getBytesEncoder)(), 8).encode(
    DECREASE_LIQUIDITY_DISCRIMINATOR
  );
}
function getDecreaseLiquidityInstructionDataEncoder() {
  return (0, import_web327.transformEncoder)(
    (0, import_web327.getStructEncoder)([
      ["discriminator", (0, import_web327.fixEncoderSize)((0, import_web327.getBytesEncoder)(), 8)],
      ["liquidityAmount", (0, import_web327.getU128Encoder)()],
      ["tokenMinA", (0, import_web327.getU64Encoder)()],
      ["tokenMinB", (0, import_web327.getU64Encoder)()]
    ]),
    (value) => ({ ...value, discriminator: DECREASE_LIQUIDITY_DISCRIMINATOR })
  );
}
function getDecreaseLiquidityInstructionDataDecoder() {
  return (0, import_web327.getStructDecoder)([
    ["discriminator", (0, import_web327.fixDecoderSize)((0, import_web327.getBytesDecoder)(), 8)],
    ["liquidityAmount", (0, import_web327.getU128Decoder)()],
    ["tokenMinA", (0, import_web327.getU64Decoder)()],
    ["tokenMinB", (0, import_web327.getU64Decoder)()]
  ]);
}
function getDecreaseLiquidityInstructionDataCodec() {
  return (0, import_web327.combineCodec)(
    getDecreaseLiquidityInstructionDataEncoder(),
    getDecreaseLiquidityInstructionDataDecoder()
  );
}
function getDecreaseLiquidityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    position: { value: input.position ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: false
    },
    tokenOwnerAccountA: {
      value: input.tokenOwnerAccountA ?? null,
      isWritable: true
    },
    tokenOwnerAccountB: {
      value: input.tokenOwnerAccountB ?? null,
      isWritable: true
    },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tickArrayLower: { value: input.tickArrayLower ?? null, isWritable: true },
    tickArrayUpper: { value: input.tickArrayUpper ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.tokenOwnerAccountA),
      getAccountMeta(accounts.tokenOwnerAccountB),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tickArrayLower),
      getAccountMeta(accounts.tickArrayUpper)
    ],
    programAddress,
    data: getDecreaseLiquidityInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseDecreaseLiquidityInstruction(instruction) {
  if (instruction.accounts.length < 11) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      tokenProgram: getNextAccount(),
      positionAuthority: getNextAccount(),
      position: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      tokenOwnerAccountA: getNextAccount(),
      tokenOwnerAccountB: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tickArrayLower: getNextAccount(),
      tickArrayUpper: getNextAccount()
    },
    data: getDecreaseLiquidityInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/decreaseLiquidityV2.ts
var import_web328 = require("@solana/web3.js");
var DECREASE_LIQUIDITY_V2_DISCRIMINATOR = new Uint8Array([
  58,
  127,
  188,
  62,
  79,
  82,
  196,
  96
]);
function getDecreaseLiquidityV2DiscriminatorBytes() {
  return (0, import_web328.fixEncoderSize)((0, import_web328.getBytesEncoder)(), 8).encode(
    DECREASE_LIQUIDITY_V2_DISCRIMINATOR
  );
}
function getDecreaseLiquidityV2InstructionDataEncoder() {
  return (0, import_web328.transformEncoder)(
    (0, import_web328.getStructEncoder)([
      ["discriminator", (0, import_web328.fixEncoderSize)((0, import_web328.getBytesEncoder)(), 8)],
      ["liquidityAmount", (0, import_web328.getU128Encoder)()],
      ["tokenMinA", (0, import_web328.getU64Encoder)()],
      ["tokenMinB", (0, import_web328.getU64Encoder)()],
      [
        "remainingAccountsInfo",
        (0, import_web328.getOptionEncoder)(getRemainingAccountsInfoEncoder())
      ]
    ]),
    (value) => ({
      ...value,
      discriminator: DECREASE_LIQUIDITY_V2_DISCRIMINATOR
    })
  );
}
function getDecreaseLiquidityV2InstructionDataDecoder() {
  return (0, import_web328.getStructDecoder)([
    ["discriminator", (0, import_web328.fixDecoderSize)((0, import_web328.getBytesDecoder)(), 8)],
    ["liquidityAmount", (0, import_web328.getU128Decoder)()],
    ["tokenMinA", (0, import_web328.getU64Decoder)()],
    ["tokenMinB", (0, import_web328.getU64Decoder)()],
    [
      "remainingAccountsInfo",
      (0, import_web328.getOptionDecoder)(getRemainingAccountsInfoDecoder())
    ]
  ]);
}
function getDecreaseLiquidityV2InstructionDataCodec() {
  return (0, import_web328.combineCodec)(
    getDecreaseLiquidityV2InstructionDataEncoder(),
    getDecreaseLiquidityV2InstructionDataDecoder()
  );
}
function getDecreaseLiquidityV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    tokenProgramA: { value: input.tokenProgramA ?? null, isWritable: false },
    tokenProgramB: { value: input.tokenProgramB ?? null, isWritable: false },
    memoProgram: { value: input.memoProgram ?? null, isWritable: false },
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    position: { value: input.position ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: false
    },
    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },
    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },
    tokenOwnerAccountA: {
      value: input.tokenOwnerAccountA ?? null,
      isWritable: true
    },
    tokenOwnerAccountB: {
      value: input.tokenOwnerAccountB ?? null,
      isWritable: true
    },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tickArrayLower: { value: input.tickArrayLower ?? null, isWritable: true },
    tickArrayUpper: { value: input.tickArrayUpper ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenProgramA),
      getAccountMeta(accounts.tokenProgramB),
      getAccountMeta(accounts.memoProgram),
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.tokenMintA),
      getAccountMeta(accounts.tokenMintB),
      getAccountMeta(accounts.tokenOwnerAccountA),
      getAccountMeta(accounts.tokenOwnerAccountB),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tickArrayLower),
      getAccountMeta(accounts.tickArrayUpper)
    ],
    programAddress,
    data: getDecreaseLiquidityV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseDecreaseLiquidityV2Instruction(instruction) {
  if (instruction.accounts.length < 15) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      tokenProgramA: getNextAccount(),
      tokenProgramB: getNextAccount(),
      memoProgram: getNextAccount(),
      positionAuthority: getNextAccount(),
      position: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      tokenMintA: getNextAccount(),
      tokenMintB: getNextAccount(),
      tokenOwnerAccountA: getNextAccount(),
      tokenOwnerAccountB: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tickArrayLower: getNextAccount(),
      tickArrayUpper: getNextAccount()
    },
    data: getDecreaseLiquidityV2InstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/deletePositionBundle.ts
var import_web329 = require("@solana/web3.js");
var DELETE_POSITION_BUNDLE_DISCRIMINATOR = new Uint8Array([
  100,
  25,
  99,
  2,
  217,
  239,
  124,
  173
]);
function getDeletePositionBundleDiscriminatorBytes() {
  return (0, import_web329.fixEncoderSize)((0, import_web329.getBytesEncoder)(), 8).encode(
    DELETE_POSITION_BUNDLE_DISCRIMINATOR
  );
}
function getDeletePositionBundleInstructionDataEncoder() {
  return (0, import_web329.transformEncoder)(
    (0, import_web329.getStructEncoder)([["discriminator", (0, import_web329.fixEncoderSize)((0, import_web329.getBytesEncoder)(), 8)]]),
    (value) => ({
      ...value,
      discriminator: DELETE_POSITION_BUNDLE_DISCRIMINATOR
    })
  );
}
function getDeletePositionBundleInstructionDataDecoder() {
  return (0, import_web329.getStructDecoder)([
    ["discriminator", (0, import_web329.fixDecoderSize)((0, import_web329.getBytesDecoder)(), 8)]
  ]);
}
function getDeletePositionBundleInstructionDataCodec() {
  return (0, import_web329.combineCodec)(
    getDeletePositionBundleInstructionDataEncoder(),
    getDeletePositionBundleInstructionDataDecoder()
  );
}
function getDeletePositionBundleInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    positionBundle: { value: input.positionBundle ?? null, isWritable: true },
    positionBundleMint: {
      value: input.positionBundleMint ?? null,
      isWritable: true
    },
    positionBundleTokenAccount: {
      value: input.positionBundleTokenAccount ?? null,
      isWritable: true
    },
    positionBundleOwner: {
      value: input.positionBundleOwner ?? null,
      isWritable: false
    },
    receiver: { value: input.receiver ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.positionBundle),
      getAccountMeta(accounts.positionBundleMint),
      getAccountMeta(accounts.positionBundleTokenAccount),
      getAccountMeta(accounts.positionBundleOwner),
      getAccountMeta(accounts.receiver),
      getAccountMeta(accounts.tokenProgram)
    ],
    programAddress,
    data: getDeletePositionBundleInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseDeletePositionBundleInstruction(instruction) {
  if (instruction.accounts.length < 6) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      positionBundle: getNextAccount(),
      positionBundleMint: getNextAccount(),
      positionBundleTokenAccount: getNextAccount(),
      positionBundleOwner: getNextAccount(),
      receiver: getNextAccount(),
      tokenProgram: getNextAccount()
    },
    data: getDeletePositionBundleInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/deleteTokenBadge.ts
var import_web330 = require("@solana/web3.js");
var DELETE_TOKEN_BADGE_DISCRIMINATOR = new Uint8Array([
  53,
  146,
  68,
  8,
  18,
  117,
  17,
  185
]);
function getDeleteTokenBadgeDiscriminatorBytes() {
  return (0, import_web330.fixEncoderSize)((0, import_web330.getBytesEncoder)(), 8).encode(
    DELETE_TOKEN_BADGE_DISCRIMINATOR
  );
}
function getDeleteTokenBadgeInstructionDataEncoder() {
  return (0, import_web330.transformEncoder)(
    (0, import_web330.getStructEncoder)([["discriminator", (0, import_web330.fixEncoderSize)((0, import_web330.getBytesEncoder)(), 8)]]),
    (value) => ({ ...value, discriminator: DELETE_TOKEN_BADGE_DISCRIMINATOR })
  );
}
function getDeleteTokenBadgeInstructionDataDecoder() {
  return (0, import_web330.getStructDecoder)([
    ["discriminator", (0, import_web330.fixDecoderSize)((0, import_web330.getBytesDecoder)(), 8)]
  ]);
}
function getDeleteTokenBadgeInstructionDataCodec() {
  return (0, import_web330.combineCodec)(
    getDeleteTokenBadgeInstructionDataEncoder(),
    getDeleteTokenBadgeInstructionDataDecoder()
  );
}
function getDeleteTokenBadgeInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    whirlpoolsConfigExtension: {
      value: input.whirlpoolsConfigExtension ?? null,
      isWritable: false
    },
    tokenBadgeAuthority: {
      value: input.tokenBadgeAuthority ?? null,
      isWritable: false
    },
    tokenMint: { value: input.tokenMint ?? null, isWritable: false },
    tokenBadge: { value: input.tokenBadge ?? null, isWritable: true },
    receiver: { value: input.receiver ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.whirlpoolsConfigExtension),
      getAccountMeta(accounts.tokenBadgeAuthority),
      getAccountMeta(accounts.tokenMint),
      getAccountMeta(accounts.tokenBadge),
      getAccountMeta(accounts.receiver)
    ],
    programAddress,
    data: getDeleteTokenBadgeInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseDeleteTokenBadgeInstruction(instruction) {
  if (instruction.accounts.length < 6) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      whirlpoolsConfigExtension: getNextAccount(),
      tokenBadgeAuthority: getNextAccount(),
      tokenMint: getNextAccount(),
      tokenBadge: getNextAccount(),
      receiver: getNextAccount()
    },
    data: getDeleteTokenBadgeInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/increaseLiquidity.ts
var import_web331 = require("@solana/web3.js");
var INCREASE_LIQUIDITY_DISCRIMINATOR = new Uint8Array([
  46,
  156,
  243,
  118,
  13,
  205,
  251,
  178
]);
function getIncreaseLiquidityDiscriminatorBytes() {
  return (0, import_web331.fixEncoderSize)((0, import_web331.getBytesEncoder)(), 8).encode(
    INCREASE_LIQUIDITY_DISCRIMINATOR
  );
}
function getIncreaseLiquidityInstructionDataEncoder() {
  return (0, import_web331.transformEncoder)(
    (0, import_web331.getStructEncoder)([
      ["discriminator", (0, import_web331.fixEncoderSize)((0, import_web331.getBytesEncoder)(), 8)],
      ["liquidityAmount", (0, import_web331.getU128Encoder)()],
      ["tokenMaxA", (0, import_web331.getU64Encoder)()],
      ["tokenMaxB", (0, import_web331.getU64Encoder)()]
    ]),
    (value) => ({ ...value, discriminator: INCREASE_LIQUIDITY_DISCRIMINATOR })
  );
}
function getIncreaseLiquidityInstructionDataDecoder() {
  return (0, import_web331.getStructDecoder)([
    ["discriminator", (0, import_web331.fixDecoderSize)((0, import_web331.getBytesDecoder)(), 8)],
    ["liquidityAmount", (0, import_web331.getU128Decoder)()],
    ["tokenMaxA", (0, import_web331.getU64Decoder)()],
    ["tokenMaxB", (0, import_web331.getU64Decoder)()]
  ]);
}
function getIncreaseLiquidityInstructionDataCodec() {
  return (0, import_web331.combineCodec)(
    getIncreaseLiquidityInstructionDataEncoder(),
    getIncreaseLiquidityInstructionDataDecoder()
  );
}
function getIncreaseLiquidityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    position: { value: input.position ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: false
    },
    tokenOwnerAccountA: {
      value: input.tokenOwnerAccountA ?? null,
      isWritable: true
    },
    tokenOwnerAccountB: {
      value: input.tokenOwnerAccountB ?? null,
      isWritable: true
    },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tickArrayLower: { value: input.tickArrayLower ?? null, isWritable: true },
    tickArrayUpper: { value: input.tickArrayUpper ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.tokenOwnerAccountA),
      getAccountMeta(accounts.tokenOwnerAccountB),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tickArrayLower),
      getAccountMeta(accounts.tickArrayUpper)
    ],
    programAddress,
    data: getIncreaseLiquidityInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseIncreaseLiquidityInstruction(instruction) {
  if (instruction.accounts.length < 11) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      tokenProgram: getNextAccount(),
      positionAuthority: getNextAccount(),
      position: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      tokenOwnerAccountA: getNextAccount(),
      tokenOwnerAccountB: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tickArrayLower: getNextAccount(),
      tickArrayUpper: getNextAccount()
    },
    data: getIncreaseLiquidityInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/increaseLiquidityV2.ts
var import_web332 = require("@solana/web3.js");
var INCREASE_LIQUIDITY_V2_DISCRIMINATOR = new Uint8Array([
  133,
  29,
  89,
  223,
  69,
  238,
  176,
  10
]);
function getIncreaseLiquidityV2DiscriminatorBytes() {
  return (0, import_web332.fixEncoderSize)((0, import_web332.getBytesEncoder)(), 8).encode(
    INCREASE_LIQUIDITY_V2_DISCRIMINATOR
  );
}
function getIncreaseLiquidityV2InstructionDataEncoder() {
  return (0, import_web332.transformEncoder)(
    (0, import_web332.getStructEncoder)([
      ["discriminator", (0, import_web332.fixEncoderSize)((0, import_web332.getBytesEncoder)(), 8)],
      ["liquidityAmount", (0, import_web332.getU128Encoder)()],
      ["tokenMaxA", (0, import_web332.getU64Encoder)()],
      ["tokenMaxB", (0, import_web332.getU64Encoder)()],
      [
        "remainingAccountsInfo",
        (0, import_web332.getOptionEncoder)(getRemainingAccountsInfoEncoder())
      ]
    ]),
    (value) => ({
      ...value,
      discriminator: INCREASE_LIQUIDITY_V2_DISCRIMINATOR
    })
  );
}
function getIncreaseLiquidityV2InstructionDataDecoder() {
  return (0, import_web332.getStructDecoder)([
    ["discriminator", (0, import_web332.fixDecoderSize)((0, import_web332.getBytesDecoder)(), 8)],
    ["liquidityAmount", (0, import_web332.getU128Decoder)()],
    ["tokenMaxA", (0, import_web332.getU64Decoder)()],
    ["tokenMaxB", (0, import_web332.getU64Decoder)()],
    [
      "remainingAccountsInfo",
      (0, import_web332.getOptionDecoder)(getRemainingAccountsInfoDecoder())
    ]
  ]);
}
function getIncreaseLiquidityV2InstructionDataCodec() {
  return (0, import_web332.combineCodec)(
    getIncreaseLiquidityV2InstructionDataEncoder(),
    getIncreaseLiquidityV2InstructionDataDecoder()
  );
}
function getIncreaseLiquidityV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    tokenProgramA: { value: input.tokenProgramA ?? null, isWritable: false },
    tokenProgramB: { value: input.tokenProgramB ?? null, isWritable: false },
    memoProgram: { value: input.memoProgram ?? null, isWritable: false },
    positionAuthority: {
      value: input.positionAuthority ?? null,
      isWritable: false
    },
    position: { value: input.position ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: false
    },
    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },
    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },
    tokenOwnerAccountA: {
      value: input.tokenOwnerAccountA ?? null,
      isWritable: true
    },
    tokenOwnerAccountB: {
      value: input.tokenOwnerAccountB ?? null,
      isWritable: true
    },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tickArrayLower: { value: input.tickArrayLower ?? null, isWritable: true },
    tickArrayUpper: { value: input.tickArrayUpper ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenProgramA),
      getAccountMeta(accounts.tokenProgramB),
      getAccountMeta(accounts.memoProgram),
      getAccountMeta(accounts.positionAuthority),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.tokenMintA),
      getAccountMeta(accounts.tokenMintB),
      getAccountMeta(accounts.tokenOwnerAccountA),
      getAccountMeta(accounts.tokenOwnerAccountB),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tickArrayLower),
      getAccountMeta(accounts.tickArrayUpper)
    ],
    programAddress,
    data: getIncreaseLiquidityV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseIncreaseLiquidityV2Instruction(instruction) {
  if (instruction.accounts.length < 15) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      tokenProgramA: getNextAccount(),
      tokenProgramB: getNextAccount(),
      memoProgram: getNextAccount(),
      positionAuthority: getNextAccount(),
      position: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      tokenMintA: getNextAccount(),
      tokenMintB: getNextAccount(),
      tokenOwnerAccountA: getNextAccount(),
      tokenOwnerAccountB: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tickArrayLower: getNextAccount(),
      tickArrayUpper: getNextAccount()
    },
    data: getIncreaseLiquidityV2InstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/initializeConfig.ts
var import_web333 = require("@solana/web3.js");
var INITIALIZE_CONFIG_DISCRIMINATOR = new Uint8Array([
  208,
  127,
  21,
  1,
  194,
  190,
  196,
  70
]);
function getInitializeConfigDiscriminatorBytes() {
  return (0, import_web333.fixEncoderSize)((0, import_web333.getBytesEncoder)(), 8).encode(
    INITIALIZE_CONFIG_DISCRIMINATOR
  );
}
function getInitializeConfigInstructionDataEncoder() {
  return (0, import_web333.transformEncoder)(
    (0, import_web333.getStructEncoder)([
      ["discriminator", (0, import_web333.fixEncoderSize)((0, import_web333.getBytesEncoder)(), 8)],
      ["feeAuthority", (0, import_web333.getAddressEncoder)()],
      ["collectProtocolFeesAuthority", (0, import_web333.getAddressEncoder)()],
      ["rewardEmissionsSuperAuthority", (0, import_web333.getAddressEncoder)()],
      ["defaultProtocolFeeRate", (0, import_web333.getU16Encoder)()]
    ]),
    (value) => ({ ...value, discriminator: INITIALIZE_CONFIG_DISCRIMINATOR })
  );
}
function getInitializeConfigInstructionDataDecoder() {
  return (0, import_web333.getStructDecoder)([
    ["discriminator", (0, import_web333.fixDecoderSize)((0, import_web333.getBytesDecoder)(), 8)],
    ["feeAuthority", (0, import_web333.getAddressDecoder)()],
    ["collectProtocolFeesAuthority", (0, import_web333.getAddressDecoder)()],
    ["rewardEmissionsSuperAuthority", (0, import_web333.getAddressDecoder)()],
    ["defaultProtocolFeeRate", (0, import_web333.getU16Decoder)()]
  ]);
}
function getInitializeConfigInstructionDataCodec() {
  return (0, import_web333.combineCodec)(
    getInitializeConfigInstructionDataEncoder(),
    getInitializeConfigInstructionDataDecoder()
  );
}
function getInitializeConfigInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    config: { value: input.config ?? null, isWritable: true },
    funder: { value: input.funder ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.config),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.systemProgram)
    ],
    programAddress,
    data: getInitializeConfigInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeConfigInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      config: getNextAccount(),
      funder: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getInitializeConfigInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/initializeConfigExtension.ts
var import_web334 = require("@solana/web3.js");
var INITIALIZE_CONFIG_EXTENSION_DISCRIMINATOR = new Uint8Array([
  55,
  9,
  53,
  9,
  114,
  57,
  209,
  52
]);
function getInitializeConfigExtensionDiscriminatorBytes() {
  return (0, import_web334.fixEncoderSize)((0, import_web334.getBytesEncoder)(), 8).encode(
    INITIALIZE_CONFIG_EXTENSION_DISCRIMINATOR
  );
}
function getInitializeConfigExtensionInstructionDataEncoder() {
  return (0, import_web334.transformEncoder)(
    (0, import_web334.getStructEncoder)([["discriminator", (0, import_web334.fixEncoderSize)((0, import_web334.getBytesEncoder)(), 8)]]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_CONFIG_EXTENSION_DISCRIMINATOR
    })
  );
}
function getInitializeConfigExtensionInstructionDataDecoder() {
  return (0, import_web334.getStructDecoder)([
    ["discriminator", (0, import_web334.fixDecoderSize)((0, import_web334.getBytesDecoder)(), 8)]
  ]);
}
function getInitializeConfigExtensionInstructionDataCodec() {
  return (0, import_web334.combineCodec)(
    getInitializeConfigExtensionInstructionDataEncoder(),
    getInitializeConfigExtensionInstructionDataDecoder()
  );
}
function getInitializeConfigExtensionInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    config: { value: input.config ?? null, isWritable: false },
    configExtension: { value: input.configExtension ?? null, isWritable: true },
    funder: { value: input.funder ?? null, isWritable: true },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.config),
      getAccountMeta(accounts.configExtension),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.feeAuthority),
      getAccountMeta(accounts.systemProgram)
    ],
    programAddress,
    data: getInitializeConfigExtensionInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseInitializeConfigExtensionInstruction(instruction) {
  if (instruction.accounts.length < 5) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      config: getNextAccount(),
      configExtension: getNextAccount(),
      funder: getNextAccount(),
      feeAuthority: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getInitializeConfigExtensionInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/initializeFeeTier.ts
var import_web335 = require("@solana/web3.js");
var INITIALIZE_FEE_TIER_DISCRIMINATOR = new Uint8Array([
  183,
  74,
  156,
  160,
  112,
  2,
  42,
  30
]);
function getInitializeFeeTierDiscriminatorBytes() {
  return (0, import_web335.fixEncoderSize)((0, import_web335.getBytesEncoder)(), 8).encode(
    INITIALIZE_FEE_TIER_DISCRIMINATOR
  );
}
function getInitializeFeeTierInstructionDataEncoder() {
  return (0, import_web335.transformEncoder)(
    (0, import_web335.getStructEncoder)([
      ["discriminator", (0, import_web335.fixEncoderSize)((0, import_web335.getBytesEncoder)(), 8)],
      ["tickSpacing", (0, import_web335.getU16Encoder)()],
      ["defaultFeeRate", (0, import_web335.getU16Encoder)()]
    ]),
    (value) => ({ ...value, discriminator: INITIALIZE_FEE_TIER_DISCRIMINATOR })
  );
}
function getInitializeFeeTierInstructionDataDecoder() {
  return (0, import_web335.getStructDecoder)([
    ["discriminator", (0, import_web335.fixDecoderSize)((0, import_web335.getBytesDecoder)(), 8)],
    ["tickSpacing", (0, import_web335.getU16Decoder)()],
    ["defaultFeeRate", (0, import_web335.getU16Decoder)()]
  ]);
}
function getInitializeFeeTierInstructionDataCodec() {
  return (0, import_web335.combineCodec)(
    getInitializeFeeTierInstructionDataEncoder(),
    getInitializeFeeTierInstructionDataDecoder()
  );
}
function getInitializeFeeTierInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    config: { value: input.config ?? null, isWritable: false },
    feeTier: { value: input.feeTier ?? null, isWritable: true },
    funder: { value: input.funder ?? null, isWritable: true },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.config),
      getAccountMeta(accounts.feeTier),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.feeAuthority),
      getAccountMeta(accounts.systemProgram)
    ],
    programAddress,
    data: getInitializeFeeTierInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeFeeTierInstruction(instruction) {
  if (instruction.accounts.length < 5) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      config: getNextAccount(),
      feeTier: getNextAccount(),
      funder: getNextAccount(),
      feeAuthority: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getInitializeFeeTierInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/initializePool.ts
var import_web336 = require("@solana/web3.js");
var INITIALIZE_POOL_DISCRIMINATOR = new Uint8Array([
  95,
  180,
  10,
  172,
  84,
  174,
  232,
  40
]);
function getInitializePoolDiscriminatorBytes() {
  return (0, import_web336.fixEncoderSize)((0, import_web336.getBytesEncoder)(), 8).encode(
    INITIALIZE_POOL_DISCRIMINATOR
  );
}
function getInitializePoolInstructionDataEncoder() {
  return (0, import_web336.transformEncoder)(
    (0, import_web336.getStructEncoder)([
      ["discriminator", (0, import_web336.fixEncoderSize)((0, import_web336.getBytesEncoder)(), 8)],
      ["whirlpoolBump", (0, import_web336.getU8Encoder)()],
      ["tickSpacing", (0, import_web336.getU16Encoder)()],
      ["initialSqrtPrice", (0, import_web336.getU128Encoder)()]
    ]),
    (value) => ({ ...value, discriminator: INITIALIZE_POOL_DISCRIMINATOR })
  );
}
function getInitializePoolInstructionDataDecoder() {
  return (0, import_web336.getStructDecoder)([
    ["discriminator", (0, import_web336.fixDecoderSize)((0, import_web336.getBytesDecoder)(), 8)],
    ["whirlpoolBump", (0, import_web336.getU8Decoder)()],
    ["tickSpacing", (0, import_web336.getU16Decoder)()],
    ["initialSqrtPrice", (0, import_web336.getU128Decoder)()]
  ]);
}
function getInitializePoolInstructionDataCodec() {
  return (0, import_web336.combineCodec)(
    getInitializePoolInstructionDataEncoder(),
    getInitializePoolInstructionDataDecoder()
  );
}
function getInitializePoolInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },
    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },
    funder: { value: input.funder ?? null, isWritable: true },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    feeTier: { value: input.feeTier ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.tokenMintA),
      getAccountMeta(accounts.tokenMintB),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.feeTier),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent)
    ],
    programAddress,
    data: getInitializePoolInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializePoolInstruction(instruction) {
  if (instruction.accounts.length < 11) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      tokenMintA: getNextAccount(),
      tokenMintB: getNextAccount(),
      funder: getNextAccount(),
      whirlpool: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenVaultB: getNextAccount(),
      feeTier: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount()
    },
    data: getInitializePoolInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/initializePoolV2.ts
var import_web337 = require("@solana/web3.js");
var INITIALIZE_POOL_V2_DISCRIMINATOR = new Uint8Array([
  207,
  45,
  87,
  242,
  27,
  63,
  204,
  67
]);
function getInitializePoolV2DiscriminatorBytes() {
  return (0, import_web337.fixEncoderSize)((0, import_web337.getBytesEncoder)(), 8).encode(
    INITIALIZE_POOL_V2_DISCRIMINATOR
  );
}
function getInitializePoolV2InstructionDataEncoder() {
  return (0, import_web337.transformEncoder)(
    (0, import_web337.getStructEncoder)([
      ["discriminator", (0, import_web337.fixEncoderSize)((0, import_web337.getBytesEncoder)(), 8)],
      ["tickSpacing", (0, import_web337.getU16Encoder)()],
      ["initialSqrtPrice", (0, import_web337.getU128Encoder)()]
    ]),
    (value) => ({ ...value, discriminator: INITIALIZE_POOL_V2_DISCRIMINATOR })
  );
}
function getInitializePoolV2InstructionDataDecoder() {
  return (0, import_web337.getStructDecoder)([
    ["discriminator", (0, import_web337.fixDecoderSize)((0, import_web337.getBytesDecoder)(), 8)],
    ["tickSpacing", (0, import_web337.getU16Decoder)()],
    ["initialSqrtPrice", (0, import_web337.getU128Decoder)()]
  ]);
}
function getInitializePoolV2InstructionDataCodec() {
  return (0, import_web337.combineCodec)(
    getInitializePoolV2InstructionDataEncoder(),
    getInitializePoolV2InstructionDataDecoder()
  );
}
function getInitializePoolV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },
    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },
    tokenBadgeA: { value: input.tokenBadgeA ?? null, isWritable: false },
    tokenBadgeB: { value: input.tokenBadgeB ?? null, isWritable: false },
    funder: { value: input.funder ?? null, isWritable: true },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    feeTier: { value: input.feeTier ?? null, isWritable: false },
    tokenProgramA: { value: input.tokenProgramA ?? null, isWritable: false },
    tokenProgramB: { value: input.tokenProgramB ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.tokenMintA),
      getAccountMeta(accounts.tokenMintB),
      getAccountMeta(accounts.tokenBadgeA),
      getAccountMeta(accounts.tokenBadgeB),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.feeTier),
      getAccountMeta(accounts.tokenProgramA),
      getAccountMeta(accounts.tokenProgramB),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent)
    ],
    programAddress,
    data: getInitializePoolV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializePoolV2Instruction(instruction) {
  if (instruction.accounts.length < 14) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      tokenMintA: getNextAccount(),
      tokenMintB: getNextAccount(),
      tokenBadgeA: getNextAccount(),
      tokenBadgeB: getNextAccount(),
      funder: getNextAccount(),
      whirlpool: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenVaultB: getNextAccount(),
      feeTier: getNextAccount(),
      tokenProgramA: getNextAccount(),
      tokenProgramB: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount()
    },
    data: getInitializePoolV2InstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/initializePositionBundle.ts
var import_web338 = require("@solana/web3.js");
var INITIALIZE_POSITION_BUNDLE_DISCRIMINATOR = new Uint8Array([
  117,
  45,
  241,
  149,
  24,
  18,
  194,
  65
]);
function getInitializePositionBundleDiscriminatorBytes() {
  return (0, import_web338.fixEncoderSize)((0, import_web338.getBytesEncoder)(), 8).encode(
    INITIALIZE_POSITION_BUNDLE_DISCRIMINATOR
  );
}
function getInitializePositionBundleInstructionDataEncoder() {
  return (0, import_web338.transformEncoder)(
    (0, import_web338.getStructEncoder)([["discriminator", (0, import_web338.fixEncoderSize)((0, import_web338.getBytesEncoder)(), 8)]]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_POSITION_BUNDLE_DISCRIMINATOR
    })
  );
}
function getInitializePositionBundleInstructionDataDecoder() {
  return (0, import_web338.getStructDecoder)([
    ["discriminator", (0, import_web338.fixDecoderSize)((0, import_web338.getBytesDecoder)(), 8)]
  ]);
}
function getInitializePositionBundleInstructionDataCodec() {
  return (0, import_web338.combineCodec)(
    getInitializePositionBundleInstructionDataEncoder(),
    getInitializePositionBundleInstructionDataDecoder()
  );
}
function getInitializePositionBundleInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    positionBundle: { value: input.positionBundle ?? null, isWritable: true },
    positionBundleMint: {
      value: input.positionBundleMint ?? null,
      isWritable: true
    },
    positionBundleTokenAccount: {
      value: input.positionBundleTokenAccount ?? null,
      isWritable: true
    },
    positionBundleOwner: {
      value: input.positionBundleOwner ?? null,
      isWritable: false
    },
    funder: { value: input.funder ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.positionBundle),
      getAccountMeta(accounts.positionBundleMint),
      getAccountMeta(accounts.positionBundleTokenAccount),
      getAccountMeta(accounts.positionBundleOwner),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent),
      getAccountMeta(accounts.associatedTokenProgram)
    ],
    programAddress,
    data: getInitializePositionBundleInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseInitializePositionBundleInstruction(instruction) {
  if (instruction.accounts.length < 9) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      positionBundle: getNextAccount(),
      positionBundleMint: getNextAccount(),
      positionBundleTokenAccount: getNextAccount(),
      positionBundleOwner: getNextAccount(),
      funder: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount(),
      associatedTokenProgram: getNextAccount()
    },
    data: getInitializePositionBundleInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/initializePositionBundleWithMetadata.ts
var import_web339 = require("@solana/web3.js");
var INITIALIZE_POSITION_BUNDLE_WITH_METADATA_DISCRIMINATOR = new Uint8Array([93, 124, 16, 179, 249, 131, 115, 245]);
function getInitializePositionBundleWithMetadataDiscriminatorBytes() {
  return (0, import_web339.fixEncoderSize)((0, import_web339.getBytesEncoder)(), 8).encode(
    INITIALIZE_POSITION_BUNDLE_WITH_METADATA_DISCRIMINATOR
  );
}
function getInitializePositionBundleWithMetadataInstructionDataEncoder() {
  return (0, import_web339.transformEncoder)(
    (0, import_web339.getStructEncoder)([["discriminator", (0, import_web339.fixEncoderSize)((0, import_web339.getBytesEncoder)(), 8)]]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_POSITION_BUNDLE_WITH_METADATA_DISCRIMINATOR
    })
  );
}
function getInitializePositionBundleWithMetadataInstructionDataDecoder() {
  return (0, import_web339.getStructDecoder)([
    ["discriminator", (0, import_web339.fixDecoderSize)((0, import_web339.getBytesDecoder)(), 8)]
  ]);
}
function getInitializePositionBundleWithMetadataInstructionDataCodec() {
  return (0, import_web339.combineCodec)(
    getInitializePositionBundleWithMetadataInstructionDataEncoder(),
    getInitializePositionBundleWithMetadataInstructionDataDecoder()
  );
}
function getInitializePositionBundleWithMetadataInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    positionBundle: { value: input.positionBundle ?? null, isWritable: true },
    positionBundleMint: {
      value: input.positionBundleMint ?? null,
      isWritable: true
    },
    positionBundleMetadata: {
      value: input.positionBundleMetadata ?? null,
      isWritable: true
    },
    positionBundleTokenAccount: {
      value: input.positionBundleTokenAccount ?? null,
      isWritable: true
    },
    positionBundleOwner: {
      value: input.positionBundleOwner ?? null,
      isWritable: false
    },
    funder: { value: input.funder ?? null, isWritable: true },
    metadataUpdateAuth: {
      value: input.metadataUpdateAuth ?? null,
      isWritable: false
    },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false
    },
    metadataProgram: {
      value: input.metadataProgram ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.positionBundle),
      getAccountMeta(accounts.positionBundleMint),
      getAccountMeta(accounts.positionBundleMetadata),
      getAccountMeta(accounts.positionBundleTokenAccount),
      getAccountMeta(accounts.positionBundleOwner),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.metadataUpdateAuth),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent),
      getAccountMeta(accounts.associatedTokenProgram),
      getAccountMeta(accounts.metadataProgram)
    ],
    programAddress,
    data: getInitializePositionBundleWithMetadataInstructionDataEncoder().encode(
      {}
    )
  };
  return instruction;
}
function parseInitializePositionBundleWithMetadataInstruction(instruction) {
  if (instruction.accounts.length < 12) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      positionBundle: getNextAccount(),
      positionBundleMint: getNextAccount(),
      positionBundleMetadata: getNextAccount(),
      positionBundleTokenAccount: getNextAccount(),
      positionBundleOwner: getNextAccount(),
      funder: getNextAccount(),
      metadataUpdateAuth: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount(),
      associatedTokenProgram: getNextAccount(),
      metadataProgram: getNextAccount()
    },
    data: getInitializePositionBundleWithMetadataInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/initializeReward.ts
var import_web340 = require("@solana/web3.js");
var INITIALIZE_REWARD_DISCRIMINATOR = new Uint8Array([
  95,
  135,
  192,
  196,
  242,
  129,
  230,
  68
]);
function getInitializeRewardDiscriminatorBytes() {
  return (0, import_web340.fixEncoderSize)((0, import_web340.getBytesEncoder)(), 8).encode(
    INITIALIZE_REWARD_DISCRIMINATOR
  );
}
function getInitializeRewardInstructionDataEncoder() {
  return (0, import_web340.transformEncoder)(
    (0, import_web340.getStructEncoder)([
      ["discriminator", (0, import_web340.fixEncoderSize)((0, import_web340.getBytesEncoder)(), 8)],
      ["rewardIndex", (0, import_web340.getU8Encoder)()]
    ]),
    (value) => ({ ...value, discriminator: INITIALIZE_REWARD_DISCRIMINATOR })
  );
}
function getInitializeRewardInstructionDataDecoder() {
  return (0, import_web340.getStructDecoder)([
    ["discriminator", (0, import_web340.fixDecoderSize)((0, import_web340.getBytesDecoder)(), 8)],
    ["rewardIndex", (0, import_web340.getU8Decoder)()]
  ]);
}
function getInitializeRewardInstructionDataCodec() {
  return (0, import_web340.combineCodec)(
    getInitializeRewardInstructionDataEncoder(),
    getInitializeRewardInstructionDataDecoder()
  );
}
function getInitializeRewardInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    rewardAuthority: {
      value: input.rewardAuthority ?? null,
      isWritable: false
    },
    funder: { value: input.funder ?? null, isWritable: true },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    rewardMint: { value: input.rewardMint ?? null, isWritable: false },
    rewardVault: { value: input.rewardVault ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.rewardAuthority),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.rewardMint),
      getAccountMeta(accounts.rewardVault),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent)
    ],
    programAddress,
    data: getInitializeRewardInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeRewardInstruction(instruction) {
  if (instruction.accounts.length < 8) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      rewardAuthority: getNextAccount(),
      funder: getNextAccount(),
      whirlpool: getNextAccount(),
      rewardMint: getNextAccount(),
      rewardVault: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount()
    },
    data: getInitializeRewardInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/initializeRewardV2.ts
var import_web341 = require("@solana/web3.js");
var INITIALIZE_REWARD_V2_DISCRIMINATOR = new Uint8Array([
  91,
  1,
  77,
  50,
  235,
  229,
  133,
  49
]);
function getInitializeRewardV2DiscriminatorBytes() {
  return (0, import_web341.fixEncoderSize)((0, import_web341.getBytesEncoder)(), 8).encode(
    INITIALIZE_REWARD_V2_DISCRIMINATOR
  );
}
function getInitializeRewardV2InstructionDataEncoder() {
  return (0, import_web341.transformEncoder)(
    (0, import_web341.getStructEncoder)([
      ["discriminator", (0, import_web341.fixEncoderSize)((0, import_web341.getBytesEncoder)(), 8)],
      ["rewardIndex", (0, import_web341.getU8Encoder)()]
    ]),
    (value) => ({ ...value, discriminator: INITIALIZE_REWARD_V2_DISCRIMINATOR })
  );
}
function getInitializeRewardV2InstructionDataDecoder() {
  return (0, import_web341.getStructDecoder)([
    ["discriminator", (0, import_web341.fixDecoderSize)((0, import_web341.getBytesDecoder)(), 8)],
    ["rewardIndex", (0, import_web341.getU8Decoder)()]
  ]);
}
function getInitializeRewardV2InstructionDataCodec() {
  return (0, import_web341.combineCodec)(
    getInitializeRewardV2InstructionDataEncoder(),
    getInitializeRewardV2InstructionDataDecoder()
  );
}
function getInitializeRewardV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    rewardAuthority: {
      value: input.rewardAuthority ?? null,
      isWritable: false
    },
    funder: { value: input.funder ?? null, isWritable: true },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    rewardMint: { value: input.rewardMint ?? null, isWritable: false },
    rewardTokenBadge: {
      value: input.rewardTokenBadge ?? null,
      isWritable: false
    },
    rewardVault: { value: input.rewardVault ?? null, isWritable: true },
    rewardTokenProgram: {
      value: input.rewardTokenProgram ?? null,
      isWritable: false
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.rewardAuthority),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.rewardMint),
      getAccountMeta(accounts.rewardTokenBadge),
      getAccountMeta(accounts.rewardVault),
      getAccountMeta(accounts.rewardTokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent)
    ],
    programAddress,
    data: getInitializeRewardV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeRewardV2Instruction(instruction) {
  if (instruction.accounts.length < 9) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      rewardAuthority: getNextAccount(),
      funder: getNextAccount(),
      whirlpool: getNextAccount(),
      rewardMint: getNextAccount(),
      rewardTokenBadge: getNextAccount(),
      rewardVault: getNextAccount(),
      rewardTokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount()
    },
    data: getInitializeRewardV2InstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/initializeTickArray.ts
var import_web342 = require("@solana/web3.js");
var INITIALIZE_TICK_ARRAY_DISCRIMINATOR = new Uint8Array([
  11,
  188,
  193,
  214,
  141,
  91,
  149,
  184
]);
function getInitializeTickArrayDiscriminatorBytes() {
  return (0, import_web342.fixEncoderSize)((0, import_web342.getBytesEncoder)(), 8).encode(
    INITIALIZE_TICK_ARRAY_DISCRIMINATOR
  );
}
function getInitializeTickArrayInstructionDataEncoder() {
  return (0, import_web342.transformEncoder)(
    (0, import_web342.getStructEncoder)([
      ["discriminator", (0, import_web342.fixEncoderSize)((0, import_web342.getBytesEncoder)(), 8)],
      ["startTickIndex", (0, import_web342.getI32Encoder)()]
    ]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_TICK_ARRAY_DISCRIMINATOR
    })
  );
}
function getInitializeTickArrayInstructionDataDecoder() {
  return (0, import_web342.getStructDecoder)([
    ["discriminator", (0, import_web342.fixDecoderSize)((0, import_web342.getBytesDecoder)(), 8)],
    ["startTickIndex", (0, import_web342.getI32Decoder)()]
  ]);
}
function getInitializeTickArrayInstructionDataCodec() {
  return (0, import_web342.combineCodec)(
    getInitializeTickArrayInstructionDataEncoder(),
    getInitializeTickArrayInstructionDataDecoder()
  );
}
function getInitializeTickArrayInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    funder: { value: input.funder ?? null, isWritable: true },
    tickArray: { value: input.tickArray ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.tickArray),
      getAccountMeta(accounts.systemProgram)
    ],
    programAddress,
    data: getInitializeTickArrayInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeTickArrayInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      funder: getNextAccount(),
      tickArray: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getInitializeTickArrayInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/initializeTokenBadge.ts
var import_web343 = require("@solana/web3.js");
var INITIALIZE_TOKEN_BADGE_DISCRIMINATOR = new Uint8Array([
  253,
  77,
  205,
  95,
  27,
  224,
  89,
  223
]);
function getInitializeTokenBadgeDiscriminatorBytes() {
  return (0, import_web343.fixEncoderSize)((0, import_web343.getBytesEncoder)(), 8).encode(
    INITIALIZE_TOKEN_BADGE_DISCRIMINATOR
  );
}
function getInitializeTokenBadgeInstructionDataEncoder() {
  return (0, import_web343.transformEncoder)(
    (0, import_web343.getStructEncoder)([["discriminator", (0, import_web343.fixEncoderSize)((0, import_web343.getBytesEncoder)(), 8)]]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_TOKEN_BADGE_DISCRIMINATOR
    })
  );
}
function getInitializeTokenBadgeInstructionDataDecoder() {
  return (0, import_web343.getStructDecoder)([
    ["discriminator", (0, import_web343.fixDecoderSize)((0, import_web343.getBytesDecoder)(), 8)]
  ]);
}
function getInitializeTokenBadgeInstructionDataCodec() {
  return (0, import_web343.combineCodec)(
    getInitializeTokenBadgeInstructionDataEncoder(),
    getInitializeTokenBadgeInstructionDataDecoder()
  );
}
function getInitializeTokenBadgeInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    whirlpoolsConfigExtension: {
      value: input.whirlpoolsConfigExtension ?? null,
      isWritable: false
    },
    tokenBadgeAuthority: {
      value: input.tokenBadgeAuthority ?? null,
      isWritable: false
    },
    tokenMint: { value: input.tokenMint ?? null, isWritable: false },
    tokenBadge: { value: input.tokenBadge ?? null, isWritable: true },
    funder: { value: input.funder ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.whirlpoolsConfigExtension),
      getAccountMeta(accounts.tokenBadgeAuthority),
      getAccountMeta(accounts.tokenMint),
      getAccountMeta(accounts.tokenBadge),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.systemProgram)
    ],
    programAddress,
    data: getInitializeTokenBadgeInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseInitializeTokenBadgeInstruction(instruction) {
  if (instruction.accounts.length < 7) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      whirlpoolsConfigExtension: getNextAccount(),
      tokenBadgeAuthority: getNextAccount(),
      tokenMint: getNextAccount(),
      tokenBadge: getNextAccount(),
      funder: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getInitializeTokenBadgeInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/openBundledPosition.ts
var import_web344 = require("@solana/web3.js");
var OPEN_BUNDLED_POSITION_DISCRIMINATOR = new Uint8Array([
  169,
  113,
  126,
  171,
  213,
  172,
  212,
  49
]);
function getOpenBundledPositionDiscriminatorBytes() {
  return (0, import_web344.fixEncoderSize)((0, import_web344.getBytesEncoder)(), 8).encode(
    OPEN_BUNDLED_POSITION_DISCRIMINATOR
  );
}
function getOpenBundledPositionInstructionDataEncoder() {
  return (0, import_web344.transformEncoder)(
    (0, import_web344.getStructEncoder)([
      ["discriminator", (0, import_web344.fixEncoderSize)((0, import_web344.getBytesEncoder)(), 8)],
      ["bundleIndex", (0, import_web344.getU16Encoder)()],
      ["tickLowerIndex", (0, import_web344.getI32Encoder)()],
      ["tickUpperIndex", (0, import_web344.getI32Encoder)()]
    ]),
    (value) => ({
      ...value,
      discriminator: OPEN_BUNDLED_POSITION_DISCRIMINATOR
    })
  );
}
function getOpenBundledPositionInstructionDataDecoder() {
  return (0, import_web344.getStructDecoder)([
    ["discriminator", (0, import_web344.fixDecoderSize)((0, import_web344.getBytesDecoder)(), 8)],
    ["bundleIndex", (0, import_web344.getU16Decoder)()],
    ["tickLowerIndex", (0, import_web344.getI32Decoder)()],
    ["tickUpperIndex", (0, import_web344.getI32Decoder)()]
  ]);
}
function getOpenBundledPositionInstructionDataCodec() {
  return (0, import_web344.combineCodec)(
    getOpenBundledPositionInstructionDataEncoder(),
    getOpenBundledPositionInstructionDataDecoder()
  );
}
function getOpenBundledPositionInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    bundledPosition: { value: input.bundledPosition ?? null, isWritable: true },
    positionBundle: { value: input.positionBundle ?? null, isWritable: true },
    positionBundleTokenAccount: {
      value: input.positionBundleTokenAccount ?? null,
      isWritable: false
    },
    positionBundleAuthority: {
      value: input.positionBundleAuthority ?? null,
      isWritable: false
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    funder: { value: input.funder ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.bundledPosition),
      getAccountMeta(accounts.positionBundle),
      getAccountMeta(accounts.positionBundleTokenAccount),
      getAccountMeta(accounts.positionBundleAuthority),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent)
    ],
    programAddress,
    data: getOpenBundledPositionInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseOpenBundledPositionInstruction(instruction) {
  if (instruction.accounts.length < 8) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      bundledPosition: getNextAccount(),
      positionBundle: getNextAccount(),
      positionBundleTokenAccount: getNextAccount(),
      positionBundleAuthority: getNextAccount(),
      whirlpool: getNextAccount(),
      funder: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount()
    },
    data: getOpenBundledPositionInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/openPosition.ts
var import_web345 = require("@solana/web3.js");
var OPEN_POSITION_DISCRIMINATOR = new Uint8Array([
  135,
  128,
  47,
  77,
  15,
  152,
  240,
  49
]);
function getOpenPositionDiscriminatorBytes() {
  return (0, import_web345.fixEncoderSize)((0, import_web345.getBytesEncoder)(), 8).encode(
    OPEN_POSITION_DISCRIMINATOR
  );
}
function getOpenPositionInstructionDataEncoder() {
  return (0, import_web345.transformEncoder)(
    (0, import_web345.getStructEncoder)([
      ["discriminator", (0, import_web345.fixEncoderSize)((0, import_web345.getBytesEncoder)(), 8)],
      ["positionBump", (0, import_web345.getU8Encoder)()],
      ["tickLowerIndex", (0, import_web345.getI32Encoder)()],
      ["tickUpperIndex", (0, import_web345.getI32Encoder)()]
    ]),
    (value) => ({ ...value, discriminator: OPEN_POSITION_DISCRIMINATOR })
  );
}
function getOpenPositionInstructionDataDecoder() {
  return (0, import_web345.getStructDecoder)([
    ["discriminator", (0, import_web345.fixDecoderSize)((0, import_web345.getBytesDecoder)(), 8)],
    ["positionBump", (0, import_web345.getU8Decoder)()],
    ["tickLowerIndex", (0, import_web345.getI32Decoder)()],
    ["tickUpperIndex", (0, import_web345.getI32Decoder)()]
  ]);
}
function getOpenPositionInstructionDataCodec() {
  return (0, import_web345.combineCodec)(
    getOpenPositionInstructionDataEncoder(),
    getOpenPositionInstructionDataDecoder()
  );
}
function getOpenPositionInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    funder: { value: input.funder ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: false },
    position: { value: input.position ?? null, isWritable: true },
    positionMint: { value: input.positionMint ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: true
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionMint),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent),
      getAccountMeta(accounts.associatedTokenProgram)
    ],
    programAddress,
    data: getOpenPositionInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseOpenPositionInstruction(instruction) {
  if (instruction.accounts.length < 10) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      funder: getNextAccount(),
      owner: getNextAccount(),
      position: getNextAccount(),
      positionMint: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      whirlpool: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount(),
      associatedTokenProgram: getNextAccount()
    },
    data: getOpenPositionInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/openPositionWithMetadata.ts
var import_web346 = require("@solana/web3.js");
var OPEN_POSITION_WITH_METADATA_DISCRIMINATOR = new Uint8Array([
  242,
  29,
  134,
  48,
  58,
  110,
  14,
  60
]);
function getOpenPositionWithMetadataDiscriminatorBytes() {
  return (0, import_web346.fixEncoderSize)((0, import_web346.getBytesEncoder)(), 8).encode(
    OPEN_POSITION_WITH_METADATA_DISCRIMINATOR
  );
}
function getOpenPositionWithMetadataInstructionDataEncoder() {
  return (0, import_web346.transformEncoder)(
    (0, import_web346.getStructEncoder)([
      ["discriminator", (0, import_web346.fixEncoderSize)((0, import_web346.getBytesEncoder)(), 8)],
      ["positionBump", (0, import_web346.getU8Encoder)()],
      ["metadataBump", (0, import_web346.getU8Encoder)()],
      ["tickLowerIndex", (0, import_web346.getI32Encoder)()],
      ["tickUpperIndex", (0, import_web346.getI32Encoder)()]
    ]),
    (value) => ({
      ...value,
      discriminator: OPEN_POSITION_WITH_METADATA_DISCRIMINATOR
    })
  );
}
function getOpenPositionWithMetadataInstructionDataDecoder() {
  return (0, import_web346.getStructDecoder)([
    ["discriminator", (0, import_web346.fixDecoderSize)((0, import_web346.getBytesDecoder)(), 8)],
    ["positionBump", (0, import_web346.getU8Decoder)()],
    ["metadataBump", (0, import_web346.getU8Decoder)()],
    ["tickLowerIndex", (0, import_web346.getI32Decoder)()],
    ["tickUpperIndex", (0, import_web346.getI32Decoder)()]
  ]);
}
function getOpenPositionWithMetadataInstructionDataCodec() {
  return (0, import_web346.combineCodec)(
    getOpenPositionWithMetadataInstructionDataEncoder(),
    getOpenPositionWithMetadataInstructionDataDecoder()
  );
}
function getOpenPositionWithMetadataInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    funder: { value: input.funder ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: false },
    position: { value: input.position ?? null, isWritable: true },
    positionMint: { value: input.positionMint ?? null, isWritable: true },
    positionMetadataAccount: {
      value: input.positionMetadataAccount ?? null,
      isWritable: true
    },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: true
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false
    },
    metadataProgram: {
      value: input.metadataProgram ?? null,
      isWritable: false
    },
    metadataUpdateAuth: {
      value: input.metadataUpdateAuth ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionMint),
      getAccountMeta(accounts.positionMetadataAccount),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.rent),
      getAccountMeta(accounts.associatedTokenProgram),
      getAccountMeta(accounts.metadataProgram),
      getAccountMeta(accounts.metadataUpdateAuth)
    ],
    programAddress,
    data: getOpenPositionWithMetadataInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseOpenPositionWithMetadataInstruction(instruction) {
  if (instruction.accounts.length < 13) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      funder: getNextAccount(),
      owner: getNextAccount(),
      position: getNextAccount(),
      positionMint: getNextAccount(),
      positionMetadataAccount: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      whirlpool: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      rent: getNextAccount(),
      associatedTokenProgram: getNextAccount(),
      metadataProgram: getNextAccount(),
      metadataUpdateAuth: getNextAccount()
    },
    data: getOpenPositionWithMetadataInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/openPositionWithTokenExtensions.ts
var import_web347 = require("@solana/web3.js");
var OPEN_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR = new Uint8Array(
  [212, 47, 95, 92, 114, 102, 131, 250]
);
function getOpenPositionWithTokenExtensionsDiscriminatorBytes() {
  return (0, import_web347.fixEncoderSize)((0, import_web347.getBytesEncoder)(), 8).encode(
    OPEN_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR
  );
}
function getOpenPositionWithTokenExtensionsInstructionDataEncoder() {
  return (0, import_web347.transformEncoder)(
    (0, import_web347.getStructEncoder)([
      ["discriminator", (0, import_web347.fixEncoderSize)((0, import_web347.getBytesEncoder)(), 8)],
      ["tickLowerIndex", (0, import_web347.getI32Encoder)()],
      ["tickUpperIndex", (0, import_web347.getI32Encoder)()],
      ["withTokenMetadataExtension", (0, import_web347.getBooleanEncoder)()]
    ]),
    (value) => ({
      ...value,
      discriminator: OPEN_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR
    })
  );
}
function getOpenPositionWithTokenExtensionsInstructionDataDecoder() {
  return (0, import_web347.getStructDecoder)([
    ["discriminator", (0, import_web347.fixDecoderSize)((0, import_web347.getBytesDecoder)(), 8)],
    ["tickLowerIndex", (0, import_web347.getI32Decoder)()],
    ["tickUpperIndex", (0, import_web347.getI32Decoder)()],
    ["withTokenMetadataExtension", (0, import_web347.getBooleanDecoder)()]
  ]);
}
function getOpenPositionWithTokenExtensionsInstructionDataCodec() {
  return (0, import_web347.combineCodec)(
    getOpenPositionWithTokenExtensionsInstructionDataEncoder(),
    getOpenPositionWithTokenExtensionsInstructionDataDecoder()
  );
}
function getOpenPositionWithTokenExtensionsInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    funder: { value: input.funder ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: false },
    position: { value: input.position ?? null, isWritable: true },
    positionMint: { value: input.positionMint ?? null, isWritable: true },
    positionTokenAccount: {
      value: input.positionTokenAccount ?? null,
      isWritable: true
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: false },
    token2022Program: {
      value: input.token2022Program ?? null,
      isWritable: false
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false
    },
    metadataUpdateAuth: {
      value: input.metadataUpdateAuth ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.funder),
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.positionMint),
      getAccountMeta(accounts.positionTokenAccount),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.token2022Program),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.associatedTokenProgram),
      getAccountMeta(accounts.metadataUpdateAuth)
    ],
    programAddress,
    data: getOpenPositionWithTokenExtensionsInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseOpenPositionWithTokenExtensionsInstruction(instruction) {
  if (instruction.accounts.length < 10) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      funder: getNextAccount(),
      owner: getNextAccount(),
      position: getNextAccount(),
      positionMint: getNextAccount(),
      positionTokenAccount: getNextAccount(),
      whirlpool: getNextAccount(),
      token2022Program: getNextAccount(),
      systemProgram: getNextAccount(),
      associatedTokenProgram: getNextAccount(),
      metadataUpdateAuth: getNextAccount()
    },
    data: getOpenPositionWithTokenExtensionsInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setCollectProtocolFeesAuthority.ts
var import_web348 = require("@solana/web3.js");
var SET_COLLECT_PROTOCOL_FEES_AUTHORITY_DISCRIMINATOR = new Uint8Array(
  [34, 150, 93, 244, 139, 225, 233, 67]
);
function getSetCollectProtocolFeesAuthorityDiscriminatorBytes() {
  return (0, import_web348.fixEncoderSize)((0, import_web348.getBytesEncoder)(), 8).encode(
    SET_COLLECT_PROTOCOL_FEES_AUTHORITY_DISCRIMINATOR
  );
}
function getSetCollectProtocolFeesAuthorityInstructionDataEncoder() {
  return (0, import_web348.transformEncoder)(
    (0, import_web348.getStructEncoder)([["discriminator", (0, import_web348.fixEncoderSize)((0, import_web348.getBytesEncoder)(), 8)]]),
    (value) => ({
      ...value,
      discriminator: SET_COLLECT_PROTOCOL_FEES_AUTHORITY_DISCRIMINATOR
    })
  );
}
function getSetCollectProtocolFeesAuthorityInstructionDataDecoder() {
  return (0, import_web348.getStructDecoder)([
    ["discriminator", (0, import_web348.fixDecoderSize)((0, import_web348.getBytesDecoder)(), 8)]
  ]);
}
function getSetCollectProtocolFeesAuthorityInstructionDataCodec() {
  return (0, import_web348.combineCodec)(
    getSetCollectProtocolFeesAuthorityInstructionDataEncoder(),
    getSetCollectProtocolFeesAuthorityInstructionDataDecoder()
  );
}
function getSetCollectProtocolFeesAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: true
    },
    collectProtocolFeesAuthority: {
      value: input.collectProtocolFeesAuthority ?? null,
      isWritable: false
    },
    newCollectProtocolFeesAuthority: {
      value: input.newCollectProtocolFeesAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.collectProtocolFeesAuthority),
      getAccountMeta(accounts.newCollectProtocolFeesAuthority)
    ],
    programAddress,
    data: getSetCollectProtocolFeesAuthorityInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseSetCollectProtocolFeesAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      collectProtocolFeesAuthority: getNextAccount(),
      newCollectProtocolFeesAuthority: getNextAccount()
    },
    data: getSetCollectProtocolFeesAuthorityInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setConfigExtensionAuthority.ts
var import_web349 = require("@solana/web3.js");
var SET_CONFIG_EXTENSION_AUTHORITY_DISCRIMINATOR = new Uint8Array([
  44,
  94,
  241,
  116,
  24,
  188,
  60,
  143
]);
function getSetConfigExtensionAuthorityDiscriminatorBytes() {
  return (0, import_web349.fixEncoderSize)((0, import_web349.getBytesEncoder)(), 8).encode(
    SET_CONFIG_EXTENSION_AUTHORITY_DISCRIMINATOR
  );
}
function getSetConfigExtensionAuthorityInstructionDataEncoder() {
  return (0, import_web349.transformEncoder)(
    (0, import_web349.getStructEncoder)([["discriminator", (0, import_web349.fixEncoderSize)((0, import_web349.getBytesEncoder)(), 8)]]),
    (value) => ({
      ...value,
      discriminator: SET_CONFIG_EXTENSION_AUTHORITY_DISCRIMINATOR
    })
  );
}
function getSetConfigExtensionAuthorityInstructionDataDecoder() {
  return (0, import_web349.getStructDecoder)([
    ["discriminator", (0, import_web349.fixDecoderSize)((0, import_web349.getBytesDecoder)(), 8)]
  ]);
}
function getSetConfigExtensionAuthorityInstructionDataCodec() {
  return (0, import_web349.combineCodec)(
    getSetConfigExtensionAuthorityInstructionDataEncoder(),
    getSetConfigExtensionAuthorityInstructionDataDecoder()
  );
}
function getSetConfigExtensionAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    whirlpoolsConfigExtension: {
      value: input.whirlpoolsConfigExtension ?? null,
      isWritable: true
    },
    configExtensionAuthority: {
      value: input.configExtensionAuthority ?? null,
      isWritable: false
    },
    newConfigExtensionAuthority: {
      value: input.newConfigExtensionAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.whirlpoolsConfigExtension),
      getAccountMeta(accounts.configExtensionAuthority),
      getAccountMeta(accounts.newConfigExtensionAuthority)
    ],
    programAddress,
    data: getSetConfigExtensionAuthorityInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseSetConfigExtensionAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      whirlpoolsConfigExtension: getNextAccount(),
      configExtensionAuthority: getNextAccount(),
      newConfigExtensionAuthority: getNextAccount()
    },
    data: getSetConfigExtensionAuthorityInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setDefaultFeeRate.ts
var import_web350 = require("@solana/web3.js");
var SET_DEFAULT_FEE_RATE_DISCRIMINATOR = new Uint8Array([
  118,
  215,
  214,
  157,
  182,
  229,
  208,
  228
]);
function getSetDefaultFeeRateDiscriminatorBytes() {
  return (0, import_web350.fixEncoderSize)((0, import_web350.getBytesEncoder)(), 8).encode(
    SET_DEFAULT_FEE_RATE_DISCRIMINATOR
  );
}
function getSetDefaultFeeRateInstructionDataEncoder() {
  return (0, import_web350.transformEncoder)(
    (0, import_web350.getStructEncoder)([
      ["discriminator", (0, import_web350.fixEncoderSize)((0, import_web350.getBytesEncoder)(), 8)],
      ["defaultFeeRate", (0, import_web350.getU16Encoder)()]
    ]),
    (value) => ({ ...value, discriminator: SET_DEFAULT_FEE_RATE_DISCRIMINATOR })
  );
}
function getSetDefaultFeeRateInstructionDataDecoder() {
  return (0, import_web350.getStructDecoder)([
    ["discriminator", (0, import_web350.fixDecoderSize)((0, import_web350.getBytesDecoder)(), 8)],
    ["defaultFeeRate", (0, import_web350.getU16Decoder)()]
  ]);
}
function getSetDefaultFeeRateInstructionDataCodec() {
  return (0, import_web350.combineCodec)(
    getSetDefaultFeeRateInstructionDataEncoder(),
    getSetDefaultFeeRateInstructionDataDecoder()
  );
}
function getSetDefaultFeeRateInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    feeTier: { value: input.feeTier ?? null, isWritable: true },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.feeTier),
      getAccountMeta(accounts.feeAuthority)
    ],
    programAddress,
    data: getSetDefaultFeeRateInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetDefaultFeeRateInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      feeTier: getNextAccount(),
      feeAuthority: getNextAccount()
    },
    data: getSetDefaultFeeRateInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/setDefaultProtocolFeeRate.ts
var import_web351 = require("@solana/web3.js");
var SET_DEFAULT_PROTOCOL_FEE_RATE_DISCRIMINATOR = new Uint8Array([
  107,
  205,
  249,
  226,
  151,
  35,
  86,
  0
]);
function getSetDefaultProtocolFeeRateDiscriminatorBytes() {
  return (0, import_web351.fixEncoderSize)((0, import_web351.getBytesEncoder)(), 8).encode(
    SET_DEFAULT_PROTOCOL_FEE_RATE_DISCRIMINATOR
  );
}
function getSetDefaultProtocolFeeRateInstructionDataEncoder() {
  return (0, import_web351.transformEncoder)(
    (0, import_web351.getStructEncoder)([
      ["discriminator", (0, import_web351.fixEncoderSize)((0, import_web351.getBytesEncoder)(), 8)],
      ["defaultProtocolFeeRate", (0, import_web351.getU16Encoder)()]
    ]),
    (value) => ({
      ...value,
      discriminator: SET_DEFAULT_PROTOCOL_FEE_RATE_DISCRIMINATOR
    })
  );
}
function getSetDefaultProtocolFeeRateInstructionDataDecoder() {
  return (0, import_web351.getStructDecoder)([
    ["discriminator", (0, import_web351.fixDecoderSize)((0, import_web351.getBytesDecoder)(), 8)],
    ["defaultProtocolFeeRate", (0, import_web351.getU16Decoder)()]
  ]);
}
function getSetDefaultProtocolFeeRateInstructionDataCodec() {
  return (0, import_web351.combineCodec)(
    getSetDefaultProtocolFeeRateInstructionDataEncoder(),
    getSetDefaultProtocolFeeRateInstructionDataDecoder()
  );
}
function getSetDefaultProtocolFeeRateInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: true
    },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.feeAuthority)
    ],
    programAddress,
    data: getSetDefaultProtocolFeeRateInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetDefaultProtocolFeeRateInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      feeAuthority: getNextAccount()
    },
    data: getSetDefaultProtocolFeeRateInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setFeeAuthority.ts
var import_web352 = require("@solana/web3.js");
var SET_FEE_AUTHORITY_DISCRIMINATOR = new Uint8Array([
  31,
  1,
  50,
  87,
  237,
  101,
  97,
  132
]);
function getSetFeeAuthorityDiscriminatorBytes() {
  return (0, import_web352.fixEncoderSize)((0, import_web352.getBytesEncoder)(), 8).encode(
    SET_FEE_AUTHORITY_DISCRIMINATOR
  );
}
function getSetFeeAuthorityInstructionDataEncoder() {
  return (0, import_web352.transformEncoder)(
    (0, import_web352.getStructEncoder)([["discriminator", (0, import_web352.fixEncoderSize)((0, import_web352.getBytesEncoder)(), 8)]]),
    (value) => ({ ...value, discriminator: SET_FEE_AUTHORITY_DISCRIMINATOR })
  );
}
function getSetFeeAuthorityInstructionDataDecoder() {
  return (0, import_web352.getStructDecoder)([
    ["discriminator", (0, import_web352.fixDecoderSize)((0, import_web352.getBytesDecoder)(), 8)]
  ]);
}
function getSetFeeAuthorityInstructionDataCodec() {
  return (0, import_web352.combineCodec)(
    getSetFeeAuthorityInstructionDataEncoder(),
    getSetFeeAuthorityInstructionDataDecoder()
  );
}
function getSetFeeAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: true
    },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false },
    newFeeAuthority: {
      value: input.newFeeAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.feeAuthority),
      getAccountMeta(accounts.newFeeAuthority)
    ],
    programAddress,
    data: getSetFeeAuthorityInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseSetFeeAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      feeAuthority: getNextAccount(),
      newFeeAuthority: getNextAccount()
    },
    data: getSetFeeAuthorityInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/setFeeRate.ts
var import_web353 = require("@solana/web3.js");
var SET_FEE_RATE_DISCRIMINATOR = new Uint8Array([
  53,
  243,
  137,
  65,
  8,
  140,
  158,
  6
]);
function getSetFeeRateDiscriminatorBytes() {
  return (0, import_web353.fixEncoderSize)((0, import_web353.getBytesEncoder)(), 8).encode(
    SET_FEE_RATE_DISCRIMINATOR
  );
}
function getSetFeeRateInstructionDataEncoder() {
  return (0, import_web353.transformEncoder)(
    (0, import_web353.getStructEncoder)([
      ["discriminator", (0, import_web353.fixEncoderSize)((0, import_web353.getBytesEncoder)(), 8)],
      ["feeRate", (0, import_web353.getU16Encoder)()]
    ]),
    (value) => ({ ...value, discriminator: SET_FEE_RATE_DISCRIMINATOR })
  );
}
function getSetFeeRateInstructionDataDecoder() {
  return (0, import_web353.getStructDecoder)([
    ["discriminator", (0, import_web353.fixDecoderSize)((0, import_web353.getBytesDecoder)(), 8)],
    ["feeRate", (0, import_web353.getU16Decoder)()]
  ]);
}
function getSetFeeRateInstructionDataCodec() {
  return (0, import_web353.combineCodec)(
    getSetFeeRateInstructionDataEncoder(),
    getSetFeeRateInstructionDataDecoder()
  );
}
function getSetFeeRateInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.feeAuthority)
    ],
    programAddress,
    data: getSetFeeRateInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetFeeRateInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      whirlpool: getNextAccount(),
      feeAuthority: getNextAccount()
    },
    data: getSetFeeRateInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/setProtocolFeeRate.ts
var import_web354 = require("@solana/web3.js");
var SET_PROTOCOL_FEE_RATE_DISCRIMINATOR = new Uint8Array([
  95,
  7,
  4,
  50,
  154,
  79,
  156,
  131
]);
function getSetProtocolFeeRateDiscriminatorBytes() {
  return (0, import_web354.fixEncoderSize)((0, import_web354.getBytesEncoder)(), 8).encode(
    SET_PROTOCOL_FEE_RATE_DISCRIMINATOR
  );
}
function getSetProtocolFeeRateInstructionDataEncoder() {
  return (0, import_web354.transformEncoder)(
    (0, import_web354.getStructEncoder)([
      ["discriminator", (0, import_web354.fixEncoderSize)((0, import_web354.getBytesEncoder)(), 8)],
      ["protocolFeeRate", (0, import_web354.getU16Encoder)()]
    ]),
    (value) => ({
      ...value,
      discriminator: SET_PROTOCOL_FEE_RATE_DISCRIMINATOR
    })
  );
}
function getSetProtocolFeeRateInstructionDataDecoder() {
  return (0, import_web354.getStructDecoder)([
    ["discriminator", (0, import_web354.fixDecoderSize)((0, import_web354.getBytesDecoder)(), 8)],
    ["protocolFeeRate", (0, import_web354.getU16Decoder)()]
  ]);
}
function getSetProtocolFeeRateInstructionDataCodec() {
  return (0, import_web354.combineCodec)(
    getSetProtocolFeeRateInstructionDataEncoder(),
    getSetProtocolFeeRateInstructionDataDecoder()
  );
}
function getSetProtocolFeeRateInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    feeAuthority: { value: input.feeAuthority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.feeAuthority)
    ],
    programAddress,
    data: getSetProtocolFeeRateInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetProtocolFeeRateInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      whirlpool: getNextAccount(),
      feeAuthority: getNextAccount()
    },
    data: getSetProtocolFeeRateInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setRewardAuthority.ts
var import_web355 = require("@solana/web3.js");
var SET_REWARD_AUTHORITY_DISCRIMINATOR = new Uint8Array([
  34,
  39,
  183,
  252,
  83,
  28,
  85,
  127
]);
function getSetRewardAuthorityDiscriminatorBytes() {
  return (0, import_web355.fixEncoderSize)((0, import_web355.getBytesEncoder)(), 8).encode(
    SET_REWARD_AUTHORITY_DISCRIMINATOR
  );
}
function getSetRewardAuthorityInstructionDataEncoder() {
  return (0, import_web355.transformEncoder)(
    (0, import_web355.getStructEncoder)([
      ["discriminator", (0, import_web355.fixEncoderSize)((0, import_web355.getBytesEncoder)(), 8)],
      ["rewardIndex", (0, import_web355.getU8Encoder)()]
    ]),
    (value) => ({ ...value, discriminator: SET_REWARD_AUTHORITY_DISCRIMINATOR })
  );
}
function getSetRewardAuthorityInstructionDataDecoder() {
  return (0, import_web355.getStructDecoder)([
    ["discriminator", (0, import_web355.fixDecoderSize)((0, import_web355.getBytesDecoder)(), 8)],
    ["rewardIndex", (0, import_web355.getU8Decoder)()]
  ]);
}
function getSetRewardAuthorityInstructionDataCodec() {
  return (0, import_web355.combineCodec)(
    getSetRewardAuthorityInstructionDataEncoder(),
    getSetRewardAuthorityInstructionDataDecoder()
  );
}
function getSetRewardAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    rewardAuthority: {
      value: input.rewardAuthority ?? null,
      isWritable: false
    },
    newRewardAuthority: {
      value: input.newRewardAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.rewardAuthority),
      getAccountMeta(accounts.newRewardAuthority)
    ],
    programAddress,
    data: getSetRewardAuthorityInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetRewardAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      rewardAuthority: getNextAccount(),
      newRewardAuthority: getNextAccount()
    },
    data: getSetRewardAuthorityInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setRewardAuthorityBySuperAuthority.ts
var import_web356 = require("@solana/web3.js");
var SET_REWARD_AUTHORITY_BY_SUPER_AUTHORITY_DISCRIMINATOR = new Uint8Array([240, 154, 201, 198, 148, 93, 56, 25]);
function getSetRewardAuthorityBySuperAuthorityDiscriminatorBytes() {
  return (0, import_web356.fixEncoderSize)((0, import_web356.getBytesEncoder)(), 8).encode(
    SET_REWARD_AUTHORITY_BY_SUPER_AUTHORITY_DISCRIMINATOR
  );
}
function getSetRewardAuthorityBySuperAuthorityInstructionDataEncoder() {
  return (0, import_web356.transformEncoder)(
    (0, import_web356.getStructEncoder)([
      ["discriminator", (0, import_web356.fixEncoderSize)((0, import_web356.getBytesEncoder)(), 8)],
      ["rewardIndex", (0, import_web356.getU8Encoder)()]
    ]),
    (value) => ({
      ...value,
      discriminator: SET_REWARD_AUTHORITY_BY_SUPER_AUTHORITY_DISCRIMINATOR
    })
  );
}
function getSetRewardAuthorityBySuperAuthorityInstructionDataDecoder() {
  return (0, import_web356.getStructDecoder)([
    ["discriminator", (0, import_web356.fixDecoderSize)((0, import_web356.getBytesDecoder)(), 8)],
    ["rewardIndex", (0, import_web356.getU8Decoder)()]
  ]);
}
function getSetRewardAuthorityBySuperAuthorityInstructionDataCodec() {
  return (0, import_web356.combineCodec)(
    getSetRewardAuthorityBySuperAuthorityInstructionDataEncoder(),
    getSetRewardAuthorityBySuperAuthorityInstructionDataDecoder()
  );
}
function getSetRewardAuthorityBySuperAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    rewardEmissionsSuperAuthority: {
      value: input.rewardEmissionsSuperAuthority ?? null,
      isWritable: false
    },
    newRewardAuthority: {
      value: input.newRewardAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.rewardEmissionsSuperAuthority),
      getAccountMeta(accounts.newRewardAuthority)
    ],
    programAddress,
    data: getSetRewardAuthorityBySuperAuthorityInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetRewardAuthorityBySuperAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      whirlpool: getNextAccount(),
      rewardEmissionsSuperAuthority: getNextAccount(),
      newRewardAuthority: getNextAccount()
    },
    data: getSetRewardAuthorityBySuperAuthorityInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setRewardEmissions.ts
var import_web357 = require("@solana/web3.js");
var SET_REWARD_EMISSIONS_DISCRIMINATOR = new Uint8Array([
  13,
  197,
  86,
  168,
  109,
  176,
  27,
  244
]);
function getSetRewardEmissionsDiscriminatorBytes() {
  return (0, import_web357.fixEncoderSize)((0, import_web357.getBytesEncoder)(), 8).encode(
    SET_REWARD_EMISSIONS_DISCRIMINATOR
  );
}
function getSetRewardEmissionsInstructionDataEncoder() {
  return (0, import_web357.transformEncoder)(
    (0, import_web357.getStructEncoder)([
      ["discriminator", (0, import_web357.fixEncoderSize)((0, import_web357.getBytesEncoder)(), 8)],
      ["rewardIndex", (0, import_web357.getU8Encoder)()],
      ["emissionsPerSecondX64", (0, import_web357.getU128Encoder)()]
    ]),
    (value) => ({ ...value, discriminator: SET_REWARD_EMISSIONS_DISCRIMINATOR })
  );
}
function getSetRewardEmissionsInstructionDataDecoder() {
  return (0, import_web357.getStructDecoder)([
    ["discriminator", (0, import_web357.fixDecoderSize)((0, import_web357.getBytesDecoder)(), 8)],
    ["rewardIndex", (0, import_web357.getU8Decoder)()],
    ["emissionsPerSecondX64", (0, import_web357.getU128Decoder)()]
  ]);
}
function getSetRewardEmissionsInstructionDataCodec() {
  return (0, import_web357.combineCodec)(
    getSetRewardEmissionsInstructionDataEncoder(),
    getSetRewardEmissionsInstructionDataDecoder()
  );
}
function getSetRewardEmissionsInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    rewardAuthority: {
      value: input.rewardAuthority ?? null,
      isWritable: false
    },
    rewardVault: { value: input.rewardVault ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.rewardAuthority),
      getAccountMeta(accounts.rewardVault)
    ],
    programAddress,
    data: getSetRewardEmissionsInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetRewardEmissionsInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      rewardAuthority: getNextAccount(),
      rewardVault: getNextAccount()
    },
    data: getSetRewardEmissionsInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setRewardEmissionsSuperAuthority.ts
var import_web358 = require("@solana/web3.js");
var SET_REWARD_EMISSIONS_SUPER_AUTHORITY_DISCRIMINATOR = new Uint8Array([207, 5, 200, 209, 122, 56, 82, 183]);
function getSetRewardEmissionsSuperAuthorityDiscriminatorBytes() {
  return (0, import_web358.fixEncoderSize)((0, import_web358.getBytesEncoder)(), 8).encode(
    SET_REWARD_EMISSIONS_SUPER_AUTHORITY_DISCRIMINATOR
  );
}
function getSetRewardEmissionsSuperAuthorityInstructionDataEncoder() {
  return (0, import_web358.transformEncoder)(
    (0, import_web358.getStructEncoder)([["discriminator", (0, import_web358.fixEncoderSize)((0, import_web358.getBytesEncoder)(), 8)]]),
    (value) => ({
      ...value,
      discriminator: SET_REWARD_EMISSIONS_SUPER_AUTHORITY_DISCRIMINATOR
    })
  );
}
function getSetRewardEmissionsSuperAuthorityInstructionDataDecoder() {
  return (0, import_web358.getStructDecoder)([
    ["discriminator", (0, import_web358.fixDecoderSize)((0, import_web358.getBytesDecoder)(), 8)]
  ]);
}
function getSetRewardEmissionsSuperAuthorityInstructionDataCodec() {
  return (0, import_web358.combineCodec)(
    getSetRewardEmissionsSuperAuthorityInstructionDataEncoder(),
    getSetRewardEmissionsSuperAuthorityInstructionDataDecoder()
  );
}
function getSetRewardEmissionsSuperAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: true
    },
    rewardEmissionsSuperAuthority: {
      value: input.rewardEmissionsSuperAuthority ?? null,
      isWritable: false
    },
    newRewardEmissionsSuperAuthority: {
      value: input.newRewardEmissionsSuperAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.rewardEmissionsSuperAuthority),
      getAccountMeta(accounts.newRewardEmissionsSuperAuthority)
    ],
    programAddress,
    data: getSetRewardEmissionsSuperAuthorityInstructionDataEncoder().encode(
      {}
    )
  };
  return instruction;
}
function parseSetRewardEmissionsSuperAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      rewardEmissionsSuperAuthority: getNextAccount(),
      newRewardEmissionsSuperAuthority: getNextAccount()
    },
    data: getSetRewardEmissionsSuperAuthorityInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setRewardEmissionsV2.ts
var import_web359 = require("@solana/web3.js");
var SET_REWARD_EMISSIONS_V2_DISCRIMINATOR = new Uint8Array([
  114,
  228,
  72,
  32,
  193,
  48,
  160,
  102
]);
function getSetRewardEmissionsV2DiscriminatorBytes() {
  return (0, import_web359.fixEncoderSize)((0, import_web359.getBytesEncoder)(), 8).encode(
    SET_REWARD_EMISSIONS_V2_DISCRIMINATOR
  );
}
function getSetRewardEmissionsV2InstructionDataEncoder() {
  return (0, import_web359.transformEncoder)(
    (0, import_web359.getStructEncoder)([
      ["discriminator", (0, import_web359.fixEncoderSize)((0, import_web359.getBytesEncoder)(), 8)],
      ["rewardIndex", (0, import_web359.getU8Encoder)()],
      ["emissionsPerSecondX64", (0, import_web359.getU128Encoder)()]
    ]),
    (value) => ({
      ...value,
      discriminator: SET_REWARD_EMISSIONS_V2_DISCRIMINATOR
    })
  );
}
function getSetRewardEmissionsV2InstructionDataDecoder() {
  return (0, import_web359.getStructDecoder)([
    ["discriminator", (0, import_web359.fixDecoderSize)((0, import_web359.getBytesDecoder)(), 8)],
    ["rewardIndex", (0, import_web359.getU8Decoder)()],
    ["emissionsPerSecondX64", (0, import_web359.getU128Decoder)()]
  ]);
}
function getSetRewardEmissionsV2InstructionDataCodec() {
  return (0, import_web359.combineCodec)(
    getSetRewardEmissionsV2InstructionDataEncoder(),
    getSetRewardEmissionsV2InstructionDataDecoder()
  );
}
function getSetRewardEmissionsV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    rewardAuthority: {
      value: input.rewardAuthority ?? null,
      isWritable: false
    },
    rewardVault: { value: input.rewardVault ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.rewardAuthority),
      getAccountMeta(accounts.rewardVault)
    ],
    programAddress,
    data: getSetRewardEmissionsV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetRewardEmissionsV2Instruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      rewardAuthority: getNextAccount(),
      rewardVault: getNextAccount()
    },
    data: getSetRewardEmissionsV2InstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/setTokenBadgeAuthority.ts
var import_web360 = require("@solana/web3.js");
var SET_TOKEN_BADGE_AUTHORITY_DISCRIMINATOR = new Uint8Array([
  207,
  202,
  4,
  32,
  205,
  79,
  13,
  178
]);
function getSetTokenBadgeAuthorityDiscriminatorBytes() {
  return (0, import_web360.fixEncoderSize)((0, import_web360.getBytesEncoder)(), 8).encode(
    SET_TOKEN_BADGE_AUTHORITY_DISCRIMINATOR
  );
}
function getSetTokenBadgeAuthorityInstructionDataEncoder() {
  return (0, import_web360.transformEncoder)(
    (0, import_web360.getStructEncoder)([["discriminator", (0, import_web360.fixEncoderSize)((0, import_web360.getBytesEncoder)(), 8)]]),
    (value) => ({
      ...value,
      discriminator: SET_TOKEN_BADGE_AUTHORITY_DISCRIMINATOR
    })
  );
}
function getSetTokenBadgeAuthorityInstructionDataDecoder() {
  return (0, import_web360.getStructDecoder)([
    ["discriminator", (0, import_web360.fixDecoderSize)((0, import_web360.getBytesDecoder)(), 8)]
  ]);
}
function getSetTokenBadgeAuthorityInstructionDataCodec() {
  return (0, import_web360.combineCodec)(
    getSetTokenBadgeAuthorityInstructionDataEncoder(),
    getSetTokenBadgeAuthorityInstructionDataDecoder()
  );
}
function getSetTokenBadgeAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolsConfig: {
      value: input.whirlpoolsConfig ?? null,
      isWritable: false
    },
    whirlpoolsConfigExtension: {
      value: input.whirlpoolsConfigExtension ?? null,
      isWritable: true
    },
    configExtensionAuthority: {
      value: input.configExtensionAuthority ?? null,
      isWritable: false
    },
    newTokenBadgeAuthority: {
      value: input.newTokenBadgeAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolsConfig),
      getAccountMeta(accounts.whirlpoolsConfigExtension),
      getAccountMeta(accounts.configExtensionAuthority),
      getAccountMeta(accounts.newTokenBadgeAuthority)
    ],
    programAddress,
    data: getSetTokenBadgeAuthorityInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseSetTokenBadgeAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolsConfig: getNextAccount(),
      whirlpoolsConfigExtension: getNextAccount(),
      configExtensionAuthority: getNextAccount(),
      newTokenBadgeAuthority: getNextAccount()
    },
    data: getSetTokenBadgeAuthorityInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/generated/instructions/swap.ts
var import_web361 = require("@solana/web3.js");
var SWAP_DISCRIMINATOR = new Uint8Array([
  248,
  198,
  158,
  145,
  225,
  117,
  135,
  200
]);
function getSwapDiscriminatorBytes() {
  return (0, import_web361.fixEncoderSize)((0, import_web361.getBytesEncoder)(), 8).encode(SWAP_DISCRIMINATOR);
}
function getSwapInstructionDataEncoder() {
  return (0, import_web361.transformEncoder)(
    (0, import_web361.getStructEncoder)([
      ["discriminator", (0, import_web361.fixEncoderSize)((0, import_web361.getBytesEncoder)(), 8)],
      ["amount", (0, import_web361.getU64Encoder)()],
      ["otherAmountThreshold", (0, import_web361.getU64Encoder)()],
      ["sqrtPriceLimit", (0, import_web361.getU128Encoder)()],
      ["amountSpecifiedIsInput", (0, import_web361.getBooleanEncoder)()],
      ["aToB", (0, import_web361.getBooleanEncoder)()]
    ]),
    (value) => ({ ...value, discriminator: SWAP_DISCRIMINATOR })
  );
}
function getSwapInstructionDataDecoder() {
  return (0, import_web361.getStructDecoder)([
    ["discriminator", (0, import_web361.fixDecoderSize)((0, import_web361.getBytesDecoder)(), 8)],
    ["amount", (0, import_web361.getU64Decoder)()],
    ["otherAmountThreshold", (0, import_web361.getU64Decoder)()],
    ["sqrtPriceLimit", (0, import_web361.getU128Decoder)()],
    ["amountSpecifiedIsInput", (0, import_web361.getBooleanDecoder)()],
    ["aToB", (0, import_web361.getBooleanDecoder)()]
  ]);
}
function getSwapInstructionDataCodec() {
  return (0, import_web361.combineCodec)(
    getSwapInstructionDataEncoder(),
    getSwapInstructionDataDecoder()
  );
}
function getSwapInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    tokenAuthority: { value: input.tokenAuthority ?? null, isWritable: false },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    tokenOwnerAccountA: {
      value: input.tokenOwnerAccountA ?? null,
      isWritable: true
    },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenOwnerAccountB: {
      value: input.tokenOwnerAccountB ?? null,
      isWritable: true
    },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tickArray0: { value: input.tickArray0 ?? null, isWritable: true },
    tickArray1: { value: input.tickArray1 ?? null, isWritable: true },
    tickArray2: { value: input.tickArray2 ?? null, isWritable: true },
    oracle: { value: input.oracle ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.tokenAuthority),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenOwnerAccountA),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenOwnerAccountB),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tickArray0),
      getAccountMeta(accounts.tickArray1),
      getAccountMeta(accounts.tickArray2),
      getAccountMeta(accounts.oracle)
    ],
    programAddress,
    data: getSwapInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSwapInstruction(instruction) {
  if (instruction.accounts.length < 11) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      tokenProgram: getNextAccount(),
      tokenAuthority: getNextAccount(),
      whirlpool: getNextAccount(),
      tokenOwnerAccountA: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenOwnerAccountB: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tickArray0: getNextAccount(),
      tickArray1: getNextAccount(),
      tickArray2: getNextAccount(),
      oracle: getNextAccount()
    },
    data: getSwapInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/swapV2.ts
var import_web362 = require("@solana/web3.js");
var SWAP_V2_DISCRIMINATOR = new Uint8Array([
  43,
  4,
  237,
  11,
  26,
  201,
  30,
  98
]);
function getSwapV2DiscriminatorBytes() {
  return (0, import_web362.fixEncoderSize)((0, import_web362.getBytesEncoder)(), 8).encode(SWAP_V2_DISCRIMINATOR);
}
function getSwapV2InstructionDataEncoder() {
  return (0, import_web362.transformEncoder)(
    (0, import_web362.getStructEncoder)([
      ["discriminator", (0, import_web362.fixEncoderSize)((0, import_web362.getBytesEncoder)(), 8)],
      ["amount", (0, import_web362.getU64Encoder)()],
      ["otherAmountThreshold", (0, import_web362.getU64Encoder)()],
      ["sqrtPriceLimit", (0, import_web362.getU128Encoder)()],
      ["amountSpecifiedIsInput", (0, import_web362.getBooleanEncoder)()],
      ["aToB", (0, import_web362.getBooleanEncoder)()],
      [
        "remainingAccountsInfo",
        (0, import_web362.getOptionEncoder)(getRemainingAccountsInfoEncoder())
      ]
    ]),
    (value) => ({ ...value, discriminator: SWAP_V2_DISCRIMINATOR })
  );
}
function getSwapV2InstructionDataDecoder() {
  return (0, import_web362.getStructDecoder)([
    ["discriminator", (0, import_web362.fixDecoderSize)((0, import_web362.getBytesDecoder)(), 8)],
    ["amount", (0, import_web362.getU64Decoder)()],
    ["otherAmountThreshold", (0, import_web362.getU64Decoder)()],
    ["sqrtPriceLimit", (0, import_web362.getU128Decoder)()],
    ["amountSpecifiedIsInput", (0, import_web362.getBooleanDecoder)()],
    ["aToB", (0, import_web362.getBooleanDecoder)()],
    [
      "remainingAccountsInfo",
      (0, import_web362.getOptionDecoder)(getRemainingAccountsInfoDecoder())
    ]
  ]);
}
function getSwapV2InstructionDataCodec() {
  return (0, import_web362.combineCodec)(
    getSwapV2InstructionDataEncoder(),
    getSwapV2InstructionDataDecoder()
  );
}
function getSwapV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    tokenProgramA: { value: input.tokenProgramA ?? null, isWritable: false },
    tokenProgramB: { value: input.tokenProgramB ?? null, isWritable: false },
    memoProgram: { value: input.memoProgram ?? null, isWritable: false },
    tokenAuthority: { value: input.tokenAuthority ?? null, isWritable: false },
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    tokenMintA: { value: input.tokenMintA ?? null, isWritable: false },
    tokenMintB: { value: input.tokenMintB ?? null, isWritable: false },
    tokenOwnerAccountA: {
      value: input.tokenOwnerAccountA ?? null,
      isWritable: true
    },
    tokenVaultA: { value: input.tokenVaultA ?? null, isWritable: true },
    tokenOwnerAccountB: {
      value: input.tokenOwnerAccountB ?? null,
      isWritable: true
    },
    tokenVaultB: { value: input.tokenVaultB ?? null, isWritable: true },
    tickArray0: { value: input.tickArray0 ?? null, isWritable: true },
    tickArray1: { value: input.tickArray1 ?? null, isWritable: true },
    tickArray2: { value: input.tickArray2 ?? null, isWritable: true },
    oracle: { value: input.oracle ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.tokenProgramA),
      getAccountMeta(accounts.tokenProgramB),
      getAccountMeta(accounts.memoProgram),
      getAccountMeta(accounts.tokenAuthority),
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.tokenMintA),
      getAccountMeta(accounts.tokenMintB),
      getAccountMeta(accounts.tokenOwnerAccountA),
      getAccountMeta(accounts.tokenVaultA),
      getAccountMeta(accounts.tokenOwnerAccountB),
      getAccountMeta(accounts.tokenVaultB),
      getAccountMeta(accounts.tickArray0),
      getAccountMeta(accounts.tickArray1),
      getAccountMeta(accounts.tickArray2),
      getAccountMeta(accounts.oracle)
    ],
    programAddress,
    data: getSwapV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSwapV2Instruction(instruction) {
  if (instruction.accounts.length < 15) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      tokenProgramA: getNextAccount(),
      tokenProgramB: getNextAccount(),
      memoProgram: getNextAccount(),
      tokenAuthority: getNextAccount(),
      whirlpool: getNextAccount(),
      tokenMintA: getNextAccount(),
      tokenMintB: getNextAccount(),
      tokenOwnerAccountA: getNextAccount(),
      tokenVaultA: getNextAccount(),
      tokenOwnerAccountB: getNextAccount(),
      tokenVaultB: getNextAccount(),
      tickArray0: getNextAccount(),
      tickArray1: getNextAccount(),
      tickArray2: getNextAccount(),
      oracle: getNextAccount()
    },
    data: getSwapV2InstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/twoHopSwap.ts
var import_web363 = require("@solana/web3.js");
var TWO_HOP_SWAP_DISCRIMINATOR = new Uint8Array([
  195,
  96,
  237,
  108,
  68,
  162,
  219,
  230
]);
function getTwoHopSwapDiscriminatorBytes() {
  return (0, import_web363.fixEncoderSize)((0, import_web363.getBytesEncoder)(), 8).encode(
    TWO_HOP_SWAP_DISCRIMINATOR
  );
}
function getTwoHopSwapInstructionDataEncoder() {
  return (0, import_web363.transformEncoder)(
    (0, import_web363.getStructEncoder)([
      ["discriminator", (0, import_web363.fixEncoderSize)((0, import_web363.getBytesEncoder)(), 8)],
      ["amount", (0, import_web363.getU64Encoder)()],
      ["otherAmountThreshold", (0, import_web363.getU64Encoder)()],
      ["amountSpecifiedIsInput", (0, import_web363.getBooleanEncoder)()],
      ["aToBOne", (0, import_web363.getBooleanEncoder)()],
      ["aToBTwo", (0, import_web363.getBooleanEncoder)()],
      ["sqrtPriceLimitOne", (0, import_web363.getU128Encoder)()],
      ["sqrtPriceLimitTwo", (0, import_web363.getU128Encoder)()]
    ]),
    (value) => ({ ...value, discriminator: TWO_HOP_SWAP_DISCRIMINATOR })
  );
}
function getTwoHopSwapInstructionDataDecoder() {
  return (0, import_web363.getStructDecoder)([
    ["discriminator", (0, import_web363.fixDecoderSize)((0, import_web363.getBytesDecoder)(), 8)],
    ["amount", (0, import_web363.getU64Decoder)()],
    ["otherAmountThreshold", (0, import_web363.getU64Decoder)()],
    ["amountSpecifiedIsInput", (0, import_web363.getBooleanDecoder)()],
    ["aToBOne", (0, import_web363.getBooleanDecoder)()],
    ["aToBTwo", (0, import_web363.getBooleanDecoder)()],
    ["sqrtPriceLimitOne", (0, import_web363.getU128Decoder)()],
    ["sqrtPriceLimitTwo", (0, import_web363.getU128Decoder)()]
  ]);
}
function getTwoHopSwapInstructionDataCodec() {
  return (0, import_web363.combineCodec)(
    getTwoHopSwapInstructionDataEncoder(),
    getTwoHopSwapInstructionDataDecoder()
  );
}
function getTwoHopSwapInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    tokenAuthority: { value: input.tokenAuthority ?? null, isWritable: false },
    whirlpoolOne: { value: input.whirlpoolOne ?? null, isWritable: true },
    whirlpoolTwo: { value: input.whirlpoolTwo ?? null, isWritable: true },
    tokenOwnerAccountOneA: {
      value: input.tokenOwnerAccountOneA ?? null,
      isWritable: true
    },
    tokenVaultOneA: { value: input.tokenVaultOneA ?? null, isWritable: true },
    tokenOwnerAccountOneB: {
      value: input.tokenOwnerAccountOneB ?? null,
      isWritable: true
    },
    tokenVaultOneB: { value: input.tokenVaultOneB ?? null, isWritable: true },
    tokenOwnerAccountTwoA: {
      value: input.tokenOwnerAccountTwoA ?? null,
      isWritable: true
    },
    tokenVaultTwoA: { value: input.tokenVaultTwoA ?? null, isWritable: true },
    tokenOwnerAccountTwoB: {
      value: input.tokenOwnerAccountTwoB ?? null,
      isWritable: true
    },
    tokenVaultTwoB: { value: input.tokenVaultTwoB ?? null, isWritable: true },
    tickArrayOne0: { value: input.tickArrayOne0 ?? null, isWritable: true },
    tickArrayOne1: { value: input.tickArrayOne1 ?? null, isWritable: true },
    tickArrayOne2: { value: input.tickArrayOne2 ?? null, isWritable: true },
    tickArrayTwo0: { value: input.tickArrayTwo0 ?? null, isWritable: true },
    tickArrayTwo1: { value: input.tickArrayTwo1 ?? null, isWritable: true },
    tickArrayTwo2: { value: input.tickArrayTwo2 ?? null, isWritable: true },
    oracleOne: { value: input.oracleOne ?? null, isWritable: false },
    oracleTwo: { value: input.oracleTwo ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.tokenAuthority),
      getAccountMeta(accounts.whirlpoolOne),
      getAccountMeta(accounts.whirlpoolTwo),
      getAccountMeta(accounts.tokenOwnerAccountOneA),
      getAccountMeta(accounts.tokenVaultOneA),
      getAccountMeta(accounts.tokenOwnerAccountOneB),
      getAccountMeta(accounts.tokenVaultOneB),
      getAccountMeta(accounts.tokenOwnerAccountTwoA),
      getAccountMeta(accounts.tokenVaultTwoA),
      getAccountMeta(accounts.tokenOwnerAccountTwoB),
      getAccountMeta(accounts.tokenVaultTwoB),
      getAccountMeta(accounts.tickArrayOne0),
      getAccountMeta(accounts.tickArrayOne1),
      getAccountMeta(accounts.tickArrayOne2),
      getAccountMeta(accounts.tickArrayTwo0),
      getAccountMeta(accounts.tickArrayTwo1),
      getAccountMeta(accounts.tickArrayTwo2),
      getAccountMeta(accounts.oracleOne),
      getAccountMeta(accounts.oracleTwo)
    ],
    programAddress,
    data: getTwoHopSwapInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseTwoHopSwapInstruction(instruction) {
  if (instruction.accounts.length < 20) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      tokenProgram: getNextAccount(),
      tokenAuthority: getNextAccount(),
      whirlpoolOne: getNextAccount(),
      whirlpoolTwo: getNextAccount(),
      tokenOwnerAccountOneA: getNextAccount(),
      tokenVaultOneA: getNextAccount(),
      tokenOwnerAccountOneB: getNextAccount(),
      tokenVaultOneB: getNextAccount(),
      tokenOwnerAccountTwoA: getNextAccount(),
      tokenVaultTwoA: getNextAccount(),
      tokenOwnerAccountTwoB: getNextAccount(),
      tokenVaultTwoB: getNextAccount(),
      tickArrayOne0: getNextAccount(),
      tickArrayOne1: getNextAccount(),
      tickArrayOne2: getNextAccount(),
      tickArrayTwo0: getNextAccount(),
      tickArrayTwo1: getNextAccount(),
      tickArrayTwo2: getNextAccount(),
      oracleOne: getNextAccount(),
      oracleTwo: getNextAccount()
    },
    data: getTwoHopSwapInstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/twoHopSwapV2.ts
var import_web364 = require("@solana/web3.js");
var TWO_HOP_SWAP_V2_DISCRIMINATOR = new Uint8Array([
  186,
  143,
  209,
  29,
  254,
  2,
  194,
  117
]);
function getTwoHopSwapV2DiscriminatorBytes() {
  return (0, import_web364.fixEncoderSize)((0, import_web364.getBytesEncoder)(), 8).encode(
    TWO_HOP_SWAP_V2_DISCRIMINATOR
  );
}
function getTwoHopSwapV2InstructionDataEncoder() {
  return (0, import_web364.transformEncoder)(
    (0, import_web364.getStructEncoder)([
      ["discriminator", (0, import_web364.fixEncoderSize)((0, import_web364.getBytesEncoder)(), 8)],
      ["amount", (0, import_web364.getU64Encoder)()],
      ["otherAmountThreshold", (0, import_web364.getU64Encoder)()],
      ["amountSpecifiedIsInput", (0, import_web364.getBooleanEncoder)()],
      ["aToBOne", (0, import_web364.getBooleanEncoder)()],
      ["aToBTwo", (0, import_web364.getBooleanEncoder)()],
      ["sqrtPriceLimitOne", (0, import_web364.getU128Encoder)()],
      ["sqrtPriceLimitTwo", (0, import_web364.getU128Encoder)()],
      [
        "remainingAccountsInfo",
        (0, import_web364.getOptionEncoder)(getRemainingAccountsInfoEncoder())
      ]
    ]),
    (value) => ({ ...value, discriminator: TWO_HOP_SWAP_V2_DISCRIMINATOR })
  );
}
function getTwoHopSwapV2InstructionDataDecoder() {
  return (0, import_web364.getStructDecoder)([
    ["discriminator", (0, import_web364.fixDecoderSize)((0, import_web364.getBytesDecoder)(), 8)],
    ["amount", (0, import_web364.getU64Decoder)()],
    ["otherAmountThreshold", (0, import_web364.getU64Decoder)()],
    ["amountSpecifiedIsInput", (0, import_web364.getBooleanDecoder)()],
    ["aToBOne", (0, import_web364.getBooleanDecoder)()],
    ["aToBTwo", (0, import_web364.getBooleanDecoder)()],
    ["sqrtPriceLimitOne", (0, import_web364.getU128Decoder)()],
    ["sqrtPriceLimitTwo", (0, import_web364.getU128Decoder)()],
    [
      "remainingAccountsInfo",
      (0, import_web364.getOptionDecoder)(getRemainingAccountsInfoDecoder())
    ]
  ]);
}
function getTwoHopSwapV2InstructionDataCodec() {
  return (0, import_web364.combineCodec)(
    getTwoHopSwapV2InstructionDataEncoder(),
    getTwoHopSwapV2InstructionDataDecoder()
  );
}
function getTwoHopSwapV2Instruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpoolOne: { value: input.whirlpoolOne ?? null, isWritable: true },
    whirlpoolTwo: { value: input.whirlpoolTwo ?? null, isWritable: true },
    tokenMintInput: { value: input.tokenMintInput ?? null, isWritable: false },
    tokenMintIntermediate: {
      value: input.tokenMintIntermediate ?? null,
      isWritable: false
    },
    tokenMintOutput: {
      value: input.tokenMintOutput ?? null,
      isWritable: false
    },
    tokenProgramInput: {
      value: input.tokenProgramInput ?? null,
      isWritable: false
    },
    tokenProgramIntermediate: {
      value: input.tokenProgramIntermediate ?? null,
      isWritable: false
    },
    tokenProgramOutput: {
      value: input.tokenProgramOutput ?? null,
      isWritable: false
    },
    tokenOwnerAccountInput: {
      value: input.tokenOwnerAccountInput ?? null,
      isWritable: true
    },
    tokenVaultOneInput: {
      value: input.tokenVaultOneInput ?? null,
      isWritable: true
    },
    tokenVaultOneIntermediate: {
      value: input.tokenVaultOneIntermediate ?? null,
      isWritable: true
    },
    tokenVaultTwoIntermediate: {
      value: input.tokenVaultTwoIntermediate ?? null,
      isWritable: true
    },
    tokenVaultTwoOutput: {
      value: input.tokenVaultTwoOutput ?? null,
      isWritable: true
    },
    tokenOwnerAccountOutput: {
      value: input.tokenOwnerAccountOutput ?? null,
      isWritable: true
    },
    tokenAuthority: { value: input.tokenAuthority ?? null, isWritable: false },
    tickArrayOne0: { value: input.tickArrayOne0 ?? null, isWritable: true },
    tickArrayOne1: { value: input.tickArrayOne1 ?? null, isWritable: true },
    tickArrayOne2: { value: input.tickArrayOne2 ?? null, isWritable: true },
    tickArrayTwo0: { value: input.tickArrayTwo0 ?? null, isWritable: true },
    tickArrayTwo1: { value: input.tickArrayTwo1 ?? null, isWritable: true },
    tickArrayTwo2: { value: input.tickArrayTwo2 ?? null, isWritable: true },
    oracleOne: { value: input.oracleOne ?? null, isWritable: true },
    oracleTwo: { value: input.oracleTwo ?? null, isWritable: true },
    memoProgram: { value: input.memoProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpoolOne),
      getAccountMeta(accounts.whirlpoolTwo),
      getAccountMeta(accounts.tokenMintInput),
      getAccountMeta(accounts.tokenMintIntermediate),
      getAccountMeta(accounts.tokenMintOutput),
      getAccountMeta(accounts.tokenProgramInput),
      getAccountMeta(accounts.tokenProgramIntermediate),
      getAccountMeta(accounts.tokenProgramOutput),
      getAccountMeta(accounts.tokenOwnerAccountInput),
      getAccountMeta(accounts.tokenVaultOneInput),
      getAccountMeta(accounts.tokenVaultOneIntermediate),
      getAccountMeta(accounts.tokenVaultTwoIntermediate),
      getAccountMeta(accounts.tokenVaultTwoOutput),
      getAccountMeta(accounts.tokenOwnerAccountOutput),
      getAccountMeta(accounts.tokenAuthority),
      getAccountMeta(accounts.tickArrayOne0),
      getAccountMeta(accounts.tickArrayOne1),
      getAccountMeta(accounts.tickArrayOne2),
      getAccountMeta(accounts.tickArrayTwo0),
      getAccountMeta(accounts.tickArrayTwo1),
      getAccountMeta(accounts.tickArrayTwo2),
      getAccountMeta(accounts.oracleOne),
      getAccountMeta(accounts.oracleTwo),
      getAccountMeta(accounts.memoProgram)
    ],
    programAddress,
    data: getTwoHopSwapV2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseTwoHopSwapV2Instruction(instruction) {
  if (instruction.accounts.length < 24) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpoolOne: getNextAccount(),
      whirlpoolTwo: getNextAccount(),
      tokenMintInput: getNextAccount(),
      tokenMintIntermediate: getNextAccount(),
      tokenMintOutput: getNextAccount(),
      tokenProgramInput: getNextAccount(),
      tokenProgramIntermediate: getNextAccount(),
      tokenProgramOutput: getNextAccount(),
      tokenOwnerAccountInput: getNextAccount(),
      tokenVaultOneInput: getNextAccount(),
      tokenVaultOneIntermediate: getNextAccount(),
      tokenVaultTwoIntermediate: getNextAccount(),
      tokenVaultTwoOutput: getNextAccount(),
      tokenOwnerAccountOutput: getNextAccount(),
      tokenAuthority: getNextAccount(),
      tickArrayOne0: getNextAccount(),
      tickArrayOne1: getNextAccount(),
      tickArrayOne2: getNextAccount(),
      tickArrayTwo0: getNextAccount(),
      tickArrayTwo1: getNextAccount(),
      tickArrayTwo2: getNextAccount(),
      oracleOne: getNextAccount(),
      oracleTwo: getNextAccount(),
      memoProgram: getNextAccount()
    },
    data: getTwoHopSwapV2InstructionDataDecoder().decode(instruction.data)
  };
}

// src/generated/instructions/updateFeesAndRewards.ts
var import_web365 = require("@solana/web3.js");
var UPDATE_FEES_AND_REWARDS_DISCRIMINATOR = new Uint8Array([
  154,
  230,
  250,
  13,
  236,
  209,
  75,
  223
]);
function getUpdateFeesAndRewardsDiscriminatorBytes() {
  return (0, import_web365.fixEncoderSize)((0, import_web365.getBytesEncoder)(), 8).encode(
    UPDATE_FEES_AND_REWARDS_DISCRIMINATOR
  );
}
function getUpdateFeesAndRewardsInstructionDataEncoder() {
  return (0, import_web365.transformEncoder)(
    (0, import_web365.getStructEncoder)([["discriminator", (0, import_web365.fixEncoderSize)((0, import_web365.getBytesEncoder)(), 8)]]),
    (value) => ({
      ...value,
      discriminator: UPDATE_FEES_AND_REWARDS_DISCRIMINATOR
    })
  );
}
function getUpdateFeesAndRewardsInstructionDataDecoder() {
  return (0, import_web365.getStructDecoder)([
    ["discriminator", (0, import_web365.fixDecoderSize)((0, import_web365.getBytesDecoder)(), 8)]
  ]);
}
function getUpdateFeesAndRewardsInstructionDataCodec() {
  return (0, import_web365.combineCodec)(
    getUpdateFeesAndRewardsInstructionDataEncoder(),
    getUpdateFeesAndRewardsInstructionDataDecoder()
  );
}
function getUpdateFeesAndRewardsInstruction(input, config) {
  const programAddress = config?.programAddress ?? WHIRLPOOL_PROGRAM_ADDRESS;
  const originalAccounts = {
    whirlpool: { value: input.whirlpool ?? null, isWritable: true },
    position: { value: input.position ?? null, isWritable: true },
    tickArrayLower: { value: input.tickArrayLower ?? null, isWritable: false },
    tickArrayUpper: { value: input.tickArrayUpper ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
  const instruction = {
    accounts: [
      getAccountMeta(accounts.whirlpool),
      getAccountMeta(accounts.position),
      getAccountMeta(accounts.tickArrayLower),
      getAccountMeta(accounts.tickArrayUpper)
    ],
    programAddress,
    data: getUpdateFeesAndRewardsInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseUpdateFeesAndRewardsInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      whirlpool: getNextAccount(),
      position: getNextAccount(),
      tickArrayLower: getNextAccount(),
      tickArrayUpper: getNextAccount()
    },
    data: getUpdateFeesAndRewardsInstructionDataDecoder().decode(
      instruction.data
    )
  };
}

// src/gpa/feeTier.ts
var import_web367 = require("@solana/web3.js");

// src/gpa/utils.ts
var import_web366 = require("@solana/web3.js");
async function fetchDecodedProgramAccounts(rpc, programAddress, filters, decoder) {
  const accountInfos = await rpc.getProgramAccounts(programAddress, {
    encoding: "base64",
    filters
  }).send();
  const encoder = (0, import_web366.getBase64Encoder)();
  const datas = accountInfos.map((x) => encoder.encode(x.account.data[0]));
  const decoded = datas.map((x) => decoder.decode(x));
  return decoded.map((data, i) => ({
    ...accountInfos[i].account,
    address: accountInfos[i].pubkey,
    programAddress,
    data
  }));
}

// src/gpa/feeTier.ts
function feeTierWhirlpoolsConfigFilter(address) {
  return {
    memcmp: {
      offset: 8n,
      bytes: (0, import_web367.getBase58Decoder)().decode((0, import_web367.getAddressEncoder)().encode(address)),
      encoding: "base58"
    }
  };
}
function feeTierTickSpacingFilter(tickSpacing) {
  return {
    memcmp: {
      offset: 40n,
      bytes: (0, import_web367.getBase58Decoder)().decode((0, import_web367.getU16Encoder)().encode(tickSpacing)),
      encoding: "base58"
    }
  };
}
function feeTierFeeRateFilter(defaultFeeRate) {
  return {
    memcmp: {
      offset: 42n,
      bytes: (0, import_web367.getBase58Decoder)().decode((0, import_web367.getU16Encoder)().encode(defaultFeeRate)),
      encoding: "base58"
    }
  };
}
async function fetchAllFeeTierWithFilter(rpc, ...filters) {
  const discriminator = (0, import_web367.getBase58Decoder)().decode(FEE_TIER_DISCRIMINATOR);
  const discriminatorFilter = {
    memcmp: {
      offset: 0n,
      bytes: discriminator,
      encoding: "base58"
    }
  };
  return fetchDecodedProgramAccounts(
    rpc,
    WHIRLPOOL_PROGRAM_ADDRESS,
    [discriminatorFilter, ...filters],
    getFeeTierDecoder()
  );
}

// src/gpa/position.ts
var import_web368 = require("@solana/web3.js");
function positionWhirlpoolFilter(address) {
  return {
    memcmp: {
      offset: 8n,
      bytes: (0, import_web368.getBase58Decoder)().decode((0, import_web368.getAddressEncoder)().encode(address)),
      encoding: "base58"
    }
  };
}
function positionMintFilter(address) {
  return {
    memcmp: {
      offset: 40n,
      bytes: (0, import_web368.getBase58Decoder)().decode((0, import_web368.getAddressEncoder)().encode(address)),
      encoding: "base58"
    }
  };
}
function positionTickLowerIndexFilter(tickLowerIndex) {
  return {
    memcmp: {
      offset: 88n,
      bytes: (0, import_web368.getBase58Decoder)().decode((0, import_web368.getI32Encoder)().encode(tickLowerIndex)),
      encoding: "base58"
    }
  };
}
function positionTickUpperIndexFilter(tickUpperIndex) {
  return {
    memcmp: {
      offset: 92n,
      bytes: (0, import_web368.getBase58Decoder)().decode((0, import_web368.getI32Encoder)().encode(tickUpperIndex)),
      encoding: "base58"
    }
  };
}
async function fetchAllPositionWithFilter(rpc, ...filters) {
  const discriminator = (0, import_web368.getBase58Decoder)().decode(POSITION_DISCRIMINATOR);
  const discriminatorFilter = {
    memcmp: {
      offset: 0n,
      bytes: discriminator,
      encoding: "base58"
    }
  };
  return fetchDecodedProgramAccounts(
    rpc,
    WHIRLPOOL_PROGRAM_ADDRESS,
    [discriminatorFilter, ...filters],
    getPositionDecoder()
  );
}

// src/gpa/positionBundle.ts
var import_web369 = require("@solana/web3.js");
function positionBundleMintFilter(address) {
  return {
    memcmp: {
      offset: 8n,
      bytes: (0, import_web369.getBase58Decoder)().decode((0, import_web369.getAddressEncoder)().encode(address)),
      encoding: "base58"
    }
  };
}
async function fetchAllPositionBundleWithFilter(rpc, ...filters) {
  const discriminator = (0, import_web369.getBase58Decoder)().decode(
    POSITION_BUNDLE_DISCRIMINATOR
  );
  const discriminatorFilter = {
    memcmp: {
      offset: 0n,
      bytes: discriminator,
      encoding: "base58"
    }
  };
  return fetchDecodedProgramAccounts(
    rpc,
    WHIRLPOOL_PROGRAM_ADDRESS,
    [discriminatorFilter, ...filters],
    getPositionBundleDecoder()
  );
}

// src/gpa/tickArray.ts
var import_web370 = require("@solana/web3.js");
function tickArrayStartTickIndexFilter(startTickIndex) {
  return {
    memcmp: {
      offset: 8n,
      bytes: (0, import_web370.getBase58Decoder)().decode((0, import_web370.getI32Encoder)().encode(startTickIndex)),
      encoding: "base58"
    }
  };
}
function tickArrayWhirlpoolFilter(address) {
  return {
    memcmp: {
      offset: 9956n,
      bytes: (0, import_web370.getBase58Decoder)().decode((0, import_web370.getAddressEncoder)().encode(address)),
      encoding: "base58"
    }
  };
}
async function fetchAllTickArrayWithFilter(rpc, ...filters) {
  const discriminator = (0, import_web370.getBase58Decoder)().decode(TICK_ARRAY_DISCRIMINATOR);
  const discriminatorFilter = {
    memcmp: {
      offset: 0n,
      bytes: discriminator,
      encoding: "base58"
    }
  };
  return fetchDecodedProgramAccounts(
    rpc,
    WHIRLPOOL_PROGRAM_ADDRESS,
    [discriminatorFilter, ...filters],
    getTickArrayDecoder()
  );
}

// src/gpa/tokenBadge.ts
var import_web371 = require("@solana/web3.js");
function tokenBadgeWhirlpoolsConfigFilter(address) {
  return {
    memcmp: {
      offset: 8n,
      bytes: (0, import_web371.getBase58Decoder)().decode((0, import_web371.getAddressEncoder)().encode(address)),
      encoding: "base58"
    }
  };
}
function tokenBadgeTokenMintFilter(address) {
  return {
    memcmp: {
      offset: 40n,
      bytes: (0, import_web371.getBase58Decoder)().decode((0, import_web371.getAddressEncoder)().encode(address)),
      encoding: "base58"
    }
  };
}
async function fetchAllTokenBadgeWithFilter(rpc, ...filters) {
  const discriminator = (0, import_web371.getBase58Decoder)().decode(TOKEN_BADGE_DISCRIMINATOR);
  const discriminatorFilter = {
    memcmp: {
      offset: 0n,
      bytes: discriminator,
      encoding: "base58"
    }
  };
  return fetchDecodedProgramAccounts(
    rpc,
    WHIRLPOOL_PROGRAM_ADDRESS,
    [discriminatorFilter, ...filters],
    getTokenBadgeDecoder()
  );
}

// src/gpa/whirlpool.ts
var import_web372 = require("@solana/web3.js");
function whirlpoolWhirlpoolConfigFilter(address) {
  return {
    memcmp: {
      offset: 8n,
      bytes: (0, import_web372.getBase58Decoder)().decode((0, import_web372.getAddressEncoder)().encode(address)),
      encoding: "base58"
    }
  };
}
function whirlpoolTickSpacingFilter(tickSpacing) {
  return {
    memcmp: {
      offset: 41n,
      bytes: (0, import_web372.getBase58Decoder)().decode((0, import_web372.getU16Encoder)().encode(tickSpacing)),
      encoding: "base58"
    }
  };
}
function whirlpoolFeeRateFilter(defaultFeeRate) {
  return {
    memcmp: {
      offset: 45n,
      bytes: (0, import_web372.getBase58Decoder)().decode((0, import_web372.getU16Encoder)().encode(defaultFeeRate)),
      encoding: "base58"
    }
  };
}
function whirlpoolProtocolFeeRateFilter(protocolFeeRate) {
  return {
    memcmp: {
      offset: 47n,
      bytes: (0, import_web372.getBase58Decoder)().decode((0, import_web372.getU16Encoder)().encode(protocolFeeRate)),
      encoding: "base58"
    }
  };
}
function whirlpoolTokenMintAFilter(tokenMintA) {
  return {
    memcmp: {
      offset: 101n,
      bytes: (0, import_web372.getBase58Decoder)().decode((0, import_web372.getAddressEncoder)().encode(tokenMintA)),
      encoding: "base58"
    }
  };
}
function whirlpoolTokenVaultAFilter(tokenVaultA) {
  return {
    memcmp: {
      offset: 133n,
      bytes: (0, import_web372.getBase58Decoder)().decode((0, import_web372.getAddressEncoder)().encode(tokenVaultA)),
      encoding: "base58"
    }
  };
}
function whirlpoolTokenMintBFilter(tokenMintB) {
  return {
    memcmp: {
      offset: 181n,
      bytes: (0, import_web372.getBase58Decoder)().decode((0, import_web372.getAddressEncoder)().encode(tokenMintB)),
      encoding: "base58"
    }
  };
}
function whirlpoolTokenVaultBFilter(tokenVaultB) {
  return {
    memcmp: {
      offset: 213n,
      bytes: (0, import_web372.getBase58Decoder)().decode((0, import_web372.getAddressEncoder)().encode(tokenVaultB)),
      encoding: "base58"
    }
  };
}
function whirlpoolRewardMint1Filter(rewardMint1) {
  return {
    memcmp: {
      offset: 269n,
      bytes: (0, import_web372.getBase58Decoder)().decode((0, import_web372.getAddressEncoder)().encode(rewardMint1)),
      encoding: "base58"
    }
  };
}
function whirlpoolRewardVault1Filter(rewardVault1) {
  return {
    memcmp: {
      offset: 301n,
      bytes: (0, import_web372.getBase58Decoder)().decode(
        (0, import_web372.getAddressEncoder)().encode(rewardVault1)
      ),
      encoding: "base58"
    }
  };
}
function whirlpoolRewardMint2Filter(rewardMint2) {
  return {
    memcmp: {
      offset: 397n,
      bytes: (0, import_web372.getBase58Decoder)().decode((0, import_web372.getAddressEncoder)().encode(rewardMint2)),
      encoding: "base58"
    }
  };
}
function whirlpoolRewardVault2Filter(rewardVault2) {
  return {
    memcmp: {
      offset: 429n,
      bytes: (0, import_web372.getBase58Decoder)().decode(
        (0, import_web372.getAddressEncoder)().encode(rewardVault2)
      ),
      encoding: "base58"
    }
  };
}
function whirlpoolRewardMint3Filter(rewardMint3) {
  return {
    memcmp: {
      offset: 525n,
      bytes: (0, import_web372.getBase58Decoder)().decode((0, import_web372.getAddressEncoder)().encode(rewardMint3)),
      encoding: "base58"
    }
  };
}
function whirlpoolRewardVault3Filter(rewardVault3) {
  return {
    memcmp: {
      offset: 557n,
      bytes: (0, import_web372.getBase58Decoder)().decode(
        (0, import_web372.getAddressEncoder)().encode(rewardVault3)
      ),
      encoding: "base58"
    }
  };
}
async function fetchAllWhirlpoolWithFilter(rpc, ...filters) {
  const discriminator = (0, import_web372.getBase58Decoder)().decode(WHIRLPOOL_DISCRIMINATOR);
  const discriminatorFilter = {
    memcmp: {
      offset: 0n,
      bytes: discriminator,
      encoding: "base58"
    }
  };
  return fetchDecodedProgramAccounts(
    rpc,
    WHIRLPOOL_PROGRAM_ADDRESS,
    [discriminatorFilter, ...filters],
    getWhirlpoolDecoder()
  );
}

// src/gpa/whirlpoolsConfig.ts
var import_web373 = require("@solana/web3.js");
function whirlpoolsConfigFeeAuthorityFilter(feeAuthority) {
  return {
    memcmp: {
      offset: 8n,
      bytes: (0, import_web373.getBase58Decoder)().decode(
        (0, import_web373.getAddressEncoder)().encode(feeAuthority)
      ),
      encoding: "base58"
    }
  };
}
function whirlpoolsConfigCollectProtocolFeesAuthorityFilter(collectProtocolFeesAuthority) {
  return {
    memcmp: {
      offset: 40n,
      bytes: (0, import_web373.getBase58Decoder)().decode(
        (0, import_web373.getAddressEncoder)().encode(collectProtocolFeesAuthority)
      ),
      encoding: "base58"
    }
  };
}
function whirlpoolsConfigRewardEmissionsSuperAuthorityFilter(rewardEmissionsSuperAuthority) {
  return {
    memcmp: {
      offset: 72n,
      bytes: (0, import_web373.getBase58Decoder)().decode(
        (0, import_web373.getAddressEncoder)().encode(rewardEmissionsSuperAuthority)
      ),
      encoding: "base58"
    }
  };
}
function whirlpoolsConfigDefaultProtocolFeeRateFilter(defaultFeeRate) {
  return {
    memcmp: {
      offset: 104n,
      bytes: (0, import_web373.getBase58Decoder)().decode((0, import_web373.getU16Encoder)().encode(defaultFeeRate)),
      encoding: "base58"
    }
  };
}
async function fetchAllWhirlpoolsConfigWithFilter(rpc, ...filters) {
  const discriminator = (0, import_web373.getBase58Decoder)().decode(
    WHIRLPOOLS_CONFIG_DISCRIMINATOR
  );
  const discriminatorFilter = {
    memcmp: {
      offset: 0n,
      bytes: discriminator,
      encoding: "base58"
    }
  };
  return fetchDecodedProgramAccounts(
    rpc,
    WHIRLPOOL_PROGRAM_ADDRESS,
    [discriminatorFilter, ...filters],
    getWhirlpoolsConfigDecoder()
  );
}

// src/gpa/whirlpoolsConfigExtension.ts
var import_web374 = require("@solana/web3.js");
function whirlpoolsConfigExtensionWhirlpoolsConfigFilter(address) {
  return {
    memcmp: {
      offset: 8n,
      bytes: (0, import_web374.getBase58Decoder)().decode((0, import_web374.getAddressEncoder)().encode(address)),
      encoding: "base58"
    }
  };
}
function whirlpoolsConfigExtensionConfigExtensionAuthorityFilter(configExtensionAuthority) {
  return {
    memcmp: {
      offset: 40n,
      bytes: (0, import_web374.getBase58Decoder)().decode(
        (0, import_web374.getAddressEncoder)().encode(configExtensionAuthority)
      ),
      encoding: "base58"
    }
  };
}
function whirlpoolsConfigExtensionConfigTokenBadgeAuthorityFilter(configTokenBadgeAuthority) {
  return {
    memcmp: {
      offset: 72n,
      bytes: (0, import_web374.getBase58Decoder)().decode(
        (0, import_web374.getAddressEncoder)().encode(configTokenBadgeAuthority)
      ),
      encoding: "base58"
    }
  };
}
async function fetchAllWhirlpoolsConfigExtensionWithFilter(rpc, ...filters) {
  const discriminator = (0, import_web374.getBase58Decoder)().decode(
    WHIRLPOOLS_CONFIG_EXTENSION_DISCRIMINATOR
  );
  const discriminatorFilter = {
    memcmp: {
      offset: 0n,
      bytes: discriminator,
      encoding: "base58"
    }
  };
  return fetchDecodedProgramAccounts(
    rpc,
    WHIRLPOOL_PROGRAM_ADDRESS,
    [discriminatorFilter, ...filters],
    getWhirlpoolsConfigExtensionDecoder()
  );
}

// src/pda/feeTier.ts
var import_web375 = require("@solana/web3.js");
async function getFeeTierAddress(whirlpoolsConfig, tickSpacing) {
  return await (0, import_web375.getProgramDerivedAddress)({
    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,
    seeds: [
      "fee_tier",
      (0, import_web375.getAddressEncoder)().encode(whirlpoolsConfig),
      (0, import_web375.getU16Encoder)().encode(tickSpacing)
    ]
  });
}

// src/pda/oracle.ts
var import_web376 = require("@solana/web3.js");
async function getOracleAddress(whirlpool) {
  return await (0, import_web376.getProgramDerivedAddress)({
    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,
    seeds: ["oracle", (0, import_web376.getAddressEncoder)().encode(whirlpool)]
  });
}

// src/pda/position.ts
var import_web377 = require("@solana/web3.js");
async function getPositionAddress(positionMint) {
  return await (0, import_web377.getProgramDerivedAddress)({
    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,
    seeds: ["position", (0, import_web377.getAddressEncoder)().encode(positionMint)]
  });
}

// src/pda/positionBundle.ts
var import_web378 = require("@solana/web3.js");
async function getPositionBundleAddress(positionBundleMint) {
  return await (0, import_web378.getProgramDerivedAddress)({
    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,
    seeds: ["position_bundle", (0, import_web378.getAddressEncoder)().encode(positionBundleMint)]
  });
}
async function getBundledPositionAddress(positionBundleAddress, bundleIndex) {
  return await (0, import_web378.getProgramDerivedAddress)({
    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,
    seeds: [
      "bundled_position",
      (0, import_web378.getAddressEncoder)().encode(positionBundleAddress),
      Buffer.from(bundleIndex.toString())
    ]
  });
}

// src/pda/tickArray.ts
var import_web379 = require("@solana/web3.js");
async function getTickArrayAddress(whirlpool, startTickIndex) {
  return await (0, import_web379.getProgramDerivedAddress)({
    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,
    seeds: [
      "tick_array",
      (0, import_web379.getAddressEncoder)().encode(whirlpool),
      `${startTickIndex}`
    ]
  });
}

// src/pda/tokenBadge.ts
var import_web380 = require("@solana/web3.js");
async function getTokenBadgeAddress(whirlpoolsConfig, tokenMint) {
  return await (0, import_web380.getProgramDerivedAddress)({
    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,
    seeds: [
      "token_badge",
      (0, import_web380.getAddressEncoder)().encode(whirlpoolsConfig),
      (0, import_web380.getAddressEncoder)().encode(tokenMint)
    ]
  });
}

// src/pda/whirlpool.ts
var import_web381 = require("@solana/web3.js");
async function getWhirlpoolAddress(whirlpoolsConfig, tokenMintA, tokenMintB, tickSpacing) {
  return await (0, import_web381.getProgramDerivedAddress)({
    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,
    seeds: [
      "whirlpool",
      (0, import_web381.getAddressEncoder)().encode(whirlpoolsConfig),
      (0, import_web381.getAddressEncoder)().encode(tokenMintA),
      (0, import_web381.getAddressEncoder)().encode(tokenMintB),
      (0, import_web381.getU16Encoder)().encode(tickSpacing)
    ]
  });
}

// src/pda/whirlpoolsConfigExtension.ts
var import_web382 = require("@solana/web3.js");
async function getWhirlpoolsConfigExtensionAddress(configAddress) {
  return await (0, import_web382.getProgramDerivedAddress)({
    programAddress: WHIRLPOOL_PROGRAM_ADDRESS,
    seeds: ["config_extension", (0, import_web382.getAddressEncoder)().encode(configAddress)]
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AccountsType,
  CLOSE_BUNDLED_POSITION_DISCRIMINATOR,
  CLOSE_POSITION_DISCRIMINATOR,
  CLOSE_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR,
  COLLECT_FEES_DISCRIMINATOR,
  COLLECT_FEES_V2_DISCRIMINATOR,
  COLLECT_PROTOCOL_FEES_DISCRIMINATOR,
  COLLECT_PROTOCOL_FEES_V2_DISCRIMINATOR,
  COLLECT_REWARD_DISCRIMINATOR,
  COLLECT_REWARD_V2_DISCRIMINATOR,
  DECREASE_LIQUIDITY_DISCRIMINATOR,
  DECREASE_LIQUIDITY_V2_DISCRIMINATOR,
  DELETE_POSITION_BUNDLE_DISCRIMINATOR,
  DELETE_TOKEN_BADGE_DISCRIMINATOR,
  FEE_TIER_DISCRIMINATOR,
  INCREASE_LIQUIDITY_DISCRIMINATOR,
  INCREASE_LIQUIDITY_V2_DISCRIMINATOR,
  INITIALIZE_CONFIG_DISCRIMINATOR,
  INITIALIZE_CONFIG_EXTENSION_DISCRIMINATOR,
  INITIALIZE_FEE_TIER_DISCRIMINATOR,
  INITIALIZE_POOL_DISCRIMINATOR,
  INITIALIZE_POOL_V2_DISCRIMINATOR,
  INITIALIZE_POSITION_BUNDLE_DISCRIMINATOR,
  INITIALIZE_POSITION_BUNDLE_WITH_METADATA_DISCRIMINATOR,
  INITIALIZE_REWARD_DISCRIMINATOR,
  INITIALIZE_REWARD_V2_DISCRIMINATOR,
  INITIALIZE_TICK_ARRAY_DISCRIMINATOR,
  INITIALIZE_TOKEN_BADGE_DISCRIMINATOR,
  OPEN_BUNDLED_POSITION_DISCRIMINATOR,
  OPEN_POSITION_DISCRIMINATOR,
  OPEN_POSITION_WITH_METADATA_DISCRIMINATOR,
  OPEN_POSITION_WITH_TOKEN_EXTENSIONS_DISCRIMINATOR,
  POSITION_BUNDLE_DISCRIMINATOR,
  POSITION_DISCRIMINATOR,
  SET_COLLECT_PROTOCOL_FEES_AUTHORITY_DISCRIMINATOR,
  SET_CONFIG_EXTENSION_AUTHORITY_DISCRIMINATOR,
  SET_DEFAULT_FEE_RATE_DISCRIMINATOR,
  SET_DEFAULT_PROTOCOL_FEE_RATE_DISCRIMINATOR,
  SET_FEE_AUTHORITY_DISCRIMINATOR,
  SET_FEE_RATE_DISCRIMINATOR,
  SET_PROTOCOL_FEE_RATE_DISCRIMINATOR,
  SET_REWARD_AUTHORITY_BY_SUPER_AUTHORITY_DISCRIMINATOR,
  SET_REWARD_AUTHORITY_DISCRIMINATOR,
  SET_REWARD_EMISSIONS_DISCRIMINATOR,
  SET_REWARD_EMISSIONS_SUPER_AUTHORITY_DISCRIMINATOR,
  SET_REWARD_EMISSIONS_V2_DISCRIMINATOR,
  SET_TOKEN_BADGE_AUTHORITY_DISCRIMINATOR,
  SWAP_DISCRIMINATOR,
  SWAP_V2_DISCRIMINATOR,
  TICK_ARRAY_DISCRIMINATOR,
  TOKEN_BADGE_DISCRIMINATOR,
  TWO_HOP_SWAP_DISCRIMINATOR,
  TWO_HOP_SWAP_V2_DISCRIMINATOR,
  UPDATE_FEES_AND_REWARDS_DISCRIMINATOR,
  WHIRLPOOLS_CONFIG_DISCRIMINATOR,
  WHIRLPOOLS_CONFIG_EXTENSION_DISCRIMINATOR,
  WHIRLPOOL_DISCRIMINATOR,
  WHIRLPOOL_ERROR__AMOUNT_CALC_OVERFLOW,
  WHIRLPOOL_ERROR__AMOUNT_IN_ABOVE_MAXIMUM,
  WHIRLPOOL_ERROR__AMOUNT_OUT_BELOW_MINIMUM,
  WHIRLPOOL_ERROR__AMOUNT_REMAINING_OVERFLOW,
  WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_CLOSED,
  WHIRLPOOL_ERROR__BUNDLED_POSITION_ALREADY_OPENED,
  WHIRLPOOL_ERROR__CLOSE_POSITION_NOT_EMPTY,
  WHIRLPOOL_ERROR__DIFFERENT_WHIRLPOOL_TICK_ARRAY_ACCOUNT,
  WHIRLPOOL_ERROR__DIVIDE_BY_ZERO,
  WHIRLPOOL_ERROR__DUPLICATE_TWO_HOP_POOL,
  WHIRLPOOL_ERROR__FEE_RATE_MAX_EXCEEDED,
  WHIRLPOOL_ERROR__FULL_RANGE_ONLY_POOL,
  WHIRLPOOL_ERROR__INTERMEDIATE_TOKEN_AMOUNT_MISMATCH,
  WHIRLPOOL_ERROR__INVALID_BUNDLE_INDEX,
  WHIRLPOOL_ERROR__INVALID_ENUM,
  WHIRLPOOL_ERROR__INVALID_INTERMEDIARY_MINT,
  WHIRLPOOL_ERROR__INVALID_POSITION_TOKEN_AMOUNT,
  WHIRLPOOL_ERROR__INVALID_REWARD_INDEX,
  WHIRLPOOL_ERROR__INVALID_SQRT_PRICE_LIMIT_DIRECTION,
  WHIRLPOOL_ERROR__INVALID_START_TICK,
  WHIRLPOOL_ERROR__INVALID_TICK_ARRAY_SEQUENCE,
  WHIRLPOOL_ERROR__INVALID_TICK_INDEX,
  WHIRLPOOL_ERROR__INVALID_TICK_SPACING,
  WHIRLPOOL_ERROR__INVALID_TIMESTAMP,
  WHIRLPOOL_ERROR__INVALID_TIMESTAMP_CONVERSION,
  WHIRLPOOL_ERROR__INVALID_TOKEN_MINT_ORDER,
  WHIRLPOOL_ERROR__LIQUIDITY_NET_ERROR,
  WHIRLPOOL_ERROR__LIQUIDITY_OVERFLOW,
  WHIRLPOOL_ERROR__LIQUIDITY_TOO_HIGH,
  WHIRLPOOL_ERROR__LIQUIDITY_UNDERFLOW,
  WHIRLPOOL_ERROR__LIQUIDITY_ZERO,
  WHIRLPOOL_ERROR__MISSING_OR_INVALID_DELEGATE,
  WHIRLPOOL_ERROR__MULTIPLICATION_OVERFLOW,
  WHIRLPOOL_ERROR__MULTIPLICATION_SHIFT_RIGHT_OVERFLOW,
  WHIRLPOOL_ERROR__MUL_DIV_INVALID_INPUT,
  WHIRLPOOL_ERROR__MUL_DIV_OVERFLOW,
  WHIRLPOOL_ERROR__NO_EXTRA_ACCOUNTS_FOR_TRANSFER_HOOK,
  WHIRLPOOL_ERROR__NUMBER_CAST_ERROR,
  WHIRLPOOL_ERROR__NUMBER_DOWN_CAST_ERROR,
  WHIRLPOOL_ERROR__PARTIAL_FILL_ERROR,
  WHIRLPOOL_ERROR__POSITION_BUNDLE_NOT_DELETABLE,
  WHIRLPOOL_ERROR__PROTOCOL_FEE_RATE_MAX_EXCEEDED,
  WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_DUPLICATED_ACCOUNTS_TYPE,
  WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INSUFFICIENT,
  WHIRLPOOL_ERROR__REMAINING_ACCOUNTS_INVALID_SLICE,
  WHIRLPOOL_ERROR__REWARD_NOT_INITIALIZED,
  WHIRLPOOL_ERROR__REWARD_VAULT_AMOUNT_INSUFFICIENT,
  WHIRLPOOL_ERROR__SQRT_PRICE_OUT_OF_BOUNDS,
  WHIRLPOOL_ERROR__TICK_ARRAY_EXIST_IN_POOL,
  WHIRLPOOL_ERROR__TICK_ARRAY_INDEX_OUTOF_BOUNDS,
  WHIRLPOOL_ERROR__TICK_ARRAY_SEQUENCE_INVALID_INDEX,
  WHIRLPOOL_ERROR__TICK_NOT_FOUND,
  WHIRLPOOL_ERROR__TOKEN_MAX_EXCEEDED,
  WHIRLPOOL_ERROR__TOKEN_MIN_SUBCEEDED,
  WHIRLPOOL_ERROR__TOO_MANY_SUPPLEMENTAL_TICK_ARRAYS,
  WHIRLPOOL_ERROR__TRANSFER_FEE_CALCULATION_ERROR,
  WHIRLPOOL_ERROR__UNSUPPORTED_TOKEN_MINT,
  WHIRLPOOL_ERROR__ZERO_TRADABLE_AMOUNT,
  WHIRLPOOL_PROGRAM_ADDRESS,
  WhirlpoolAccount,
  WhirlpoolInstruction,
  decodeFeeTier,
  decodePosition,
  decodePositionBundle,
  decodeTickArray,
  decodeTokenBadge,
  decodeWhirlpool,
  decodeWhirlpoolsConfig,
  decodeWhirlpoolsConfigExtension,
  feeTierFeeRateFilter,
  feeTierTickSpacingFilter,
  feeTierWhirlpoolsConfigFilter,
  fetchAllFeeTier,
  fetchAllFeeTierWithFilter,
  fetchAllMaybeFeeTier,
  fetchAllMaybePosition,
  fetchAllMaybePositionBundle,
  fetchAllMaybeTickArray,
  fetchAllMaybeTokenBadge,
  fetchAllMaybeWhirlpool,
  fetchAllMaybeWhirlpoolsConfig,
  fetchAllMaybeWhirlpoolsConfigExtension,
  fetchAllPosition,
  fetchAllPositionBundle,
  fetchAllPositionBundleWithFilter,
  fetchAllPositionWithFilter,
  fetchAllTickArray,
  fetchAllTickArrayWithFilter,
  fetchAllTokenBadge,
  fetchAllTokenBadgeWithFilter,
  fetchAllWhirlpool,
  fetchAllWhirlpoolWithFilter,
  fetchAllWhirlpoolsConfig,
  fetchAllWhirlpoolsConfigExtension,
  fetchAllWhirlpoolsConfigExtensionWithFilter,
  fetchAllWhirlpoolsConfigWithFilter,
  fetchFeeTier,
  fetchMaybeFeeTier,
  fetchMaybePosition,
  fetchMaybePositionBundle,
  fetchMaybeTickArray,
  fetchMaybeTokenBadge,
  fetchMaybeWhirlpool,
  fetchMaybeWhirlpoolsConfig,
  fetchMaybeWhirlpoolsConfigExtension,
  fetchPosition,
  fetchPositionBundle,
  fetchTickArray,
  fetchTokenBadge,
  fetchWhirlpool,
  fetchWhirlpoolsConfig,
  fetchWhirlpoolsConfigExtension,
  getAccountsTypeCodec,
  getAccountsTypeDecoder,
  getAccountsTypeEncoder,
  getBundledPositionAddress,
  getCloseBundledPositionDiscriminatorBytes,
  getCloseBundledPositionInstruction,
  getCloseBundledPositionInstructionDataCodec,
  getCloseBundledPositionInstructionDataDecoder,
  getCloseBundledPositionInstructionDataEncoder,
  getClosePositionDiscriminatorBytes,
  getClosePositionInstruction,
  getClosePositionInstructionDataCodec,
  getClosePositionInstructionDataDecoder,
  getClosePositionInstructionDataEncoder,
  getClosePositionWithTokenExtensionsDiscriminatorBytes,
  getClosePositionWithTokenExtensionsInstruction,
  getClosePositionWithTokenExtensionsInstructionDataCodec,
  getClosePositionWithTokenExtensionsInstructionDataDecoder,
  getClosePositionWithTokenExtensionsInstructionDataEncoder,
  getCollectFeesDiscriminatorBytes,
  getCollectFeesInstruction,
  getCollectFeesInstructionDataCodec,
  getCollectFeesInstructionDataDecoder,
  getCollectFeesInstructionDataEncoder,
  getCollectFeesV2DiscriminatorBytes,
  getCollectFeesV2Instruction,
  getCollectFeesV2InstructionDataCodec,
  getCollectFeesV2InstructionDataDecoder,
  getCollectFeesV2InstructionDataEncoder,
  getCollectProtocolFeesDiscriminatorBytes,
  getCollectProtocolFeesInstruction,
  getCollectProtocolFeesInstructionDataCodec,
  getCollectProtocolFeesInstructionDataDecoder,
  getCollectProtocolFeesInstructionDataEncoder,
  getCollectProtocolFeesV2DiscriminatorBytes,
  getCollectProtocolFeesV2Instruction,
  getCollectProtocolFeesV2InstructionDataCodec,
  getCollectProtocolFeesV2InstructionDataDecoder,
  getCollectProtocolFeesV2InstructionDataEncoder,
  getCollectRewardDiscriminatorBytes,
  getCollectRewardInstruction,
  getCollectRewardInstructionDataCodec,
  getCollectRewardInstructionDataDecoder,
  getCollectRewardInstructionDataEncoder,
  getCollectRewardV2DiscriminatorBytes,
  getCollectRewardV2Instruction,
  getCollectRewardV2InstructionDataCodec,
  getCollectRewardV2InstructionDataDecoder,
  getCollectRewardV2InstructionDataEncoder,
  getDecreaseLiquidityDiscriminatorBytes,
  getDecreaseLiquidityInstruction,
  getDecreaseLiquidityInstructionDataCodec,
  getDecreaseLiquidityInstructionDataDecoder,
  getDecreaseLiquidityInstructionDataEncoder,
  getDecreaseLiquidityV2DiscriminatorBytes,
  getDecreaseLiquidityV2Instruction,
  getDecreaseLiquidityV2InstructionDataCodec,
  getDecreaseLiquidityV2InstructionDataDecoder,
  getDecreaseLiquidityV2InstructionDataEncoder,
  getDeletePositionBundleDiscriminatorBytes,
  getDeletePositionBundleInstruction,
  getDeletePositionBundleInstructionDataCodec,
  getDeletePositionBundleInstructionDataDecoder,
  getDeletePositionBundleInstructionDataEncoder,
  getDeleteTokenBadgeDiscriminatorBytes,
  getDeleteTokenBadgeInstruction,
  getDeleteTokenBadgeInstructionDataCodec,
  getDeleteTokenBadgeInstructionDataDecoder,
  getDeleteTokenBadgeInstructionDataEncoder,
  getFeeTierAddress,
  getFeeTierCodec,
  getFeeTierDecoder,
  getFeeTierDiscriminatorBytes,
  getFeeTierEncoder,
  getFeeTierSize,
  getIncreaseLiquidityDiscriminatorBytes,
  getIncreaseLiquidityInstruction,
  getIncreaseLiquidityInstructionDataCodec,
  getIncreaseLiquidityInstructionDataDecoder,
  getIncreaseLiquidityInstructionDataEncoder,
  getIncreaseLiquidityV2DiscriminatorBytes,
  getIncreaseLiquidityV2Instruction,
  getIncreaseLiquidityV2InstructionDataCodec,
  getIncreaseLiquidityV2InstructionDataDecoder,
  getIncreaseLiquidityV2InstructionDataEncoder,
  getInitializeConfigDiscriminatorBytes,
  getInitializeConfigExtensionDiscriminatorBytes,
  getInitializeConfigExtensionInstruction,
  getInitializeConfigExtensionInstructionDataCodec,
  getInitializeConfigExtensionInstructionDataDecoder,
  getInitializeConfigExtensionInstructionDataEncoder,
  getInitializeConfigInstruction,
  getInitializeConfigInstructionDataCodec,
  getInitializeConfigInstructionDataDecoder,
  getInitializeConfigInstructionDataEncoder,
  getInitializeFeeTierDiscriminatorBytes,
  getInitializeFeeTierInstruction,
  getInitializeFeeTierInstructionDataCodec,
  getInitializeFeeTierInstructionDataDecoder,
  getInitializeFeeTierInstructionDataEncoder,
  getInitializePoolDiscriminatorBytes,
  getInitializePoolInstruction,
  getInitializePoolInstructionDataCodec,
  getInitializePoolInstructionDataDecoder,
  getInitializePoolInstructionDataEncoder,
  getInitializePoolV2DiscriminatorBytes,
  getInitializePoolV2Instruction,
  getInitializePoolV2InstructionDataCodec,
  getInitializePoolV2InstructionDataDecoder,
  getInitializePoolV2InstructionDataEncoder,
  getInitializePositionBundleDiscriminatorBytes,
  getInitializePositionBundleInstruction,
  getInitializePositionBundleInstructionDataCodec,
  getInitializePositionBundleInstructionDataDecoder,
  getInitializePositionBundleInstructionDataEncoder,
  getInitializePositionBundleWithMetadataDiscriminatorBytes,
  getInitializePositionBundleWithMetadataInstruction,
  getInitializePositionBundleWithMetadataInstructionDataCodec,
  getInitializePositionBundleWithMetadataInstructionDataDecoder,
  getInitializePositionBundleWithMetadataInstructionDataEncoder,
  getInitializeRewardDiscriminatorBytes,
  getInitializeRewardInstruction,
  getInitializeRewardInstructionDataCodec,
  getInitializeRewardInstructionDataDecoder,
  getInitializeRewardInstructionDataEncoder,
  getInitializeRewardV2DiscriminatorBytes,
  getInitializeRewardV2Instruction,
  getInitializeRewardV2InstructionDataCodec,
  getInitializeRewardV2InstructionDataDecoder,
  getInitializeRewardV2InstructionDataEncoder,
  getInitializeTickArrayDiscriminatorBytes,
  getInitializeTickArrayInstruction,
  getInitializeTickArrayInstructionDataCodec,
  getInitializeTickArrayInstructionDataDecoder,
  getInitializeTickArrayInstructionDataEncoder,
  getInitializeTokenBadgeDiscriminatorBytes,
  getInitializeTokenBadgeInstruction,
  getInitializeTokenBadgeInstructionDataCodec,
  getInitializeTokenBadgeInstructionDataDecoder,
  getInitializeTokenBadgeInstructionDataEncoder,
  getOpenBundledPositionDiscriminatorBytes,
  getOpenBundledPositionInstruction,
  getOpenBundledPositionInstructionDataCodec,
  getOpenBundledPositionInstructionDataDecoder,
  getOpenBundledPositionInstructionDataEncoder,
  getOpenPositionDiscriminatorBytes,
  getOpenPositionInstruction,
  getOpenPositionInstructionDataCodec,
  getOpenPositionInstructionDataDecoder,
  getOpenPositionInstructionDataEncoder,
  getOpenPositionWithMetadataDiscriminatorBytes,
  getOpenPositionWithMetadataInstruction,
  getOpenPositionWithMetadataInstructionDataCodec,
  getOpenPositionWithMetadataInstructionDataDecoder,
  getOpenPositionWithMetadataInstructionDataEncoder,
  getOpenPositionWithTokenExtensionsDiscriminatorBytes,
  getOpenPositionWithTokenExtensionsInstruction,
  getOpenPositionWithTokenExtensionsInstructionDataCodec,
  getOpenPositionWithTokenExtensionsInstructionDataDecoder,
  getOpenPositionWithTokenExtensionsInstructionDataEncoder,
  getOracleAddress,
  getPositionAddress,
  getPositionBundleAddress,
  getPositionBundleCodec,
  getPositionBundleDecoder,
  getPositionBundleDiscriminatorBytes,
  getPositionBundleEncoder,
  getPositionBundleSize,
  getPositionCodec,
  getPositionDecoder,
  getPositionDiscriminatorBytes,
  getPositionEncoder,
  getPositionRewardInfoCodec,
  getPositionRewardInfoDecoder,
  getPositionRewardInfoEncoder,
  getPositionSize,
  getRemainingAccountsInfoCodec,
  getRemainingAccountsInfoDecoder,
  getRemainingAccountsInfoEncoder,
  getRemainingAccountsSliceCodec,
  getRemainingAccountsSliceDecoder,
  getRemainingAccountsSliceEncoder,
  getSetCollectProtocolFeesAuthorityDiscriminatorBytes,
  getSetCollectProtocolFeesAuthorityInstruction,
  getSetCollectProtocolFeesAuthorityInstructionDataCodec,
  getSetCollectProtocolFeesAuthorityInstructionDataDecoder,
  getSetCollectProtocolFeesAuthorityInstructionDataEncoder,
  getSetConfigExtensionAuthorityDiscriminatorBytes,
  getSetConfigExtensionAuthorityInstruction,
  getSetConfigExtensionAuthorityInstructionDataCodec,
  getSetConfigExtensionAuthorityInstructionDataDecoder,
  getSetConfigExtensionAuthorityInstructionDataEncoder,
  getSetDefaultFeeRateDiscriminatorBytes,
  getSetDefaultFeeRateInstruction,
  getSetDefaultFeeRateInstructionDataCodec,
  getSetDefaultFeeRateInstructionDataDecoder,
  getSetDefaultFeeRateInstructionDataEncoder,
  getSetDefaultProtocolFeeRateDiscriminatorBytes,
  getSetDefaultProtocolFeeRateInstruction,
  getSetDefaultProtocolFeeRateInstructionDataCodec,
  getSetDefaultProtocolFeeRateInstructionDataDecoder,
  getSetDefaultProtocolFeeRateInstructionDataEncoder,
  getSetFeeAuthorityDiscriminatorBytes,
  getSetFeeAuthorityInstruction,
  getSetFeeAuthorityInstructionDataCodec,
  getSetFeeAuthorityInstructionDataDecoder,
  getSetFeeAuthorityInstructionDataEncoder,
  getSetFeeRateDiscriminatorBytes,
  getSetFeeRateInstruction,
  getSetFeeRateInstructionDataCodec,
  getSetFeeRateInstructionDataDecoder,
  getSetFeeRateInstructionDataEncoder,
  getSetProtocolFeeRateDiscriminatorBytes,
  getSetProtocolFeeRateInstruction,
  getSetProtocolFeeRateInstructionDataCodec,
  getSetProtocolFeeRateInstructionDataDecoder,
  getSetProtocolFeeRateInstructionDataEncoder,
  getSetRewardAuthorityBySuperAuthorityDiscriminatorBytes,
  getSetRewardAuthorityBySuperAuthorityInstruction,
  getSetRewardAuthorityBySuperAuthorityInstructionDataCodec,
  getSetRewardAuthorityBySuperAuthorityInstructionDataDecoder,
  getSetRewardAuthorityBySuperAuthorityInstructionDataEncoder,
  getSetRewardAuthorityDiscriminatorBytes,
  getSetRewardAuthorityInstruction,
  getSetRewardAuthorityInstructionDataCodec,
  getSetRewardAuthorityInstructionDataDecoder,
  getSetRewardAuthorityInstructionDataEncoder,
  getSetRewardEmissionsDiscriminatorBytes,
  getSetRewardEmissionsInstruction,
  getSetRewardEmissionsInstructionDataCodec,
  getSetRewardEmissionsInstructionDataDecoder,
  getSetRewardEmissionsInstructionDataEncoder,
  getSetRewardEmissionsSuperAuthorityDiscriminatorBytes,
  getSetRewardEmissionsSuperAuthorityInstruction,
  getSetRewardEmissionsSuperAuthorityInstructionDataCodec,
  getSetRewardEmissionsSuperAuthorityInstructionDataDecoder,
  getSetRewardEmissionsSuperAuthorityInstructionDataEncoder,
  getSetRewardEmissionsV2DiscriminatorBytes,
  getSetRewardEmissionsV2Instruction,
  getSetRewardEmissionsV2InstructionDataCodec,
  getSetRewardEmissionsV2InstructionDataDecoder,
  getSetRewardEmissionsV2InstructionDataEncoder,
  getSetTokenBadgeAuthorityDiscriminatorBytes,
  getSetTokenBadgeAuthorityInstruction,
  getSetTokenBadgeAuthorityInstructionDataCodec,
  getSetTokenBadgeAuthorityInstructionDataDecoder,
  getSetTokenBadgeAuthorityInstructionDataEncoder,
  getSwapDiscriminatorBytes,
  getSwapInstruction,
  getSwapInstructionDataCodec,
  getSwapInstructionDataDecoder,
  getSwapInstructionDataEncoder,
  getSwapV2DiscriminatorBytes,
  getSwapV2Instruction,
  getSwapV2InstructionDataCodec,
  getSwapV2InstructionDataDecoder,
  getSwapV2InstructionDataEncoder,
  getTickArrayAddress,
  getTickArrayCodec,
  getTickArrayDecoder,
  getTickArrayDiscriminatorBytes,
  getTickArrayEncoder,
  getTickArraySize,
  getTickCodec,
  getTickDecoder,
  getTickEncoder,
  getTokenBadgeAddress,
  getTokenBadgeCodec,
  getTokenBadgeDecoder,
  getTokenBadgeDiscriminatorBytes,
  getTokenBadgeEncoder,
  getTokenBadgeSize,
  getTwoHopSwapDiscriminatorBytes,
  getTwoHopSwapInstruction,
  getTwoHopSwapInstructionDataCodec,
  getTwoHopSwapInstructionDataDecoder,
  getTwoHopSwapInstructionDataEncoder,
  getTwoHopSwapV2DiscriminatorBytes,
  getTwoHopSwapV2Instruction,
  getTwoHopSwapV2InstructionDataCodec,
  getTwoHopSwapV2InstructionDataDecoder,
  getTwoHopSwapV2InstructionDataEncoder,
  getUpdateFeesAndRewardsDiscriminatorBytes,
  getUpdateFeesAndRewardsInstruction,
  getUpdateFeesAndRewardsInstructionDataCodec,
  getUpdateFeesAndRewardsInstructionDataDecoder,
  getUpdateFeesAndRewardsInstructionDataEncoder,
  getWhirlpoolAddress,
  getWhirlpoolCodec,
  getWhirlpoolDecoder,
  getWhirlpoolDiscriminatorBytes,
  getWhirlpoolEncoder,
  getWhirlpoolErrorMessage,
  getWhirlpoolRewardInfoCodec,
  getWhirlpoolRewardInfoDecoder,
  getWhirlpoolRewardInfoEncoder,
  getWhirlpoolSize,
  getWhirlpoolsConfigCodec,
  getWhirlpoolsConfigDecoder,
  getWhirlpoolsConfigDiscriminatorBytes,
  getWhirlpoolsConfigEncoder,
  getWhirlpoolsConfigExtensionAddress,
  getWhirlpoolsConfigExtensionCodec,
  getWhirlpoolsConfigExtensionDecoder,
  getWhirlpoolsConfigExtensionDiscriminatorBytes,
  getWhirlpoolsConfigExtensionEncoder,
  getWhirlpoolsConfigExtensionSize,
  getWhirlpoolsConfigSize,
  identifyWhirlpoolAccount,
  identifyWhirlpoolInstruction,
  isWhirlpoolError,
  parseCloseBundledPositionInstruction,
  parseClosePositionInstruction,
  parseClosePositionWithTokenExtensionsInstruction,
  parseCollectFeesInstruction,
  parseCollectFeesV2Instruction,
  parseCollectProtocolFeesInstruction,
  parseCollectProtocolFeesV2Instruction,
  parseCollectRewardInstruction,
  parseCollectRewardV2Instruction,
  parseDecreaseLiquidityInstruction,
  parseDecreaseLiquidityV2Instruction,
  parseDeletePositionBundleInstruction,
  parseDeleteTokenBadgeInstruction,
  parseIncreaseLiquidityInstruction,
  parseIncreaseLiquidityV2Instruction,
  parseInitializeConfigExtensionInstruction,
  parseInitializeConfigInstruction,
  parseInitializeFeeTierInstruction,
  parseInitializePoolInstruction,
  parseInitializePoolV2Instruction,
  parseInitializePositionBundleInstruction,
  parseInitializePositionBundleWithMetadataInstruction,
  parseInitializeRewardInstruction,
  parseInitializeRewardV2Instruction,
  parseInitializeTickArrayInstruction,
  parseInitializeTokenBadgeInstruction,
  parseOpenBundledPositionInstruction,
  parseOpenPositionInstruction,
  parseOpenPositionWithMetadataInstruction,
  parseOpenPositionWithTokenExtensionsInstruction,
  parseSetCollectProtocolFeesAuthorityInstruction,
  parseSetConfigExtensionAuthorityInstruction,
  parseSetDefaultFeeRateInstruction,
  parseSetDefaultProtocolFeeRateInstruction,
  parseSetFeeAuthorityInstruction,
  parseSetFeeRateInstruction,
  parseSetProtocolFeeRateInstruction,
  parseSetRewardAuthorityBySuperAuthorityInstruction,
  parseSetRewardAuthorityInstruction,
  parseSetRewardEmissionsInstruction,
  parseSetRewardEmissionsSuperAuthorityInstruction,
  parseSetRewardEmissionsV2Instruction,
  parseSetTokenBadgeAuthorityInstruction,
  parseSwapInstruction,
  parseSwapV2Instruction,
  parseTwoHopSwapInstruction,
  parseTwoHopSwapV2Instruction,
  parseUpdateFeesAndRewardsInstruction,
  positionBundleMintFilter,
  positionMintFilter,
  positionTickLowerIndexFilter,
  positionTickUpperIndexFilter,
  positionWhirlpoolFilter,
  tickArrayStartTickIndexFilter,
  tickArrayWhirlpoolFilter,
  tokenBadgeTokenMintFilter,
  tokenBadgeWhirlpoolsConfigFilter,
  whirlpoolFeeRateFilter,
  whirlpoolProtocolFeeRateFilter,
  whirlpoolRewardMint1Filter,
  whirlpoolRewardMint2Filter,
  whirlpoolRewardMint3Filter,
  whirlpoolRewardVault1Filter,
  whirlpoolRewardVault2Filter,
  whirlpoolRewardVault3Filter,
  whirlpoolTickSpacingFilter,
  whirlpoolTokenMintAFilter,
  whirlpoolTokenMintBFilter,
  whirlpoolTokenVaultAFilter,
  whirlpoolTokenVaultBFilter,
  whirlpoolWhirlpoolConfigFilter,
  whirlpoolsConfigCollectProtocolFeesAuthorityFilter,
  whirlpoolsConfigDefaultProtocolFeeRateFilter,
  whirlpoolsConfigExtensionConfigExtensionAuthorityFilter,
  whirlpoolsConfigExtensionConfigTokenBadgeAuthorityFilter,
  whirlpoolsConfigExtensionWhirlpoolsConfigFilter,
  whirlpoolsConfigFeeAuthorityFilter,
  whirlpoolsConfigRewardEmissionsSuperAuthorityFilter
});
//# sourceMappingURL=index.cjs.map