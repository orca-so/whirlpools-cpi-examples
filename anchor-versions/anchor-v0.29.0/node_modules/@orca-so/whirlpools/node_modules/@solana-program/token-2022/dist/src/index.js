'use strict';

var web3_js = require('@solana/web3.js');

// src/generated/accounts/mint.ts
var AccountState = /* @__PURE__ */ ((AccountState2) => {
  AccountState2[AccountState2["Uninitialized"] = 0] = "Uninitialized";
  AccountState2[AccountState2["Initialized"] = 1] = "Initialized";
  AccountState2[AccountState2["Frozen"] = 2] = "Frozen";
  return AccountState2;
})(AccountState || {});
function getAccountStateEncoder() {
  return web3_js.getEnumEncoder(AccountState);
}
function getAccountStateDecoder() {
  return web3_js.getEnumDecoder(AccountState);
}
function getAccountStateCodec() {
  return web3_js.combineCodec(getAccountStateEncoder(), getAccountStateDecoder());
}
var AuthorityType = /* @__PURE__ */ ((AuthorityType2) => {
  AuthorityType2[AuthorityType2["MintTokens"] = 0] = "MintTokens";
  AuthorityType2[AuthorityType2["FreezeAccount"] = 1] = "FreezeAccount";
  AuthorityType2[AuthorityType2["AccountOwner"] = 2] = "AccountOwner";
  AuthorityType2[AuthorityType2["CloseAccount"] = 3] = "CloseAccount";
  return AuthorityType2;
})(AuthorityType || {});
function getAuthorityTypeEncoder() {
  return web3_js.getEnumEncoder(AuthorityType);
}
function getAuthorityTypeDecoder() {
  return web3_js.getEnumDecoder(AuthorityType);
}
function getAuthorityTypeCodec() {
  return web3_js.combineCodec(getAuthorityTypeEncoder(), getAuthorityTypeDecoder());
}
function getDecryptableBalanceEncoder() {
  return web3_js.fixEncoderSize(web3_js.getBytesEncoder(), 36);
}
function getDecryptableBalanceDecoder() {
  return web3_js.fixDecoderSize(web3_js.getBytesDecoder(), 36);
}
function getDecryptableBalanceCodec() {
  return web3_js.combineCodec(
    getDecryptableBalanceEncoder(),
    getDecryptableBalanceDecoder()
  );
}
function getEncryptedBalanceEncoder() {
  return web3_js.fixEncoderSize(web3_js.getBytesEncoder(), 64);
}
function getEncryptedBalanceDecoder() {
  return web3_js.fixDecoderSize(web3_js.getBytesDecoder(), 64);
}
function getEncryptedBalanceCodec() {
  return web3_js.combineCodec(
    getEncryptedBalanceEncoder(),
    getEncryptedBalanceDecoder()
  );
}
function getExtensionEncoder() {
  return web3_js.getDiscriminatedUnionEncoder(
    [
      ["Uninitialized", web3_js.getUnitEncoder()],
      [
        "TransferFeeConfig",
        web3_js.addEncoderSizePrefix(
          web3_js.getStructEncoder([
            ["transferFeeConfigAuthority", web3_js.getAddressEncoder()],
            ["withdrawWithheldAuthority", web3_js.getAddressEncoder()],
            ["withheldAmount", web3_js.getU64Encoder()],
            ["olderTransferFee", getTransferFeeEncoder()],
            ["newerTransferFee", getTransferFeeEncoder()]
          ]),
          web3_js.getU16Encoder()
        )
      ],
      [
        "TransferFeeAmount",
        web3_js.addEncoderSizePrefix(
          web3_js.getStructEncoder([["withheldAmount", web3_js.getU64Encoder()]]),
          web3_js.getU16Encoder()
        )
      ],
      [
        "MintCloseAuthority",
        web3_js.addEncoderSizePrefix(
          web3_js.getStructEncoder([["closeAuthority", web3_js.getAddressEncoder()]]),
          web3_js.getU16Encoder()
        )
      ],
      [
        "ConfidentialTransferMint",
        web3_js.addEncoderSizePrefix(
          web3_js.getStructEncoder([
            [
              "authority",
              web3_js.getOptionEncoder(web3_js.getAddressEncoder(), {
                prefix: null,
                noneValue: "zeroes"
              })
            ],
            ["autoApproveNewAccounts", web3_js.getBooleanEncoder()],
            [
              "auditorElgamalPubkey",
              web3_js.getOptionEncoder(web3_js.getAddressEncoder(), {
                prefix: null,
                noneValue: "zeroes"
              })
            ]
          ]),
          web3_js.getU16Encoder()
        )
      ],
      [
        "ConfidentialTransferAccount",
        web3_js.addEncoderSizePrefix(
          web3_js.getStructEncoder([
            ["approved", web3_js.getBooleanEncoder()],
            ["elgamalPubkey", web3_js.getAddressEncoder()],
            ["pendingBalanceLow", getEncryptedBalanceEncoder()],
            ["pendingBalanceHigh", getEncryptedBalanceEncoder()],
            ["availableBalance", getEncryptedBalanceEncoder()],
            ["decryptableAvailableBalance", getDecryptableBalanceEncoder()],
            ["allowConfidentialCredits", web3_js.getBooleanEncoder()],
            ["allowNonConfidentialCredits", web3_js.getBooleanEncoder()],
            ["pendingBalanceCreditCounter", web3_js.getU64Encoder()],
            ["maximumPendingBalanceCreditCounter", web3_js.getU64Encoder()],
            ["expectedPendingBalanceCreditCounter", web3_js.getU64Encoder()],
            ["actualPendingBalanceCreditCounter", web3_js.getU64Encoder()]
          ]),
          web3_js.getU16Encoder()
        )
      ],
      [
        "DefaultAccountState",
        web3_js.addEncoderSizePrefix(
          web3_js.getStructEncoder([["state", getAccountStateEncoder()]]),
          web3_js.getU16Encoder()
        )
      ],
      [
        "ImmutableOwner",
        web3_js.addEncoderSizePrefix(web3_js.getStructEncoder([]), web3_js.getU16Encoder())
      ],
      [
        "MemoTransfer",
        web3_js.addEncoderSizePrefix(
          web3_js.getStructEncoder([
            ["requireIncomingTransferMemos", web3_js.getBooleanEncoder()]
          ]),
          web3_js.getU16Encoder()
        )
      ],
      [
        "NonTransferable",
        web3_js.addEncoderSizePrefix(web3_js.getStructEncoder([]), web3_js.getU16Encoder())
      ],
      [
        "InterestBearingConfig",
        web3_js.addEncoderSizePrefix(
          web3_js.getStructEncoder([
            ["rateAuthority", web3_js.getAddressEncoder()],
            ["initializationTimestamp", web3_js.getU64Encoder()],
            ["preUpdateAverageRate", web3_js.getI16Encoder()],
            ["lastUpdateTimestamp", web3_js.getU64Encoder()],
            ["currentRate", web3_js.getI16Encoder()]
          ]),
          web3_js.getU16Encoder()
        )
      ],
      [
        "CpiGuard",
        web3_js.addEncoderSizePrefix(
          web3_js.getStructEncoder([["lockCpi", web3_js.getBooleanEncoder()]]),
          web3_js.getU16Encoder()
        )
      ],
      [
        "PermanentDelegate",
        web3_js.addEncoderSizePrefix(
          web3_js.getStructEncoder([["delegate", web3_js.getAddressEncoder()]]),
          web3_js.getU16Encoder()
        )
      ],
      [
        "NonTransferableAccount",
        web3_js.addEncoderSizePrefix(web3_js.getStructEncoder([]), web3_js.getU16Encoder())
      ],
      [
        "TransferHook",
        web3_js.addEncoderSizePrefix(
          web3_js.getStructEncoder([
            ["authority", web3_js.getAddressEncoder()],
            ["programId", web3_js.getAddressEncoder()]
          ]),
          web3_js.getU16Encoder()
        )
      ],
      [
        "TransferHookAccount",
        web3_js.addEncoderSizePrefix(
          web3_js.getStructEncoder([["transferring", web3_js.getBooleanEncoder()]]),
          web3_js.getU16Encoder()
        )
      ],
      [
        "ConfidentialTransferFee",
        web3_js.addEncoderSizePrefix(
          web3_js.getStructEncoder([
            [
              "authority",
              web3_js.getOptionEncoder(web3_js.getAddressEncoder(), {
                prefix: null,
                noneValue: "zeroes"
              })
            ],
            ["elgamalPubkey", web3_js.getAddressEncoder()],
            ["harvestToMintEnabled", web3_js.getBooleanEncoder()],
            ["withheldAmount", getEncryptedBalanceEncoder()]
          ]),
          web3_js.getU16Encoder()
        )
      ],
      [
        "ConfidentialTransferFeeAmount",
        web3_js.addEncoderSizePrefix(
          web3_js.getStructEncoder([["withheldAmount", getEncryptedBalanceEncoder()]]),
          web3_js.getU16Encoder()
        )
      ],
      [
        "MetadataPointer",
        web3_js.addEncoderSizePrefix(
          web3_js.getStructEncoder([
            [
              "authority",
              web3_js.getOptionEncoder(web3_js.getAddressEncoder(), {
                prefix: null,
                noneValue: "zeroes"
              })
            ],
            [
              "metadataAddress",
              web3_js.getOptionEncoder(web3_js.getAddressEncoder(), {
                prefix: null,
                noneValue: "zeroes"
              })
            ]
          ]),
          web3_js.getU16Encoder()
        )
      ],
      [
        "TokenMetadata",
        web3_js.addEncoderSizePrefix(
          web3_js.getStructEncoder([
            [
              "updateAuthority",
              web3_js.getOptionEncoder(web3_js.getAddressEncoder(), {
                prefix: null,
                noneValue: "zeroes"
              })
            ],
            ["mint", web3_js.getAddressEncoder()],
            ["name", web3_js.addEncoderSizePrefix(web3_js.getUtf8Encoder(), web3_js.getU32Encoder())],
            ["symbol", web3_js.addEncoderSizePrefix(web3_js.getUtf8Encoder(), web3_js.getU32Encoder())],
            ["uri", web3_js.addEncoderSizePrefix(web3_js.getUtf8Encoder(), web3_js.getU32Encoder())],
            [
              "additionalMetadata",
              web3_js.getMapEncoder(
                web3_js.addEncoderSizePrefix(web3_js.getUtf8Encoder(), web3_js.getU32Encoder()),
                web3_js.addEncoderSizePrefix(web3_js.getUtf8Encoder(), web3_js.getU32Encoder())
              )
            ]
          ]),
          web3_js.getU16Encoder()
        )
      ],
      [
        "GroupPointer",
        web3_js.addEncoderSizePrefix(
          web3_js.getStructEncoder([
            [
              "authority",
              web3_js.getOptionEncoder(web3_js.getAddressEncoder(), {
                prefix: null,
                noneValue: "zeroes"
              })
            ],
            [
              "groupAddress",
              web3_js.getOptionEncoder(web3_js.getAddressEncoder(), {
                prefix: null,
                noneValue: "zeroes"
              })
            ]
          ]),
          web3_js.getU16Encoder()
        )
      ],
      [
        "TokenGroup",
        web3_js.addEncoderSizePrefix(
          web3_js.getStructEncoder([
            [
              "updateAuthority",
              web3_js.getOptionEncoder(web3_js.getAddressEncoder(), {
                prefix: null,
                noneValue: "zeroes"
              })
            ],
            ["mint", web3_js.getAddressEncoder()],
            ["size", web3_js.getU64Encoder()],
            ["maxSize", web3_js.getU64Encoder()]
          ]),
          web3_js.getU16Encoder()
        )
      ],
      [
        "GroupMemberPointer",
        web3_js.addEncoderSizePrefix(
          web3_js.getStructEncoder([
            [
              "authority",
              web3_js.getOptionEncoder(web3_js.getAddressEncoder(), {
                prefix: null,
                noneValue: "zeroes"
              })
            ],
            [
              "memberAddress",
              web3_js.getOptionEncoder(web3_js.getAddressEncoder(), {
                prefix: null,
                noneValue: "zeroes"
              })
            ]
          ]),
          web3_js.getU16Encoder()
        )
      ],
      [
        "TokenGroupMember",
        web3_js.addEncoderSizePrefix(
          web3_js.getStructEncoder([
            ["mint", web3_js.getAddressEncoder()],
            ["group", web3_js.getAddressEncoder()],
            ["memberNumber", web3_js.getU64Encoder()]
          ]),
          web3_js.getU16Encoder()
        )
      ]
    ],
    { size: web3_js.getU16Encoder() }
  );
}
function getExtensionDecoder() {
  return web3_js.getDiscriminatedUnionDecoder(
    [
      ["Uninitialized", web3_js.getUnitDecoder()],
      [
        "TransferFeeConfig",
        web3_js.addDecoderSizePrefix(
          web3_js.getStructDecoder([
            ["transferFeeConfigAuthority", web3_js.getAddressDecoder()],
            ["withdrawWithheldAuthority", web3_js.getAddressDecoder()],
            ["withheldAmount", web3_js.getU64Decoder()],
            ["olderTransferFee", getTransferFeeDecoder()],
            ["newerTransferFee", getTransferFeeDecoder()]
          ]),
          web3_js.getU16Decoder()
        )
      ],
      [
        "TransferFeeAmount",
        web3_js.addDecoderSizePrefix(
          web3_js.getStructDecoder([["withheldAmount", web3_js.getU64Decoder()]]),
          web3_js.getU16Decoder()
        )
      ],
      [
        "MintCloseAuthority",
        web3_js.addDecoderSizePrefix(
          web3_js.getStructDecoder([["closeAuthority", web3_js.getAddressDecoder()]]),
          web3_js.getU16Decoder()
        )
      ],
      [
        "ConfidentialTransferMint",
        web3_js.addDecoderSizePrefix(
          web3_js.getStructDecoder([
            [
              "authority",
              web3_js.getOptionDecoder(web3_js.getAddressDecoder(), {
                prefix: null,
                noneValue: "zeroes"
              })
            ],
            ["autoApproveNewAccounts", web3_js.getBooleanDecoder()],
            [
              "auditorElgamalPubkey",
              web3_js.getOptionDecoder(web3_js.getAddressDecoder(), {
                prefix: null,
                noneValue: "zeroes"
              })
            ]
          ]),
          web3_js.getU16Decoder()
        )
      ],
      [
        "ConfidentialTransferAccount",
        web3_js.addDecoderSizePrefix(
          web3_js.getStructDecoder([
            ["approved", web3_js.getBooleanDecoder()],
            ["elgamalPubkey", web3_js.getAddressDecoder()],
            ["pendingBalanceLow", getEncryptedBalanceDecoder()],
            ["pendingBalanceHigh", getEncryptedBalanceDecoder()],
            ["availableBalance", getEncryptedBalanceDecoder()],
            ["decryptableAvailableBalance", getDecryptableBalanceDecoder()],
            ["allowConfidentialCredits", web3_js.getBooleanDecoder()],
            ["allowNonConfidentialCredits", web3_js.getBooleanDecoder()],
            ["pendingBalanceCreditCounter", web3_js.getU64Decoder()],
            ["maximumPendingBalanceCreditCounter", web3_js.getU64Decoder()],
            ["expectedPendingBalanceCreditCounter", web3_js.getU64Decoder()],
            ["actualPendingBalanceCreditCounter", web3_js.getU64Decoder()]
          ]),
          web3_js.getU16Decoder()
        )
      ],
      [
        "DefaultAccountState",
        web3_js.addDecoderSizePrefix(
          web3_js.getStructDecoder([["state", getAccountStateDecoder()]]),
          web3_js.getU16Decoder()
        )
      ],
      [
        "ImmutableOwner",
        web3_js.addDecoderSizePrefix(web3_js.getStructDecoder([]), web3_js.getU16Decoder())
      ],
      [
        "MemoTransfer",
        web3_js.addDecoderSizePrefix(
          web3_js.getStructDecoder([
            ["requireIncomingTransferMemos", web3_js.getBooleanDecoder()]
          ]),
          web3_js.getU16Decoder()
        )
      ],
      [
        "NonTransferable",
        web3_js.addDecoderSizePrefix(web3_js.getStructDecoder([]), web3_js.getU16Decoder())
      ],
      [
        "InterestBearingConfig",
        web3_js.addDecoderSizePrefix(
          web3_js.getStructDecoder([
            ["rateAuthority", web3_js.getAddressDecoder()],
            ["initializationTimestamp", web3_js.getU64Decoder()],
            ["preUpdateAverageRate", web3_js.getI16Decoder()],
            ["lastUpdateTimestamp", web3_js.getU64Decoder()],
            ["currentRate", web3_js.getI16Decoder()]
          ]),
          web3_js.getU16Decoder()
        )
      ],
      [
        "CpiGuard",
        web3_js.addDecoderSizePrefix(
          web3_js.getStructDecoder([["lockCpi", web3_js.getBooleanDecoder()]]),
          web3_js.getU16Decoder()
        )
      ],
      [
        "PermanentDelegate",
        web3_js.addDecoderSizePrefix(
          web3_js.getStructDecoder([["delegate", web3_js.getAddressDecoder()]]),
          web3_js.getU16Decoder()
        )
      ],
      [
        "NonTransferableAccount",
        web3_js.addDecoderSizePrefix(web3_js.getStructDecoder([]), web3_js.getU16Decoder())
      ],
      [
        "TransferHook",
        web3_js.addDecoderSizePrefix(
          web3_js.getStructDecoder([
            ["authority", web3_js.getAddressDecoder()],
            ["programId", web3_js.getAddressDecoder()]
          ]),
          web3_js.getU16Decoder()
        )
      ],
      [
        "TransferHookAccount",
        web3_js.addDecoderSizePrefix(
          web3_js.getStructDecoder([["transferring", web3_js.getBooleanDecoder()]]),
          web3_js.getU16Decoder()
        )
      ],
      [
        "ConfidentialTransferFee",
        web3_js.addDecoderSizePrefix(
          web3_js.getStructDecoder([
            [
              "authority",
              web3_js.getOptionDecoder(web3_js.getAddressDecoder(), {
                prefix: null,
                noneValue: "zeroes"
              })
            ],
            ["elgamalPubkey", web3_js.getAddressDecoder()],
            ["harvestToMintEnabled", web3_js.getBooleanDecoder()],
            ["withheldAmount", getEncryptedBalanceDecoder()]
          ]),
          web3_js.getU16Decoder()
        )
      ],
      [
        "ConfidentialTransferFeeAmount",
        web3_js.addDecoderSizePrefix(
          web3_js.getStructDecoder([["withheldAmount", getEncryptedBalanceDecoder()]]),
          web3_js.getU16Decoder()
        )
      ],
      [
        "MetadataPointer",
        web3_js.addDecoderSizePrefix(
          web3_js.getStructDecoder([
            [
              "authority",
              web3_js.getOptionDecoder(web3_js.getAddressDecoder(), {
                prefix: null,
                noneValue: "zeroes"
              })
            ],
            [
              "metadataAddress",
              web3_js.getOptionDecoder(web3_js.getAddressDecoder(), {
                prefix: null,
                noneValue: "zeroes"
              })
            ]
          ]),
          web3_js.getU16Decoder()
        )
      ],
      [
        "TokenMetadata",
        web3_js.addDecoderSizePrefix(
          web3_js.getStructDecoder([
            [
              "updateAuthority",
              web3_js.getOptionDecoder(web3_js.getAddressDecoder(), {
                prefix: null,
                noneValue: "zeroes"
              })
            ],
            ["mint", web3_js.getAddressDecoder()],
            ["name", web3_js.addDecoderSizePrefix(web3_js.getUtf8Decoder(), web3_js.getU32Decoder())],
            ["symbol", web3_js.addDecoderSizePrefix(web3_js.getUtf8Decoder(), web3_js.getU32Decoder())],
            ["uri", web3_js.addDecoderSizePrefix(web3_js.getUtf8Decoder(), web3_js.getU32Decoder())],
            [
              "additionalMetadata",
              web3_js.getMapDecoder(
                web3_js.addDecoderSizePrefix(web3_js.getUtf8Decoder(), web3_js.getU32Decoder()),
                web3_js.addDecoderSizePrefix(web3_js.getUtf8Decoder(), web3_js.getU32Decoder())
              )
            ]
          ]),
          web3_js.getU16Decoder()
        )
      ],
      [
        "GroupPointer",
        web3_js.addDecoderSizePrefix(
          web3_js.getStructDecoder([
            [
              "authority",
              web3_js.getOptionDecoder(web3_js.getAddressDecoder(), {
                prefix: null,
                noneValue: "zeroes"
              })
            ],
            [
              "groupAddress",
              web3_js.getOptionDecoder(web3_js.getAddressDecoder(), {
                prefix: null,
                noneValue: "zeroes"
              })
            ]
          ]),
          web3_js.getU16Decoder()
        )
      ],
      [
        "TokenGroup",
        web3_js.addDecoderSizePrefix(
          web3_js.getStructDecoder([
            [
              "updateAuthority",
              web3_js.getOptionDecoder(web3_js.getAddressDecoder(), {
                prefix: null,
                noneValue: "zeroes"
              })
            ],
            ["mint", web3_js.getAddressDecoder()],
            ["size", web3_js.getU64Decoder()],
            ["maxSize", web3_js.getU64Decoder()]
          ]),
          web3_js.getU16Decoder()
        )
      ],
      [
        "GroupMemberPointer",
        web3_js.addDecoderSizePrefix(
          web3_js.getStructDecoder([
            [
              "authority",
              web3_js.getOptionDecoder(web3_js.getAddressDecoder(), {
                prefix: null,
                noneValue: "zeroes"
              })
            ],
            [
              "memberAddress",
              web3_js.getOptionDecoder(web3_js.getAddressDecoder(), {
                prefix: null,
                noneValue: "zeroes"
              })
            ]
          ]),
          web3_js.getU16Decoder()
        )
      ],
      [
        "TokenGroupMember",
        web3_js.addDecoderSizePrefix(
          web3_js.getStructDecoder([
            ["mint", web3_js.getAddressDecoder()],
            ["group", web3_js.getAddressDecoder()],
            ["memberNumber", web3_js.getU64Decoder()]
          ]),
          web3_js.getU16Decoder()
        )
      ]
    ],
    { size: web3_js.getU16Decoder() }
  );
}
function getExtensionCodec() {
  return web3_js.combineCodec(getExtensionEncoder(), getExtensionDecoder());
}
function extension(kind, data) {
  return Array.isArray(data) ? { __kind: kind, fields: data } : { __kind: kind, ...data ?? {} };
}
function isExtension(kind, value) {
  return value.__kind === kind;
}
var ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {
  ExtensionType2[ExtensionType2["Uninitialized"] = 0] = "Uninitialized";
  ExtensionType2[ExtensionType2["TransferFeeConfig"] = 1] = "TransferFeeConfig";
  ExtensionType2[ExtensionType2["TransferFeeAmount"] = 2] = "TransferFeeAmount";
  ExtensionType2[ExtensionType2["MintCloseAuthority"] = 3] = "MintCloseAuthority";
  ExtensionType2[ExtensionType2["ConfidentialTransferMint"] = 4] = "ConfidentialTransferMint";
  ExtensionType2[ExtensionType2["ConfidentialTransferAccount"] = 5] = "ConfidentialTransferAccount";
  ExtensionType2[ExtensionType2["DefaultAccountState"] = 6] = "DefaultAccountState";
  ExtensionType2[ExtensionType2["ImmutableOwner"] = 7] = "ImmutableOwner";
  ExtensionType2[ExtensionType2["MemoTransfer"] = 8] = "MemoTransfer";
  ExtensionType2[ExtensionType2["NonTransferable"] = 9] = "NonTransferable";
  ExtensionType2[ExtensionType2["InterestBearingConfig"] = 10] = "InterestBearingConfig";
  ExtensionType2[ExtensionType2["CpiGuard"] = 11] = "CpiGuard";
  ExtensionType2[ExtensionType2["PermanentDelegate"] = 12] = "PermanentDelegate";
  ExtensionType2[ExtensionType2["NonTransferableAccount"] = 13] = "NonTransferableAccount";
  ExtensionType2[ExtensionType2["TransferHook"] = 14] = "TransferHook";
  ExtensionType2[ExtensionType2["TransferHookAccount"] = 15] = "TransferHookAccount";
  ExtensionType2[ExtensionType2["ConfidentialTransferFee"] = 16] = "ConfidentialTransferFee";
  ExtensionType2[ExtensionType2["ConfidentialTransferFeeAmount"] = 17] = "ConfidentialTransferFeeAmount";
  ExtensionType2[ExtensionType2["MetadataPointer"] = 18] = "MetadataPointer";
  ExtensionType2[ExtensionType2["TokenMetadata"] = 19] = "TokenMetadata";
  ExtensionType2[ExtensionType2["GroupPointer"] = 20] = "GroupPointer";
  ExtensionType2[ExtensionType2["TokenGroup"] = 21] = "TokenGroup";
  ExtensionType2[ExtensionType2["GroupMemberPointer"] = 22] = "GroupMemberPointer";
  ExtensionType2[ExtensionType2["TokenGroupMember"] = 23] = "TokenGroupMember";
  return ExtensionType2;
})(ExtensionType || {});
function getExtensionTypeEncoder() {
  return web3_js.getEnumEncoder(ExtensionType, { size: web3_js.getU16Encoder() });
}
function getExtensionTypeDecoder() {
  return web3_js.getEnumDecoder(ExtensionType, { size: web3_js.getU16Decoder() });
}
function getExtensionTypeCodec() {
  return web3_js.combineCodec(getExtensionTypeEncoder(), getExtensionTypeDecoder());
}
function getTokenMetadataFieldEncoder() {
  return web3_js.getDiscriminatedUnionEncoder([
    ["Name", web3_js.getUnitEncoder()],
    ["Symbol", web3_js.getUnitEncoder()],
    ["Uri", web3_js.getUnitEncoder()],
    [
      "Key",
      web3_js.getStructEncoder([
        [
          "fields",
          web3_js.getTupleEncoder([
            web3_js.addEncoderSizePrefix(web3_js.getUtf8Encoder(), web3_js.getU32Encoder())
          ])
        ]
      ])
    ]
  ]);
}
function getTokenMetadataFieldDecoder() {
  return web3_js.getDiscriminatedUnionDecoder([
    ["Name", web3_js.getUnitDecoder()],
    ["Symbol", web3_js.getUnitDecoder()],
    ["Uri", web3_js.getUnitDecoder()],
    [
      "Key",
      web3_js.getStructDecoder([
        [
          "fields",
          web3_js.getTupleDecoder([
            web3_js.addDecoderSizePrefix(web3_js.getUtf8Decoder(), web3_js.getU32Decoder())
          ])
        ]
      ])
    ]
  ]);
}
function getTokenMetadataFieldCodec() {
  return web3_js.combineCodec(
    getTokenMetadataFieldEncoder(),
    getTokenMetadataFieldDecoder()
  );
}
function tokenMetadataField(kind, data) {
  return Array.isArray(data) ? { __kind: kind, fields: data } : { __kind: kind, ...data ?? {} };
}
function isTokenMetadataField(kind, value) {
  return value.__kind === kind;
}
function getTransferFeeEncoder() {
  return web3_js.getStructEncoder([
    ["epoch", web3_js.getU64Encoder()],
    ["maximumFee", web3_js.getU64Encoder()],
    ["transferFeeBasisPoints", web3_js.getU16Encoder()]
  ]);
}
function getTransferFeeDecoder() {
  return web3_js.getStructDecoder([
    ["epoch", web3_js.getU64Decoder()],
    ["maximumFee", web3_js.getU64Decoder()],
    ["transferFeeBasisPoints", web3_js.getU16Decoder()]
  ]);
}
function getTransferFeeCodec() {
  return web3_js.combineCodec(getTransferFeeEncoder(), getTransferFeeDecoder());
}

// src/generated/accounts/mint.ts
function getMintEncoder() {
  return web3_js.getStructEncoder([
    [
      "mintAuthority",
      web3_js.getOptionEncoder(web3_js.getAddressEncoder(), {
        prefix: web3_js.getU32Encoder(),
        noneValue: "zeroes"
      })
    ],
    ["supply", web3_js.getU64Encoder()],
    ["decimals", web3_js.getU8Encoder()],
    ["isInitialized", web3_js.getBooleanEncoder()],
    [
      "freezeAuthority",
      web3_js.getOptionEncoder(web3_js.getAddressEncoder(), {
        prefix: web3_js.getU32Encoder(),
        noneValue: "zeroes"
      })
    ],
    [
      "extensions",
      web3_js.getOptionEncoder(
        web3_js.getHiddenPrefixEncoder(
          web3_js.getArrayEncoder(getExtensionEncoder(), { size: "remainder" }),
          [web3_js.getConstantEncoder(web3_js.padLeftEncoder(web3_js.getU8Encoder(), 83).encode(1))]
        ),
        { prefix: null }
      )
    ]
  ]);
}
function getMintDecoder() {
  return web3_js.getStructDecoder([
    [
      "mintAuthority",
      web3_js.getOptionDecoder(web3_js.getAddressDecoder(), {
        prefix: web3_js.getU32Decoder(),
        noneValue: "zeroes"
      })
    ],
    ["supply", web3_js.getU64Decoder()],
    ["decimals", web3_js.getU8Decoder()],
    ["isInitialized", web3_js.getBooleanDecoder()],
    [
      "freezeAuthority",
      web3_js.getOptionDecoder(web3_js.getAddressDecoder(), {
        prefix: web3_js.getU32Decoder(),
        noneValue: "zeroes"
      })
    ],
    [
      "extensions",
      web3_js.getOptionDecoder(
        web3_js.getHiddenPrefixDecoder(
          web3_js.getArrayDecoder(getExtensionDecoder(), { size: "remainder" }),
          [web3_js.getConstantDecoder(web3_js.padLeftEncoder(web3_js.getU8Encoder(), 83).encode(1))]
        ),
        { prefix: null }
      )
    ]
  ]);
}
function getMintCodec() {
  return web3_js.combineCodec(getMintEncoder(), getMintDecoder());
}
function decodeMint(encodedAccount) {
  return web3_js.decodeAccount(
    encodedAccount,
    getMintDecoder()
  );
}
async function fetchMint(rpc, address, config) {
  const maybeAccount = await fetchMaybeMint(rpc, address, config);
  web3_js.assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeMint(rpc, address, config) {
  const maybeAccount = await web3_js.fetchEncodedAccount(rpc, address, config);
  return decodeMint(maybeAccount);
}
async function fetchAllMint(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeMint(rpc, addresses, config);
  web3_js.assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeMint(rpc, addresses, config) {
  const maybeAccounts = await web3_js.fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeMint(maybeAccount));
}
function getMultisigEncoder() {
  return web3_js.getStructEncoder([
    ["m", web3_js.getU8Encoder()],
    ["n", web3_js.getU8Encoder()],
    ["isInitialized", web3_js.getBooleanEncoder()],
    ["signers", web3_js.getArrayEncoder(web3_js.getAddressEncoder(), { size: 11 })]
  ]);
}
function getMultisigDecoder() {
  return web3_js.getStructDecoder([
    ["m", web3_js.getU8Decoder()],
    ["n", web3_js.getU8Decoder()],
    ["isInitialized", web3_js.getBooleanDecoder()],
    ["signers", web3_js.getArrayDecoder(web3_js.getAddressDecoder(), { size: 11 })]
  ]);
}
function getMultisigCodec() {
  return web3_js.combineCodec(getMultisigEncoder(), getMultisigDecoder());
}
function decodeMultisig(encodedAccount) {
  return web3_js.decodeAccount(
    encodedAccount,
    getMultisigDecoder()
  );
}
async function fetchMultisig(rpc, address, config) {
  const maybeAccount = await fetchMaybeMultisig(rpc, address, config);
  web3_js.assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeMultisig(rpc, address, config) {
  const maybeAccount = await web3_js.fetchEncodedAccount(rpc, address, config);
  return decodeMultisig(maybeAccount);
}
async function fetchAllMultisig(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeMultisig(rpc, addresses, config);
  web3_js.assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeMultisig(rpc, addresses, config) {
  const maybeAccounts = await web3_js.fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeMultisig(maybeAccount));
}
function getMultisigSize() {
  return 355;
}
function getTokenEncoder() {
  return web3_js.getStructEncoder([
    ["mint", web3_js.getAddressEncoder()],
    ["owner", web3_js.getAddressEncoder()],
    ["amount", web3_js.getU64Encoder()],
    [
      "delegate",
      web3_js.getOptionEncoder(web3_js.getAddressEncoder(), {
        prefix: web3_js.getU32Encoder(),
        noneValue: "zeroes"
      })
    ],
    ["state", getAccountStateEncoder()],
    [
      "isNative",
      web3_js.getOptionEncoder(web3_js.getU64Encoder(), {
        prefix: web3_js.getU32Encoder(),
        noneValue: "zeroes"
      })
    ],
    ["delegatedAmount", web3_js.getU64Encoder()],
    [
      "closeAuthority",
      web3_js.getOptionEncoder(web3_js.getAddressEncoder(), {
        prefix: web3_js.getU32Encoder(),
        noneValue: "zeroes"
      })
    ],
    [
      "extensions",
      web3_js.getOptionEncoder(
        web3_js.getHiddenPrefixEncoder(
          web3_js.getArrayEncoder(getExtensionEncoder(), { size: "remainder" }),
          [web3_js.getConstantEncoder(web3_js.getU8Encoder().encode(2))]
        ),
        { prefix: null }
      )
    ]
  ]);
}
function getTokenDecoder() {
  return web3_js.getStructDecoder([
    ["mint", web3_js.getAddressDecoder()],
    ["owner", web3_js.getAddressDecoder()],
    ["amount", web3_js.getU64Decoder()],
    [
      "delegate",
      web3_js.getOptionDecoder(web3_js.getAddressDecoder(), {
        prefix: web3_js.getU32Decoder(),
        noneValue: "zeroes"
      })
    ],
    ["state", getAccountStateDecoder()],
    [
      "isNative",
      web3_js.getOptionDecoder(web3_js.getU64Decoder(), {
        prefix: web3_js.getU32Decoder(),
        noneValue: "zeroes"
      })
    ],
    ["delegatedAmount", web3_js.getU64Decoder()],
    [
      "closeAuthority",
      web3_js.getOptionDecoder(web3_js.getAddressDecoder(), {
        prefix: web3_js.getU32Decoder(),
        noneValue: "zeroes"
      })
    ],
    [
      "extensions",
      web3_js.getOptionDecoder(
        web3_js.getHiddenPrefixDecoder(
          web3_js.getArrayDecoder(getExtensionDecoder(), { size: "remainder" }),
          [web3_js.getConstantDecoder(web3_js.getU8Encoder().encode(2))]
        ),
        { prefix: null }
      )
    ]
  ]);
}
function getTokenCodec() {
  return web3_js.combineCodec(getTokenEncoder(), getTokenDecoder());
}
function decodeToken(encodedAccount) {
  return web3_js.decodeAccount(
    encodedAccount,
    getTokenDecoder()
  );
}
async function fetchToken(rpc, address, config) {
  const maybeAccount = await fetchMaybeToken(rpc, address, config);
  web3_js.assertAccountExists(maybeAccount);
  return maybeAccount;
}
async function fetchMaybeToken(rpc, address, config) {
  const maybeAccount = await web3_js.fetchEncodedAccount(rpc, address, config);
  return decodeToken(maybeAccount);
}
async function fetchAllToken(rpc, addresses, config) {
  const maybeAccounts = await fetchAllMaybeToken(rpc, addresses, config);
  web3_js.assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}
async function fetchAllMaybeToken(rpc, addresses, config) {
  const maybeAccounts = await web3_js.fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeToken(maybeAccount));
}
var ASSOCIATED_TOKEN_PROGRAM_ADDRESS = "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL";
var AssociatedTokenInstruction = /* @__PURE__ */ ((AssociatedTokenInstruction2) => {
  AssociatedTokenInstruction2[AssociatedTokenInstruction2["CreateAssociatedToken"] = 0] = "CreateAssociatedToken";
  AssociatedTokenInstruction2[AssociatedTokenInstruction2["CreateAssociatedTokenIdempotent"] = 1] = "CreateAssociatedTokenIdempotent";
  AssociatedTokenInstruction2[AssociatedTokenInstruction2["RecoverNestedAssociatedToken"] = 2] = "RecoverNestedAssociatedToken";
  return AssociatedTokenInstruction2;
})(AssociatedTokenInstruction || {});
function identifyAssociatedTokenInstruction(instruction) {
  const data = "data" in instruction ? instruction.data : instruction;
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(0), 0)) {
    return 0 /* CreateAssociatedToken */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(1), 0)) {
    return 1 /* CreateAssociatedTokenIdempotent */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(2), 0)) {
    return 2 /* RecoverNestedAssociatedToken */;
  }
  throw new Error(
    "The provided instruction could not be identified as a associatedToken instruction."
  );
}
var TOKEN_2022_PROGRAM_ADDRESS = "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb";
var Token2022Account = /* @__PURE__ */ ((Token2022Account2) => {
  Token2022Account2[Token2022Account2["Mint"] = 0] = "Mint";
  Token2022Account2[Token2022Account2["Token"] = 1] = "Token";
  Token2022Account2[Token2022Account2["Multisig"] = 2] = "Multisig";
  return Token2022Account2;
})(Token2022Account || {});
function identifyToken2022Account(account) {
  const data = "data" in account ? account.data : account;
  if (data.length === 82) {
    return 0 /* Mint */;
  }
  if (data.length === 165) {
    return 1 /* Token */;
  }
  if (data.length === 355) {
    return 2 /* Multisig */;
  }
  throw new Error(
    "The provided account could not be identified as a token-2022 account."
  );
}
var Token2022Instruction = /* @__PURE__ */ ((Token2022Instruction2) => {
  Token2022Instruction2[Token2022Instruction2["InitializeMint"] = 0] = "InitializeMint";
  Token2022Instruction2[Token2022Instruction2["InitializeAccount"] = 1] = "InitializeAccount";
  Token2022Instruction2[Token2022Instruction2["InitializeMultisig"] = 2] = "InitializeMultisig";
  Token2022Instruction2[Token2022Instruction2["Transfer"] = 3] = "Transfer";
  Token2022Instruction2[Token2022Instruction2["Approve"] = 4] = "Approve";
  Token2022Instruction2[Token2022Instruction2["Revoke"] = 5] = "Revoke";
  Token2022Instruction2[Token2022Instruction2["SetAuthority"] = 6] = "SetAuthority";
  Token2022Instruction2[Token2022Instruction2["MintTo"] = 7] = "MintTo";
  Token2022Instruction2[Token2022Instruction2["Burn"] = 8] = "Burn";
  Token2022Instruction2[Token2022Instruction2["CloseAccount"] = 9] = "CloseAccount";
  Token2022Instruction2[Token2022Instruction2["FreezeAccount"] = 10] = "FreezeAccount";
  Token2022Instruction2[Token2022Instruction2["ThawAccount"] = 11] = "ThawAccount";
  Token2022Instruction2[Token2022Instruction2["TransferChecked"] = 12] = "TransferChecked";
  Token2022Instruction2[Token2022Instruction2["ApproveChecked"] = 13] = "ApproveChecked";
  Token2022Instruction2[Token2022Instruction2["MintToChecked"] = 14] = "MintToChecked";
  Token2022Instruction2[Token2022Instruction2["BurnChecked"] = 15] = "BurnChecked";
  Token2022Instruction2[Token2022Instruction2["InitializeAccount2"] = 16] = "InitializeAccount2";
  Token2022Instruction2[Token2022Instruction2["SyncNative"] = 17] = "SyncNative";
  Token2022Instruction2[Token2022Instruction2["InitializeAccount3"] = 18] = "InitializeAccount3";
  Token2022Instruction2[Token2022Instruction2["InitializeMultisig2"] = 19] = "InitializeMultisig2";
  Token2022Instruction2[Token2022Instruction2["InitializeMint2"] = 20] = "InitializeMint2";
  Token2022Instruction2[Token2022Instruction2["GetAccountDataSize"] = 21] = "GetAccountDataSize";
  Token2022Instruction2[Token2022Instruction2["InitializeImmutableOwner"] = 22] = "InitializeImmutableOwner";
  Token2022Instruction2[Token2022Instruction2["AmountToUiAmount"] = 23] = "AmountToUiAmount";
  Token2022Instruction2[Token2022Instruction2["UiAmountToAmount"] = 24] = "UiAmountToAmount";
  Token2022Instruction2[Token2022Instruction2["InitializeMintCloseAuthority"] = 25] = "InitializeMintCloseAuthority";
  Token2022Instruction2[Token2022Instruction2["InitializeTransferFeeConfig"] = 26] = "InitializeTransferFeeConfig";
  Token2022Instruction2[Token2022Instruction2["TransferCheckedWithFee"] = 27] = "TransferCheckedWithFee";
  Token2022Instruction2[Token2022Instruction2["WithdrawWithheldTokensFromMint"] = 28] = "WithdrawWithheldTokensFromMint";
  Token2022Instruction2[Token2022Instruction2["WithdrawWithheldTokensFromAccounts"] = 29] = "WithdrawWithheldTokensFromAccounts";
  Token2022Instruction2[Token2022Instruction2["HarvestWithheldTokensToMint"] = 30] = "HarvestWithheldTokensToMint";
  Token2022Instruction2[Token2022Instruction2["SetTransferFee"] = 31] = "SetTransferFee";
  Token2022Instruction2[Token2022Instruction2["InitializeConfidentialTransferMint"] = 32] = "InitializeConfidentialTransferMint";
  Token2022Instruction2[Token2022Instruction2["UpdateConfidentialTransferMint"] = 33] = "UpdateConfidentialTransferMint";
  Token2022Instruction2[Token2022Instruction2["ConfigureConfidentialTransferAccount"] = 34] = "ConfigureConfidentialTransferAccount";
  Token2022Instruction2[Token2022Instruction2["ApproveConfidentialTransferAccount"] = 35] = "ApproveConfidentialTransferAccount";
  Token2022Instruction2[Token2022Instruction2["EmptyConfidentialTransferAccount"] = 36] = "EmptyConfidentialTransferAccount";
  Token2022Instruction2[Token2022Instruction2["ConfidentialDeposit"] = 37] = "ConfidentialDeposit";
  Token2022Instruction2[Token2022Instruction2["ConfidentialWithdraw"] = 38] = "ConfidentialWithdraw";
  Token2022Instruction2[Token2022Instruction2["ConfidentialTransfer"] = 39] = "ConfidentialTransfer";
  Token2022Instruction2[Token2022Instruction2["ApplyConfidentialPendingBalance"] = 40] = "ApplyConfidentialPendingBalance";
  Token2022Instruction2[Token2022Instruction2["EnableConfidentialCredits"] = 41] = "EnableConfidentialCredits";
  Token2022Instruction2[Token2022Instruction2["DisableConfidentialCredits"] = 42] = "DisableConfidentialCredits";
  Token2022Instruction2[Token2022Instruction2["EnableNonConfidentialCredits"] = 43] = "EnableNonConfidentialCredits";
  Token2022Instruction2[Token2022Instruction2["DisableNonConfidentialCredits"] = 44] = "DisableNonConfidentialCredits";
  Token2022Instruction2[Token2022Instruction2["ConfidentialTransferWithFee"] = 45] = "ConfidentialTransferWithFee";
  Token2022Instruction2[Token2022Instruction2["InitializeDefaultAccountState"] = 46] = "InitializeDefaultAccountState";
  Token2022Instruction2[Token2022Instruction2["UpdateDefaultAccountState"] = 47] = "UpdateDefaultAccountState";
  Token2022Instruction2[Token2022Instruction2["Reallocate"] = 48] = "Reallocate";
  Token2022Instruction2[Token2022Instruction2["EnableMemoTransfers"] = 49] = "EnableMemoTransfers";
  Token2022Instruction2[Token2022Instruction2["DisableMemoTransfers"] = 50] = "DisableMemoTransfers";
  Token2022Instruction2[Token2022Instruction2["CreateNativeMint"] = 51] = "CreateNativeMint";
  Token2022Instruction2[Token2022Instruction2["InitializeNonTransferableMint"] = 52] = "InitializeNonTransferableMint";
  Token2022Instruction2[Token2022Instruction2["InitializeInterestBearingMint"] = 53] = "InitializeInterestBearingMint";
  Token2022Instruction2[Token2022Instruction2["UpdateRateInterestBearingMint"] = 54] = "UpdateRateInterestBearingMint";
  Token2022Instruction2[Token2022Instruction2["EnableCpiGuard"] = 55] = "EnableCpiGuard";
  Token2022Instruction2[Token2022Instruction2["DisableCpiGuard"] = 56] = "DisableCpiGuard";
  Token2022Instruction2[Token2022Instruction2["InitializePermanentDelegate"] = 57] = "InitializePermanentDelegate";
  Token2022Instruction2[Token2022Instruction2["InitializeTransferHook"] = 58] = "InitializeTransferHook";
  Token2022Instruction2[Token2022Instruction2["UpdateTransferHook"] = 59] = "UpdateTransferHook";
  Token2022Instruction2[Token2022Instruction2["InitializeConfidentialTransferFee"] = 60] = "InitializeConfidentialTransferFee";
  Token2022Instruction2[Token2022Instruction2["WithdrawWithheldTokensFromMintForConfidentialTransferFee"] = 61] = "WithdrawWithheldTokensFromMintForConfidentialTransferFee";
  Token2022Instruction2[Token2022Instruction2["WithdrawWithheldTokensFromAccountsForConfidentialTransferFee"] = 62] = "WithdrawWithheldTokensFromAccountsForConfidentialTransferFee";
  Token2022Instruction2[Token2022Instruction2["HarvestWithheldTokensToMintForConfidentialTransferFee"] = 63] = "HarvestWithheldTokensToMintForConfidentialTransferFee";
  Token2022Instruction2[Token2022Instruction2["EnableHarvestToMint"] = 64] = "EnableHarvestToMint";
  Token2022Instruction2[Token2022Instruction2["DisableHarvestToMint"] = 65] = "DisableHarvestToMint";
  Token2022Instruction2[Token2022Instruction2["WithdrawExcessLamports"] = 66] = "WithdrawExcessLamports";
  Token2022Instruction2[Token2022Instruction2["InitializeMetadataPointer"] = 67] = "InitializeMetadataPointer";
  Token2022Instruction2[Token2022Instruction2["UpdateMetadataPointer"] = 68] = "UpdateMetadataPointer";
  Token2022Instruction2[Token2022Instruction2["InitializeGroupPointer"] = 69] = "InitializeGroupPointer";
  Token2022Instruction2[Token2022Instruction2["UpdateGroupPointer"] = 70] = "UpdateGroupPointer";
  Token2022Instruction2[Token2022Instruction2["InitializeGroupMemberPointer"] = 71] = "InitializeGroupMemberPointer";
  Token2022Instruction2[Token2022Instruction2["UpdateGroupMemberPointer"] = 72] = "UpdateGroupMemberPointer";
  Token2022Instruction2[Token2022Instruction2["InitializeTokenMetadata"] = 73] = "InitializeTokenMetadata";
  Token2022Instruction2[Token2022Instruction2["UpdateTokenMetadataField"] = 74] = "UpdateTokenMetadataField";
  Token2022Instruction2[Token2022Instruction2["RemoveTokenMetadataKey"] = 75] = "RemoveTokenMetadataKey";
  Token2022Instruction2[Token2022Instruction2["UpdateTokenMetadataUpdateAuthority"] = 76] = "UpdateTokenMetadataUpdateAuthority";
  Token2022Instruction2[Token2022Instruction2["EmitTokenMetadata"] = 77] = "EmitTokenMetadata";
  Token2022Instruction2[Token2022Instruction2["InitializeTokenGroup"] = 78] = "InitializeTokenGroup";
  Token2022Instruction2[Token2022Instruction2["UpdateTokenGroupMaxSize"] = 79] = "UpdateTokenGroupMaxSize";
  Token2022Instruction2[Token2022Instruction2["UpdateTokenGroupUpdateAuthority"] = 80] = "UpdateTokenGroupUpdateAuthority";
  Token2022Instruction2[Token2022Instruction2["InitializeTokenGroupMember"] = 81] = "InitializeTokenGroupMember";
  return Token2022Instruction2;
})(Token2022Instruction || {});
function identifyToken2022Instruction(instruction) {
  const data = "data" in instruction ? instruction.data : instruction;
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(0), 0)) {
    return 0 /* InitializeMint */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(1), 0)) {
    return 1 /* InitializeAccount */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(2), 0)) {
    return 2 /* InitializeMultisig */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(3), 0)) {
    return 3 /* Transfer */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(4), 0)) {
    return 4 /* Approve */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(5), 0)) {
    return 5 /* Revoke */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(6), 0)) {
    return 6 /* SetAuthority */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(7), 0)) {
    return 7 /* MintTo */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(8), 0)) {
    return 8 /* Burn */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(9), 0)) {
    return 9 /* CloseAccount */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(10), 0)) {
    return 10 /* FreezeAccount */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(11), 0)) {
    return 11 /* ThawAccount */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(12), 0)) {
    return 12 /* TransferChecked */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(13), 0)) {
    return 13 /* ApproveChecked */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(14), 0)) {
    return 14 /* MintToChecked */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(15), 0)) {
    return 15 /* BurnChecked */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(16), 0)) {
    return 16 /* InitializeAccount2 */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(17), 0)) {
    return 17 /* SyncNative */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(18), 0)) {
    return 18 /* InitializeAccount3 */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(19), 0)) {
    return 19 /* InitializeMultisig2 */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(20), 0)) {
    return 20 /* InitializeMint2 */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(21), 0)) {
    return 21 /* GetAccountDataSize */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(22), 0)) {
    return 22 /* InitializeImmutableOwner */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(23), 0)) {
    return 23 /* AmountToUiAmount */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(24), 0)) {
    return 24 /* UiAmountToAmount */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(25), 0)) {
    return 25 /* InitializeMintCloseAuthority */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(26), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(0), 1)) {
    return 26 /* InitializeTransferFeeConfig */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(26), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(1), 1)) {
    return 27 /* TransferCheckedWithFee */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(26), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(2), 1)) {
    return 28 /* WithdrawWithheldTokensFromMint */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(26), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(3), 1)) {
    return 29 /* WithdrawWithheldTokensFromAccounts */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(26), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(4), 1)) {
    return 30 /* HarvestWithheldTokensToMint */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(26), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(5), 1)) {
    return 31 /* SetTransferFee */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(27), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(0), 1)) {
    return 32 /* InitializeConfidentialTransferMint */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(27), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(1), 1)) {
    return 33 /* UpdateConfidentialTransferMint */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(27), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(2), 1)) {
    return 34 /* ConfigureConfidentialTransferAccount */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(27), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(3), 1)) {
    return 35 /* ApproveConfidentialTransferAccount */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(27), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(4), 1)) {
    return 36 /* EmptyConfidentialTransferAccount */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(27), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(5), 1)) {
    return 37 /* ConfidentialDeposit */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(27), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(6), 1)) {
    return 38 /* ConfidentialWithdraw */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(27), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(7), 1)) {
    return 39 /* ConfidentialTransfer */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(27), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(8), 1)) {
    return 40 /* ApplyConfidentialPendingBalance */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(27), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(9), 1)) {
    return 41 /* EnableConfidentialCredits */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(27), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(10), 1)) {
    return 42 /* DisableConfidentialCredits */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(27), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(11), 1)) {
    return 43 /* EnableNonConfidentialCredits */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(27), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(12), 1)) {
    return 44 /* DisableNonConfidentialCredits */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(27), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(13), 1)) {
    return 45 /* ConfidentialTransferWithFee */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(28), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(0), 1)) {
    return 46 /* InitializeDefaultAccountState */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(28), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(1), 1)) {
    return 47 /* UpdateDefaultAccountState */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(29), 0)) {
    return 48 /* Reallocate */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(30), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(0), 1)) {
    return 49 /* EnableMemoTransfers */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(30), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(1), 1)) {
    return 50 /* DisableMemoTransfers */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(31), 0)) {
    return 51 /* CreateNativeMint */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(32), 0)) {
    return 52 /* InitializeNonTransferableMint */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(33), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(0), 1)) {
    return 53 /* InitializeInterestBearingMint */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(33), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(1), 1)) {
    return 54 /* UpdateRateInterestBearingMint */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(34), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(0), 1)) {
    return 55 /* EnableCpiGuard */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(34), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(1), 1)) {
    return 56 /* DisableCpiGuard */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(35), 0)) {
    return 57 /* InitializePermanentDelegate */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(36), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(0), 1)) {
    return 58 /* InitializeTransferHook */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(36), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(1), 1)) {
    return 59 /* UpdateTransferHook */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(37), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(0), 1)) {
    return 60 /* InitializeConfidentialTransferFee */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(37), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(1), 1)) {
    return 61 /* WithdrawWithheldTokensFromMintForConfidentialTransferFee */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(37), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(2), 1)) {
    return 62 /* WithdrawWithheldTokensFromAccountsForConfidentialTransferFee */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(37), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(3), 1)) {
    return 63 /* HarvestWithheldTokensToMintForConfidentialTransferFee */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(37), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(4), 1)) {
    return 64 /* EnableHarvestToMint */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(37), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(5), 1)) {
    return 65 /* DisableHarvestToMint */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(38), 0)) {
    return 66 /* WithdrawExcessLamports */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(39), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(0), 1)) {
    return 67 /* InitializeMetadataPointer */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(39), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(1), 1)) {
    return 68 /* UpdateMetadataPointer */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(40), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(0), 1)) {
    return 69 /* InitializeGroupPointer */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(40), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(1), 1)) {
    return 70 /* UpdateGroupPointer */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(41), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(0), 1)) {
    return 71 /* InitializeGroupMemberPointer */;
  }
  if (web3_js.containsBytes(data, web3_js.getU8Encoder().encode(41), 0) && web3_js.containsBytes(data, web3_js.getU8Encoder().encode(1), 1)) {
    return 72 /* UpdateGroupMemberPointer */;
  }
  if (web3_js.containsBytes(
    data,
    new Uint8Array([210, 225, 30, 162, 88, 184, 77, 141]),
    0
  )) {
    return 73 /* InitializeTokenMetadata */;
  }
  if (web3_js.containsBytes(
    data,
    new Uint8Array([221, 233, 49, 45, 181, 202, 220, 200]),
    0
  )) {
    return 74 /* UpdateTokenMetadataField */;
  }
  if (web3_js.containsBytes(data, new Uint8Array([234, 18, 32, 56, 89, 141, 37, 181]), 0)) {
    return 75 /* RemoveTokenMetadataKey */;
  }
  if (web3_js.containsBytes(
    data,
    new Uint8Array([215, 228, 166, 228, 84, 100, 86, 123]),
    0
  )) {
    return 76 /* UpdateTokenMetadataUpdateAuthority */;
  }
  if (web3_js.containsBytes(
    data,
    new Uint8Array([250, 166, 180, 250, 13, 12, 184, 70]),
    0
  )) {
    return 77 /* EmitTokenMetadata */;
  }
  if (web3_js.containsBytes(data, new Uint8Array([121, 113, 108, 39, 54, 51, 0, 4]), 0)) {
    return 78 /* InitializeTokenGroup */;
  }
  if (web3_js.containsBytes(
    data,
    new Uint8Array([108, 37, 171, 143, 248, 30, 18, 110]),
    0
  )) {
    return 79 /* UpdateTokenGroupMaxSize */;
  }
  if (web3_js.containsBytes(
    data,
    new Uint8Array([161, 105, 88, 1, 237, 221, 216, 203]),
    0
  )) {
    return 80 /* UpdateTokenGroupUpdateAuthority */;
  }
  if (web3_js.containsBytes(
    data,
    new Uint8Array([152, 32, 222, 176, 223, 237, 116, 134]),
    0
  )) {
    return 81 /* InitializeTokenGroupMember */;
  }
  throw new Error(
    "The provided instruction could not be identified as a token-2022 instruction."
  );
}

// src/generated/errors/associatedToken.ts
var ASSOCIATED_TOKEN_ERROR__INVALID_OWNER = 0;
var associatedTokenErrorMessages;
if (process.env.NODE_ENV !== "production") {
  associatedTokenErrorMessages = {
    [ASSOCIATED_TOKEN_ERROR__INVALID_OWNER]: `Associated token account owner does not match address derivation`
  };
}
function getAssociatedTokenErrorMessage(code) {
  if (process.env.NODE_ENV !== "production") {
    return associatedTokenErrorMessages[code];
  }
  return "Error message not available in production bundles.";
}
function isAssociatedTokenError(error, transactionMessage, code) {
  return web3_js.isProgramError(
    error,
    transactionMessage,
    ASSOCIATED_TOKEN_PROGRAM_ADDRESS,
    code
  );
}
var TOKEN_2022_ERROR__NOT_RENT_EXEMPT = 0;
var TOKEN_2022_ERROR__INSUFFICIENT_FUNDS = 1;
var TOKEN_2022_ERROR__INVALID_MINT = 2;
var TOKEN_2022_ERROR__MINT_MISMATCH = 3;
var TOKEN_2022_ERROR__OWNER_MISMATCH = 4;
var TOKEN_2022_ERROR__FIXED_SUPPLY = 5;
var TOKEN_2022_ERROR__ALREADY_IN_USE = 6;
var TOKEN_2022_ERROR__INVALID_NUMBER_OF_PROVIDED_SIGNERS = 7;
var TOKEN_2022_ERROR__INVALID_NUMBER_OF_REQUIRED_SIGNERS = 8;
var TOKEN_2022_ERROR__UNINITIALIZED_STATE = 9;
var TOKEN_2022_ERROR__NATIVE_NOT_SUPPORTED = 10;
var TOKEN_2022_ERROR__NON_NATIVE_HAS_BALANCE = 11;
var TOKEN_2022_ERROR__INVALID_INSTRUCTION = 12;
var TOKEN_2022_ERROR__INVALID_STATE = 13;
var TOKEN_2022_ERROR__OVERFLOW = 14;
var TOKEN_2022_ERROR__AUTHORITY_TYPE_NOT_SUPPORTED = 15;
var TOKEN_2022_ERROR__MINT_CANNOT_FREEZE = 16;
var TOKEN_2022_ERROR__ACCOUNT_FROZEN = 17;
var TOKEN_2022_ERROR__MINT_DECIMALS_MISMATCH = 18;
var TOKEN_2022_ERROR__NON_NATIVE_NOT_SUPPORTED = 19;
var token2022ErrorMessages;
if (process.env.NODE_ENV !== "production") {
  token2022ErrorMessages = {
    [TOKEN_2022_ERROR__ACCOUNT_FROZEN]: `Account is frozen`,
    [TOKEN_2022_ERROR__ALREADY_IN_USE]: `Already in use`,
    [TOKEN_2022_ERROR__AUTHORITY_TYPE_NOT_SUPPORTED]: `Account does not support specified authority type`,
    [TOKEN_2022_ERROR__FIXED_SUPPLY]: `Fixed supply`,
    [TOKEN_2022_ERROR__INSUFFICIENT_FUNDS]: `Insufficient funds`,
    [TOKEN_2022_ERROR__INVALID_INSTRUCTION]: `Invalid instruction`,
    [TOKEN_2022_ERROR__INVALID_MINT]: `Invalid Mint`,
    [TOKEN_2022_ERROR__INVALID_NUMBER_OF_PROVIDED_SIGNERS]: `Invalid number of provided signers`,
    [TOKEN_2022_ERROR__INVALID_NUMBER_OF_REQUIRED_SIGNERS]: `Invalid number of required signers`,
    [TOKEN_2022_ERROR__INVALID_STATE]: `State is invalid for requested operation`,
    [TOKEN_2022_ERROR__MINT_CANNOT_FREEZE]: `This token mint cannot freeze accounts`,
    [TOKEN_2022_ERROR__MINT_DECIMALS_MISMATCH]: `The provided decimals value different from the Mint decimals`,
    [TOKEN_2022_ERROR__MINT_MISMATCH]: `Account not associated with this Mint`,
    [TOKEN_2022_ERROR__NATIVE_NOT_SUPPORTED]: `Instruction does not support native tokens`,
    [TOKEN_2022_ERROR__NON_NATIVE_HAS_BALANCE]: `Non-native account can only be closed if its balance is zero`,
    [TOKEN_2022_ERROR__NON_NATIVE_NOT_SUPPORTED]: `Instruction does not support non-native tokens`,
    [TOKEN_2022_ERROR__NOT_RENT_EXEMPT]: `Lamport balance below rent-exempt threshold`,
    [TOKEN_2022_ERROR__OVERFLOW]: `Operation overflowed`,
    [TOKEN_2022_ERROR__OWNER_MISMATCH]: `Owner does not match`,
    [TOKEN_2022_ERROR__UNINITIALIZED_STATE]: `State is unititialized`
  };
}
function getToken2022ErrorMessage(code) {
  if (process.env.NODE_ENV !== "production") {
    return token2022ErrorMessages[code];
  }
  return "Error message not available in production bundles.";
}
function isToken2022Error(error, transactionMessage, code) {
  return web3_js.isProgramError(
    error,
    transactionMessage,
    TOKEN_2022_PROGRAM_ADDRESS,
    code
  );
}
function expectAddress(value) {
  if (!value) {
    throw new Error("Expected a Address.");
  }
  if (typeof value === "object" && "address" in value) {
    return value.address;
  }
  if (Array.isArray(value)) {
    return value[0];
  }
  return value;
}
function getAccountMetaFactory(programAddress, optionalAccountStrategy) {
  return (account) => {
    if (!account.value) {
      return Object.freeze({
        address: programAddress,
        role: web3_js.AccountRole.READONLY
      });
    }
    const writableRole = account.isWritable ? web3_js.AccountRole.WRITABLE : web3_js.AccountRole.READONLY;
    return Object.freeze({
      address: expectAddress(account.value),
      role: isTransactionSigner(account.value) ? web3_js.upgradeRoleToSigner(writableRole) : writableRole,
      ...isTransactionSigner(account.value) ? { signer: account.value } : {}
    });
  };
}
function isTransactionSigner(value) {
  return !!value && typeof value === "object" && "address" in value && web3_js.isTransactionSigner(value);
}

// src/generated/instructions/amountToUiAmount.ts
var AMOUNT_TO_UI_AMOUNT_DISCRIMINATOR = 23;
function getAmountToUiAmountDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(AMOUNT_TO_UI_AMOUNT_DISCRIMINATOR);
}
function getAmountToUiAmountInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["amount", web3_js.getU64Encoder()]
    ]),
    (value) => ({ ...value, discriminator: AMOUNT_TO_UI_AMOUNT_DISCRIMINATOR })
  );
}
function getAmountToUiAmountInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["amount", web3_js.getU64Decoder()]
  ]);
}
function getAmountToUiAmountInstructionDataCodec() {
  return web3_js.combineCodec(
    getAmountToUiAmountInstructionDataEncoder(),
    getAmountToUiAmountInstructionDataDecoder()
  );
}
function getAmountToUiAmountInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    mint: { value: input.mint ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [getAccountMeta(accounts.mint)],
    programAddress,
    data: getAmountToUiAmountInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseAmountToUiAmountInstruction(instruction) {
  if (instruction.accounts.length < 1) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      mint: getNextAccount()
    },
    data: getAmountToUiAmountInstructionDataDecoder().decode(instruction.data)
  };
}
var APPLY_CONFIDENTIAL_PENDING_BALANCE_DISCRIMINATOR = 27;
function getApplyConfidentialPendingBalanceDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    APPLY_CONFIDENTIAL_PENDING_BALANCE_DISCRIMINATOR
  );
}
var APPLY_CONFIDENTIAL_PENDING_BALANCE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 8;
function getApplyConfidentialPendingBalanceConfidentialTransferDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    APPLY_CONFIDENTIAL_PENDING_BALANCE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR
  );
}
function getApplyConfidentialPendingBalanceInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["confidentialTransferDiscriminator", web3_js.getU8Encoder()],
      ["expectedPendingBalanceCreditCounter", web3_js.getU64Encoder()],
      ["newDecryptableAvailableBalance", getDecryptableBalanceEncoder()]
    ]),
    (value) => ({
      ...value,
      discriminator: APPLY_CONFIDENTIAL_PENDING_BALANCE_DISCRIMINATOR,
      confidentialTransferDiscriminator: APPLY_CONFIDENTIAL_PENDING_BALANCE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR
    })
  );
}
function getApplyConfidentialPendingBalanceInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["confidentialTransferDiscriminator", web3_js.getU8Decoder()],
    ["expectedPendingBalanceCreditCounter", web3_js.getU64Decoder()],
    ["newDecryptableAvailableBalance", getDecryptableBalanceDecoder()]
  ]);
}
function getApplyConfidentialPendingBalanceInstructionDataCodec() {
  return web3_js.combineCodec(
    getApplyConfidentialPendingBalanceInstructionDataEncoder(),
    getApplyConfidentialPendingBalanceInstructionDataDecoder()
  );
}
function getApplyConfidentialPendingBalanceInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    token: { value: input.token ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.token),
      getAccountMeta(accounts.authority),
      ...remainingAccounts
    ],
    programAddress,
    data: getApplyConfidentialPendingBalanceInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseApplyConfidentialPendingBalanceInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      token: getNextAccount(),
      authority: getNextAccount()
    },
    data: getApplyConfidentialPendingBalanceInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var APPROVE_DISCRIMINATOR = 4;
function getApproveDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(APPROVE_DISCRIMINATOR);
}
function getApproveInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["amount", web3_js.getU64Encoder()]
    ]),
    (value) => ({ ...value, discriminator: APPROVE_DISCRIMINATOR })
  );
}
function getApproveInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["amount", web3_js.getU64Decoder()]
  ]);
}
function getApproveInstructionDataCodec() {
  return web3_js.combineCodec(
    getApproveInstructionDataEncoder(),
    getApproveInstructionDataDecoder()
  );
}
function getApproveInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    source: { value: input.source ?? null, isWritable: true },
    delegate: { value: input.delegate ?? null, isWritable: false },
    owner: { value: input.owner ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.source),
      getAccountMeta(accounts.delegate),
      getAccountMeta(accounts.owner),
      ...remainingAccounts
    ],
    programAddress,
    data: getApproveInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseApproveInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      source: getNextAccount(),
      delegate: getNextAccount(),
      owner: getNextAccount()
    },
    data: getApproveInstructionDataDecoder().decode(instruction.data)
  };
}
var APPROVE_CHECKED_DISCRIMINATOR = 13;
function getApproveCheckedDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(APPROVE_CHECKED_DISCRIMINATOR);
}
function getApproveCheckedInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["amount", web3_js.getU64Encoder()],
      ["decimals", web3_js.getU8Encoder()]
    ]),
    (value) => ({ ...value, discriminator: APPROVE_CHECKED_DISCRIMINATOR })
  );
}
function getApproveCheckedInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["amount", web3_js.getU64Decoder()],
    ["decimals", web3_js.getU8Decoder()]
  ]);
}
function getApproveCheckedInstructionDataCodec() {
  return web3_js.combineCodec(
    getApproveCheckedInstructionDataEncoder(),
    getApproveCheckedInstructionDataDecoder()
  );
}
function getApproveCheckedInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    source: { value: input.source ?? null, isWritable: true },
    mint: { value: input.mint ?? null, isWritable: false },
    delegate: { value: input.delegate ?? null, isWritable: false },
    owner: { value: input.owner ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.source),
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.delegate),
      getAccountMeta(accounts.owner),
      ...remainingAccounts
    ],
    programAddress,
    data: getApproveCheckedInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseApproveCheckedInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      source: getNextAccount(),
      mint: getNextAccount(),
      delegate: getNextAccount(),
      owner: getNextAccount()
    },
    data: getApproveCheckedInstructionDataDecoder().decode(instruction.data)
  };
}
var APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR = 27;
function getApproveConfidentialTransferAccountDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR
  );
}
var APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 3;
function getApproveConfidentialTransferAccountConfidentialTransferDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR
  );
}
function getApproveConfidentialTransferAccountInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["confidentialTransferDiscriminator", web3_js.getU8Encoder()]
    ]),
    (value) => ({
      ...value,
      discriminator: APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR,
      confidentialTransferDiscriminator: APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR
    })
  );
}
function getApproveConfidentialTransferAccountInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["confidentialTransferDiscriminator", web3_js.getU8Decoder()]
  ]);
}
function getApproveConfidentialTransferAccountInstructionDataCodec() {
  return web3_js.combineCodec(
    getApproveConfidentialTransferAccountInstructionDataEncoder(),
    getApproveConfidentialTransferAccountInstructionDataDecoder()
  );
}
function getApproveConfidentialTransferAccountInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    token: { value: input.token ?? null, isWritable: true },
    mint: { value: input.mint ?? null, isWritable: false },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.token),
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.authority)
    ],
    programAddress,
    data: getApproveConfidentialTransferAccountInstructionDataEncoder().encode(
      {}
    )
  };
  return instruction;
}
function parseApproveConfidentialTransferAccountInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      token: getNextAccount(),
      mint: getNextAccount(),
      authority: getNextAccount()
    },
    data: getApproveConfidentialTransferAccountInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var BURN_DISCRIMINATOR = 8;
function getBurnDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(BURN_DISCRIMINATOR);
}
function getBurnInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["amount", web3_js.getU64Encoder()]
    ]),
    (value) => ({ ...value, discriminator: BURN_DISCRIMINATOR })
  );
}
function getBurnInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["amount", web3_js.getU64Decoder()]
  ]);
}
function getBurnInstructionDataCodec() {
  return web3_js.combineCodec(
    getBurnInstructionDataEncoder(),
    getBurnInstructionDataDecoder()
  );
}
function getBurnInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    account: { value: input.account ?? null, isWritable: true },
    mint: { value: input.mint ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.account),
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.authority),
      ...remainingAccounts
    ],
    programAddress,
    data: getBurnInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseBurnInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      account: getNextAccount(),
      mint: getNextAccount(),
      authority: getNextAccount()
    },
    data: getBurnInstructionDataDecoder().decode(instruction.data)
  };
}
var BURN_CHECKED_DISCRIMINATOR = 15;
function getBurnCheckedDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(BURN_CHECKED_DISCRIMINATOR);
}
function getBurnCheckedInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["amount", web3_js.getU64Encoder()],
      ["decimals", web3_js.getU8Encoder()]
    ]),
    (value) => ({ ...value, discriminator: BURN_CHECKED_DISCRIMINATOR })
  );
}
function getBurnCheckedInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["amount", web3_js.getU64Decoder()],
    ["decimals", web3_js.getU8Decoder()]
  ]);
}
function getBurnCheckedInstructionDataCodec() {
  return web3_js.combineCodec(
    getBurnCheckedInstructionDataEncoder(),
    getBurnCheckedInstructionDataDecoder()
  );
}
function getBurnCheckedInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    account: { value: input.account ?? null, isWritable: true },
    mint: { value: input.mint ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.account),
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.authority),
      ...remainingAccounts
    ],
    programAddress,
    data: getBurnCheckedInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseBurnCheckedInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      account: getNextAccount(),
      mint: getNextAccount(),
      authority: getNextAccount()
    },
    data: getBurnCheckedInstructionDataDecoder().decode(instruction.data)
  };
}
var CLOSE_ACCOUNT_DISCRIMINATOR = 9;
function getCloseAccountDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(CLOSE_ACCOUNT_DISCRIMINATOR);
}
function getCloseAccountInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([["discriminator", web3_js.getU8Encoder()]]),
    (value) => ({ ...value, discriminator: CLOSE_ACCOUNT_DISCRIMINATOR })
  );
}
function getCloseAccountInstructionDataDecoder() {
  return web3_js.getStructDecoder([["discriminator", web3_js.getU8Decoder()]]);
}
function getCloseAccountInstructionDataCodec() {
  return web3_js.combineCodec(
    getCloseAccountInstructionDataEncoder(),
    getCloseAccountInstructionDataDecoder()
  );
}
function getCloseAccountInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    account: { value: input.account ?? null, isWritable: true },
    destination: { value: input.destination ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.account),
      getAccountMeta(accounts.destination),
      getAccountMeta(accounts.owner),
      ...remainingAccounts
    ],
    programAddress,
    data: getCloseAccountInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseCloseAccountInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      account: getNextAccount(),
      destination: getNextAccount(),
      owner: getNextAccount()
    },
    data: getCloseAccountInstructionDataDecoder().decode(instruction.data)
  };
}
var CONFIDENTIAL_DEPOSIT_DISCRIMINATOR = 27;
function getConfidentialDepositDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(CONFIDENTIAL_DEPOSIT_DISCRIMINATOR);
}
var CONFIDENTIAL_DEPOSIT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 5;
function getConfidentialDepositConfidentialTransferDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    CONFIDENTIAL_DEPOSIT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR
  );
}
function getConfidentialDepositInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["confidentialTransferDiscriminator", web3_js.getU8Encoder()],
      ["amount", web3_js.getU64Encoder()],
      ["decimals", web3_js.getU8Encoder()]
    ]),
    (value) => ({
      ...value,
      discriminator: CONFIDENTIAL_DEPOSIT_DISCRIMINATOR,
      confidentialTransferDiscriminator: CONFIDENTIAL_DEPOSIT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR
    })
  );
}
function getConfidentialDepositInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["confidentialTransferDiscriminator", web3_js.getU8Decoder()],
    ["amount", web3_js.getU64Decoder()],
    ["decimals", web3_js.getU8Decoder()]
  ]);
}
function getConfidentialDepositInstructionDataCodec() {
  return web3_js.combineCodec(
    getConfidentialDepositInstructionDataEncoder(),
    getConfidentialDepositInstructionDataDecoder()
  );
}
function getConfidentialDepositInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    token: { value: input.token ?? null, isWritable: true },
    mint: { value: input.mint ?? null, isWritable: false },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.token),
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.authority),
      ...remainingAccounts
    ],
    programAddress,
    data: getConfidentialDepositInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseConfidentialDepositInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      token: getNextAccount(),
      mint: getNextAccount(),
      authority: getNextAccount()
    },
    data: getConfidentialDepositInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 27;
function getConfidentialTransferDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(CONFIDENTIAL_TRANSFER_DISCRIMINATOR);
}
var CONFIDENTIAL_TRANSFER_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 7;
function getConfidentialTransferConfidentialTransferDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    CONFIDENTIAL_TRANSFER_CONFIDENTIAL_TRANSFER_DISCRIMINATOR
  );
}
function getConfidentialTransferInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["confidentialTransferDiscriminator", web3_js.getU8Encoder()],
      ["newSourceDecryptableAvailableBalance", getDecryptableBalanceEncoder()],
      ["equalityProofInstructionOffset", web3_js.getI8Encoder()],
      ["ciphertextValidityProofInstructionOffset", web3_js.getI8Encoder()],
      ["rangeProofInstructionOffset", web3_js.getI8Encoder()]
    ]),
    (value) => ({
      ...value,
      discriminator: CONFIDENTIAL_TRANSFER_DISCRIMINATOR,
      confidentialTransferDiscriminator: CONFIDENTIAL_TRANSFER_CONFIDENTIAL_TRANSFER_DISCRIMINATOR
    })
  );
}
function getConfidentialTransferInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["confidentialTransferDiscriminator", web3_js.getU8Decoder()],
    ["newSourceDecryptableAvailableBalance", getDecryptableBalanceDecoder()],
    ["equalityProofInstructionOffset", web3_js.getI8Decoder()],
    ["ciphertextValidityProofInstructionOffset", web3_js.getI8Decoder()],
    ["rangeProofInstructionOffset", web3_js.getI8Decoder()]
  ]);
}
function getConfidentialTransferInstructionDataCodec() {
  return web3_js.combineCodec(
    getConfidentialTransferInstructionDataEncoder(),
    getConfidentialTransferInstructionDataDecoder()
  );
}
function getConfidentialTransferInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    sourceToken: { value: input.sourceToken ?? null, isWritable: true },
    mint: { value: input.mint ?? null, isWritable: false },
    destinationToken: {
      value: input.destinationToken ?? null,
      isWritable: true
    },
    instructionsSysvar: {
      value: input.instructionsSysvar ?? null,
      isWritable: false
    },
    equalityRecord: { value: input.equalityRecord ?? null, isWritable: false },
    ciphertextValidityRecord: {
      value: input.ciphertextValidityRecord ?? null,
      isWritable: false
    },
    rangeRecord: { value: input.rangeRecord ?? null, isWritable: false },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.sourceToken),
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.destinationToken),
      getAccountMeta(accounts.instructionsSysvar),
      getAccountMeta(accounts.equalityRecord),
      getAccountMeta(accounts.ciphertextValidityRecord),
      getAccountMeta(accounts.rangeRecord),
      getAccountMeta(accounts.authority),
      ...remainingAccounts
    ],
    programAddress,
    data: getConfidentialTransferInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseConfidentialTransferInstruction(instruction) {
  if (instruction.accounts.length < 8) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  const getNextOptionalAccount = () => {
    const accountMeta = getNextAccount();
    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS ? void 0 : accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      sourceToken: getNextAccount(),
      mint: getNextAccount(),
      destinationToken: getNextAccount(),
      instructionsSysvar: getNextOptionalAccount(),
      equalityRecord: getNextOptionalAccount(),
      ciphertextValidityRecord: getNextOptionalAccount(),
      rangeRecord: getNextOptionalAccount(),
      authority: getNextAccount()
    },
    data: getConfidentialTransferInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var CONFIDENTIAL_TRANSFER_WITH_FEE_DISCRIMINATOR = 27;
function getConfidentialTransferWithFeeDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(CONFIDENTIAL_TRANSFER_WITH_FEE_DISCRIMINATOR);
}
var CONFIDENTIAL_TRANSFER_WITH_FEE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 13;
function getConfidentialTransferWithFeeConfidentialTransferDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    CONFIDENTIAL_TRANSFER_WITH_FEE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR
  );
}
function getConfidentialTransferWithFeeInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["confidentialTransferDiscriminator", web3_js.getU8Encoder()],
      ["newSourceDecryptableAvailableBalance", getDecryptableBalanceEncoder()],
      ["equalityProofInstructionOffset", web3_js.getI8Encoder()],
      [
        "transferAmountCiphertextValidityProofInstructionOffset",
        web3_js.getI8Encoder()
      ],
      ["feeSigmaProofInstructionOffset", web3_js.getI8Encoder()],
      ["feeCiphertextValidityProofInstructionOffset", web3_js.getI8Encoder()],
      ["rangeProofInstructionOffset", web3_js.getI8Encoder()]
    ]),
    (value) => ({
      ...value,
      discriminator: CONFIDENTIAL_TRANSFER_WITH_FEE_DISCRIMINATOR,
      confidentialTransferDiscriminator: CONFIDENTIAL_TRANSFER_WITH_FEE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR
    })
  );
}
function getConfidentialTransferWithFeeInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["confidentialTransferDiscriminator", web3_js.getU8Decoder()],
    ["newSourceDecryptableAvailableBalance", getDecryptableBalanceDecoder()],
    ["equalityProofInstructionOffset", web3_js.getI8Decoder()],
    ["transferAmountCiphertextValidityProofInstructionOffset", web3_js.getI8Decoder()],
    ["feeSigmaProofInstructionOffset", web3_js.getI8Decoder()],
    ["feeCiphertextValidityProofInstructionOffset", web3_js.getI8Decoder()],
    ["rangeProofInstructionOffset", web3_js.getI8Decoder()]
  ]);
}
function getConfidentialTransferWithFeeInstructionDataCodec() {
  return web3_js.combineCodec(
    getConfidentialTransferWithFeeInstructionDataEncoder(),
    getConfidentialTransferWithFeeInstructionDataDecoder()
  );
}
function getConfidentialTransferWithFeeInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    sourceToken: { value: input.sourceToken ?? null, isWritable: true },
    mint: { value: input.mint ?? null, isWritable: false },
    destinationToken: {
      value: input.destinationToken ?? null,
      isWritable: true
    },
    instructionsSysvar: {
      value: input.instructionsSysvar ?? null,
      isWritable: false
    },
    equalityRecord: { value: input.equalityRecord ?? null, isWritable: false },
    transferAmountCiphertextValidityRecord: {
      value: input.transferAmountCiphertextValidityRecord ?? null,
      isWritable: false
    },
    feeSigmaRecord: { value: input.feeSigmaRecord ?? null, isWritable: false },
    feeCiphertextValidityRecord: {
      value: input.feeCiphertextValidityRecord ?? null,
      isWritable: false
    },
    rangeRecord: { value: input.rangeRecord ?? null, isWritable: false },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.sourceToken),
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.destinationToken),
      getAccountMeta(accounts.instructionsSysvar),
      getAccountMeta(accounts.equalityRecord),
      getAccountMeta(accounts.transferAmountCiphertextValidityRecord),
      getAccountMeta(accounts.feeSigmaRecord),
      getAccountMeta(accounts.feeCiphertextValidityRecord),
      getAccountMeta(accounts.rangeRecord),
      getAccountMeta(accounts.authority),
      ...remainingAccounts
    ],
    programAddress,
    data: getConfidentialTransferWithFeeInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseConfidentialTransferWithFeeInstruction(instruction) {
  if (instruction.accounts.length < 10) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  const getNextOptionalAccount = () => {
    const accountMeta = getNextAccount();
    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS ? void 0 : accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      sourceToken: getNextAccount(),
      mint: getNextAccount(),
      destinationToken: getNextAccount(),
      instructionsSysvar: getNextOptionalAccount(),
      equalityRecord: getNextOptionalAccount(),
      transferAmountCiphertextValidityRecord: getNextOptionalAccount(),
      feeSigmaRecord: getNextOptionalAccount(),
      feeCiphertextValidityRecord: getNextOptionalAccount(),
      rangeRecord: getNextOptionalAccount(),
      authority: getNextAccount()
    },
    data: getConfidentialTransferWithFeeInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var CONFIDENTIAL_WITHDRAW_DISCRIMINATOR = 27;
function getConfidentialWithdrawDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(CONFIDENTIAL_WITHDRAW_DISCRIMINATOR);
}
var CONFIDENTIAL_WITHDRAW_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 6;
function getConfidentialWithdrawConfidentialTransferDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    CONFIDENTIAL_WITHDRAW_CONFIDENTIAL_TRANSFER_DISCRIMINATOR
  );
}
function getConfidentialWithdrawInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["confidentialTransferDiscriminator", web3_js.getU8Encoder()],
      ["amount", web3_js.getU64Encoder()],
      ["decimals", web3_js.getU8Encoder()],
      ["newDecryptableAvailableBalance", getDecryptableBalanceEncoder()],
      ["equalityProofInstructionOffset", web3_js.getI8Encoder()],
      ["rangeProofInstructionOffset", web3_js.getI8Encoder()]
    ]),
    (value) => ({
      ...value,
      discriminator: CONFIDENTIAL_WITHDRAW_DISCRIMINATOR,
      confidentialTransferDiscriminator: CONFIDENTIAL_WITHDRAW_CONFIDENTIAL_TRANSFER_DISCRIMINATOR
    })
  );
}
function getConfidentialWithdrawInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["confidentialTransferDiscriminator", web3_js.getU8Decoder()],
    ["amount", web3_js.getU64Decoder()],
    ["decimals", web3_js.getU8Decoder()],
    ["newDecryptableAvailableBalance", getDecryptableBalanceDecoder()],
    ["equalityProofInstructionOffset", web3_js.getI8Decoder()],
    ["rangeProofInstructionOffset", web3_js.getI8Decoder()]
  ]);
}
function getConfidentialWithdrawInstructionDataCodec() {
  return web3_js.combineCodec(
    getConfidentialWithdrawInstructionDataEncoder(),
    getConfidentialWithdrawInstructionDataDecoder()
  );
}
function getConfidentialWithdrawInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    token: { value: input.token ?? null, isWritable: true },
    mint: { value: input.mint ?? null, isWritable: false },
    instructionsSysvar: {
      value: input.instructionsSysvar ?? null,
      isWritable: false
    },
    equalityRecord: { value: input.equalityRecord ?? null, isWritable: false },
    rangeRecord: { value: input.rangeRecord ?? null, isWritable: false },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.token),
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.instructionsSysvar),
      getAccountMeta(accounts.equalityRecord),
      getAccountMeta(accounts.rangeRecord),
      getAccountMeta(accounts.authority),
      ...remainingAccounts
    ],
    programAddress,
    data: getConfidentialWithdrawInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseConfidentialWithdrawInstruction(instruction) {
  if (instruction.accounts.length < 6) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  const getNextOptionalAccount = () => {
    const accountMeta = getNextAccount();
    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS ? void 0 : accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      token: getNextAccount(),
      mint: getNextAccount(),
      instructionsSysvar: getNextOptionalAccount(),
      equalityRecord: getNextOptionalAccount(),
      rangeRecord: getNextOptionalAccount(),
      authority: getNextAccount()
    },
    data: getConfidentialWithdrawInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR = 27;
function getConfigureConfidentialTransferAccountDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR
  );
}
var CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 2;
function getConfigureConfidentialTransferAccountConfidentialTransferDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR
  );
}
function getConfigureConfidentialTransferAccountInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["confidentialTransferDiscriminator", web3_js.getU8Encoder()],
      ["decryptableZeroBalance", getDecryptableBalanceEncoder()],
      ["maximumPendingBalanceCreditCounter", web3_js.getU64Encoder()],
      ["proofInstructionOffset", web3_js.getI8Encoder()]
    ]),
    (value) => ({
      ...value,
      discriminator: CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR,
      confidentialTransferDiscriminator: CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR
    })
  );
}
function getConfigureConfidentialTransferAccountInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["confidentialTransferDiscriminator", web3_js.getU8Decoder()],
    ["decryptableZeroBalance", getDecryptableBalanceDecoder()],
    ["maximumPendingBalanceCreditCounter", web3_js.getU64Decoder()],
    ["proofInstructionOffset", web3_js.getI8Decoder()]
  ]);
}
function getConfigureConfidentialTransferAccountInstructionDataCodec() {
  return web3_js.combineCodec(
    getConfigureConfidentialTransferAccountInstructionDataEncoder(),
    getConfigureConfidentialTransferAccountInstructionDataDecoder()
  );
}
function getConfigureConfidentialTransferAccountInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    token: { value: input.token ?? null, isWritable: true },
    mint: { value: input.mint ?? null, isWritable: false },
    instructionsSysvarOrContextState: {
      value: input.instructionsSysvarOrContextState ?? null,
      isWritable: false
    },
    record: { value: input.record ?? null, isWritable: false },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.instructionsSysvarOrContextState.value) {
    accounts.instructionsSysvarOrContextState.value = "Sysvar1nstructions1111111111111111111111111";
  }
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.token),
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.instructionsSysvarOrContextState),
      getAccountMeta(accounts.record),
      getAccountMeta(accounts.authority),
      ...remainingAccounts
    ],
    programAddress,
    data: getConfigureConfidentialTransferAccountInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseConfigureConfidentialTransferAccountInstruction(instruction) {
  if (instruction.accounts.length < 5) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  const getNextOptionalAccount = () => {
    const accountMeta = getNextAccount();
    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS ? void 0 : accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      token: getNextAccount(),
      mint: getNextAccount(),
      instructionsSysvarOrContextState: getNextAccount(),
      record: getNextOptionalAccount(),
      authority: getNextAccount()
    },
    data: getConfigureConfidentialTransferAccountInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
async function findAssociatedTokenPda(seeds, config = {}) {
  const {
    programAddress = "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"
  } = config;
  return await web3_js.getProgramDerivedAddress({
    programAddress,
    seeds: [
      web3_js.getAddressEncoder().encode(seeds.owner),
      web3_js.getAddressEncoder().encode(seeds.tokenProgram),
      web3_js.getAddressEncoder().encode(seeds.mint)
    ]
  });
}

// src/generated/instructions/createAssociatedToken.ts
var CREATE_ASSOCIATED_TOKEN_DISCRIMINATOR = 0;
function getCreateAssociatedTokenDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(CREATE_ASSOCIATED_TOKEN_DISCRIMINATOR);
}
function getCreateAssociatedTokenInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([["discriminator", web3_js.getU8Encoder()]]),
    (value) => ({
      ...value,
      discriminator: CREATE_ASSOCIATED_TOKEN_DISCRIMINATOR
    })
  );
}
function getCreateAssociatedTokenInstructionDataDecoder() {
  return web3_js.getStructDecoder([["discriminator", web3_js.getU8Decoder()]]);
}
function getCreateAssociatedTokenInstructionDataCodec() {
  return web3_js.combineCodec(
    getCreateAssociatedTokenInstructionDataEncoder(),
    getCreateAssociatedTokenInstructionDataDecoder()
  );
}
async function getCreateAssociatedTokenInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;
  const originalAccounts = {
    payer: { value: input.payer ?? null, isWritable: true },
    ata: { value: input.ata ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: false },
    mint: { value: input.mint ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb";
  }
  if (!accounts.ata.value) {
    accounts.ata.value = await findAssociatedTokenPda({
      owner: expectAddress(accounts.owner.value),
      tokenProgram: expectAddress(accounts.tokenProgram.value),
      mint: expectAddress(accounts.mint.value)
    });
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.ata),
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.tokenProgram)
    ],
    programAddress,
    data: getCreateAssociatedTokenInstructionDataEncoder().encode({})
  };
  return instruction;
}
function getCreateAssociatedTokenInstruction(input, config) {
  const programAddress = config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;
  const originalAccounts = {
    payer: { value: input.payer ?? null, isWritable: true },
    ata: { value: input.ata ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: false },
    mint: { value: input.mint ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb";
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.ata),
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.tokenProgram)
    ],
    programAddress,
    data: getCreateAssociatedTokenInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseCreateAssociatedTokenInstruction(instruction) {
  if (instruction.accounts.length < 6) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      payer: getNextAccount(),
      ata: getNextAccount(),
      owner: getNextAccount(),
      mint: getNextAccount(),
      systemProgram: getNextAccount(),
      tokenProgram: getNextAccount()
    },
    data: getCreateAssociatedTokenInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var CREATE_ASSOCIATED_TOKEN_IDEMPOTENT_DISCRIMINATOR = 1;
function getCreateAssociatedTokenIdempotentDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    CREATE_ASSOCIATED_TOKEN_IDEMPOTENT_DISCRIMINATOR
  );
}
function getCreateAssociatedTokenIdempotentInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([["discriminator", web3_js.getU8Encoder()]]),
    (value) => ({
      ...value,
      discriminator: CREATE_ASSOCIATED_TOKEN_IDEMPOTENT_DISCRIMINATOR
    })
  );
}
function getCreateAssociatedTokenIdempotentInstructionDataDecoder() {
  return web3_js.getStructDecoder([["discriminator", web3_js.getU8Decoder()]]);
}
function getCreateAssociatedTokenIdempotentInstructionDataCodec() {
  return web3_js.combineCodec(
    getCreateAssociatedTokenIdempotentInstructionDataEncoder(),
    getCreateAssociatedTokenIdempotentInstructionDataDecoder()
  );
}
async function getCreateAssociatedTokenIdempotentInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;
  const originalAccounts = {
    payer: { value: input.payer ?? null, isWritable: true },
    ata: { value: input.ata ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: false },
    mint: { value: input.mint ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb";
  }
  if (!accounts.ata.value) {
    accounts.ata.value = await findAssociatedTokenPda({
      owner: expectAddress(accounts.owner.value),
      tokenProgram: expectAddress(accounts.tokenProgram.value),
      mint: expectAddress(accounts.mint.value)
    });
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.ata),
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.tokenProgram)
    ],
    programAddress,
    data: getCreateAssociatedTokenIdempotentInstructionDataEncoder().encode({})
  };
  return instruction;
}
function getCreateAssociatedTokenIdempotentInstruction(input, config) {
  const programAddress = config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;
  const originalAccounts = {
    payer: { value: input.payer ?? null, isWritable: true },
    ata: { value: input.ata ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: false },
    mint: { value: input.mint ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb";
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.ata),
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.tokenProgram)
    ],
    programAddress,
    data: getCreateAssociatedTokenIdempotentInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseCreateAssociatedTokenIdempotentInstruction(instruction) {
  if (instruction.accounts.length < 6) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      payer: getNextAccount(),
      ata: getNextAccount(),
      owner: getNextAccount(),
      mint: getNextAccount(),
      systemProgram: getNextAccount(),
      tokenProgram: getNextAccount()
    },
    data: getCreateAssociatedTokenIdempotentInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var CREATE_NATIVE_MINT_DISCRIMINATOR = 31;
function getCreateNativeMintDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(CREATE_NATIVE_MINT_DISCRIMINATOR);
}
function getCreateNativeMintInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([["discriminator", web3_js.getU8Encoder()]]),
    (value) => ({ ...value, discriminator: CREATE_NATIVE_MINT_DISCRIMINATOR })
  );
}
function getCreateNativeMintInstructionDataDecoder() {
  return web3_js.getStructDecoder([["discriminator", web3_js.getU8Decoder()]]);
}
function getCreateNativeMintInstructionDataCodec() {
  return web3_js.combineCodec(
    getCreateNativeMintInstructionDataEncoder(),
    getCreateNativeMintInstructionDataDecoder()
  );
}
function getCreateNativeMintInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    payer: { value: input.payer ?? null, isWritable: true },
    nativeMint: { value: input.nativeMint ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.nativeMint),
      getAccountMeta(accounts.systemProgram)
    ],
    programAddress,
    data: getCreateNativeMintInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseCreateNativeMintInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      payer: getNextAccount(),
      nativeMint: getNextAccount(),
      systemProgram: getNextAccount()
    },
    data: getCreateNativeMintInstructionDataDecoder().decode(instruction.data)
  };
}
var DISABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR = 27;
function getDisableConfidentialCreditsDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(DISABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR);
}
var DISABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 10;
function getDisableConfidentialCreditsConfidentialTransferDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    DISABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR
  );
}
function getDisableConfidentialCreditsInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["confidentialTransferDiscriminator", web3_js.getU8Encoder()]
    ]),
    (value) => ({
      ...value,
      discriminator: DISABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR,
      confidentialTransferDiscriminator: DISABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR
    })
  );
}
function getDisableConfidentialCreditsInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["confidentialTransferDiscriminator", web3_js.getU8Decoder()]
  ]);
}
function getDisableConfidentialCreditsInstructionDataCodec() {
  return web3_js.combineCodec(
    getDisableConfidentialCreditsInstructionDataEncoder(),
    getDisableConfidentialCreditsInstructionDataDecoder()
  );
}
function getDisableConfidentialCreditsInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    token: { value: input.token ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.token),
      getAccountMeta(accounts.authority),
      ...remainingAccounts
    ],
    programAddress,
    data: getDisableConfidentialCreditsInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseDisableConfidentialCreditsInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      token: getNextAccount(),
      authority: getNextAccount()
    },
    data: getDisableConfidentialCreditsInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var DISABLE_CPI_GUARD_DISCRIMINATOR = 34;
function getDisableCpiGuardDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(DISABLE_CPI_GUARD_DISCRIMINATOR);
}
var DISABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR = 1;
function getDisableCpiGuardCpiGuardDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(DISABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR);
}
function getDisableCpiGuardInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["cpiGuardDiscriminator", web3_js.getU8Encoder()]
    ]),
    (value) => ({
      ...value,
      discriminator: DISABLE_CPI_GUARD_DISCRIMINATOR,
      cpiGuardDiscriminator: DISABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR
    })
  );
}
function getDisableCpiGuardInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["cpiGuardDiscriminator", web3_js.getU8Decoder()]
  ]);
}
function getDisableCpiGuardInstructionDataCodec() {
  return web3_js.combineCodec(
    getDisableCpiGuardInstructionDataEncoder(),
    getDisableCpiGuardInstructionDataDecoder()
  );
}
function getDisableCpiGuardInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    token: { value: input.token ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.token),
      getAccountMeta(accounts.owner),
      ...remainingAccounts
    ],
    programAddress,
    data: getDisableCpiGuardInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseDisableCpiGuardInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      token: getNextAccount(),
      owner: getNextAccount()
    },
    data: getDisableCpiGuardInstructionDataDecoder().decode(instruction.data)
  };
}
var DISABLE_HARVEST_TO_MINT_DISCRIMINATOR = 37;
function getDisableHarvestToMintDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(DISABLE_HARVEST_TO_MINT_DISCRIMINATOR);
}
var DISABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 5;
function getDisableHarvestToMintConfidentialTransferFeeDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    DISABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR
  );
}
function getDisableHarvestToMintInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["confidentialTransferFeeDiscriminator", web3_js.getU8Encoder()]
    ]),
    (value) => ({
      ...value,
      discriminator: DISABLE_HARVEST_TO_MINT_DISCRIMINATOR,
      confidentialTransferFeeDiscriminator: DISABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR
    })
  );
}
function getDisableHarvestToMintInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["confidentialTransferFeeDiscriminator", web3_js.getU8Decoder()]
  ]);
}
function getDisableHarvestToMintInstructionDataCodec() {
  return web3_js.combineCodec(
    getDisableHarvestToMintInstructionDataEncoder(),
    getDisableHarvestToMintInstructionDataDecoder()
  );
}
function getDisableHarvestToMintInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    mint: { value: input.mint ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.authority),
      ...remainingAccounts
    ],
    programAddress,
    data: getDisableHarvestToMintInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseDisableHarvestToMintInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      mint: getNextAccount(),
      authority: getNextAccount()
    },
    data: getDisableHarvestToMintInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var DISABLE_MEMO_TRANSFERS_DISCRIMINATOR = 30;
function getDisableMemoTransfersDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(DISABLE_MEMO_TRANSFERS_DISCRIMINATOR);
}
var DISABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR = 1;
function getDisableMemoTransfersMemoTransfersDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    DISABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR
  );
}
function getDisableMemoTransfersInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["memoTransfersDiscriminator", web3_js.getU8Encoder()]
    ]),
    (value) => ({
      ...value,
      discriminator: DISABLE_MEMO_TRANSFERS_DISCRIMINATOR,
      memoTransfersDiscriminator: DISABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR
    })
  );
}
function getDisableMemoTransfersInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["memoTransfersDiscriminator", web3_js.getU8Decoder()]
  ]);
}
function getDisableMemoTransfersInstructionDataCodec() {
  return web3_js.combineCodec(
    getDisableMemoTransfersInstructionDataEncoder(),
    getDisableMemoTransfersInstructionDataDecoder()
  );
}
function getDisableMemoTransfersInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    token: { value: input.token ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.token),
      getAccountMeta(accounts.owner),
      ...remainingAccounts
    ],
    programAddress,
    data: getDisableMemoTransfersInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseDisableMemoTransfersInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      token: getNextAccount(),
      owner: getNextAccount()
    },
    data: getDisableMemoTransfersInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var DISABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR = 27;
function getDisableNonConfidentialCreditsDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(DISABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR);
}
var DISABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 12;
function getDisableNonConfidentialCreditsConfidentialTransferDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    DISABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR
  );
}
function getDisableNonConfidentialCreditsInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["confidentialTransferDiscriminator", web3_js.getU8Encoder()]
    ]),
    (value) => ({
      ...value,
      discriminator: DISABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR,
      confidentialTransferDiscriminator: DISABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR
    })
  );
}
function getDisableNonConfidentialCreditsInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["confidentialTransferDiscriminator", web3_js.getU8Decoder()]
  ]);
}
function getDisableNonConfidentialCreditsInstructionDataCodec() {
  return web3_js.combineCodec(
    getDisableNonConfidentialCreditsInstructionDataEncoder(),
    getDisableNonConfidentialCreditsInstructionDataDecoder()
  );
}
function getDisableNonConfidentialCreditsInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    token: { value: input.token ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.token),
      getAccountMeta(accounts.authority),
      ...remainingAccounts
    ],
    programAddress,
    data: getDisableNonConfidentialCreditsInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseDisableNonConfidentialCreditsInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      token: getNextAccount(),
      authority: getNextAccount()
    },
    data: getDisableNonConfidentialCreditsInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var EMIT_TOKEN_METADATA_DISCRIMINATOR = new Uint8Array([
  250,
  166,
  180,
  250,
  13,
  12,
  184,
  70
]);
function getEmitTokenMetadataDiscriminatorBytes() {
  return web3_js.getBytesEncoder().encode(EMIT_TOKEN_METADATA_DISCRIMINATOR);
}
function getEmitTokenMetadataInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getBytesEncoder()],
      ["start", web3_js.getOptionEncoder(web3_js.getU64Encoder())],
      ["end", web3_js.getOptionEncoder(web3_js.getU64Encoder())]
    ]),
    (value) => ({
      ...value,
      discriminator: EMIT_TOKEN_METADATA_DISCRIMINATOR,
      start: value.start ?? web3_js.none(),
      end: value.end ?? web3_js.none()
    })
  );
}
function getEmitTokenMetadataInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getBytesDecoder()],
    ["start", web3_js.getOptionDecoder(web3_js.getU64Decoder())],
    ["end", web3_js.getOptionDecoder(web3_js.getU64Decoder())]
  ]);
}
function getEmitTokenMetadataInstructionDataCodec() {
  return web3_js.combineCodec(
    getEmitTokenMetadataInstructionDataEncoder(),
    getEmitTokenMetadataInstructionDataDecoder()
  );
}
function getEmitTokenMetadataInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    metadata: { value: input.metadata ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [getAccountMeta(accounts.metadata)],
    programAddress,
    data: getEmitTokenMetadataInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseEmitTokenMetadataInstruction(instruction) {
  if (instruction.accounts.length < 1) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      metadata: getNextAccount()
    },
    data: getEmitTokenMetadataInstructionDataDecoder().decode(instruction.data)
  };
}
var EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR = 27;
function getEmptyConfidentialTransferAccountDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR
  );
}
var EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 4;
function getEmptyConfidentialTransferAccountConfidentialTransferDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR
  );
}
function getEmptyConfidentialTransferAccountInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["confidentialTransferDiscriminator", web3_js.getU8Encoder()],
      ["proofInstructionOffset", web3_js.getI8Encoder()]
    ]),
    (value) => ({
      ...value,
      discriminator: EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR,
      confidentialTransferDiscriminator: EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR
    })
  );
}
function getEmptyConfidentialTransferAccountInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["confidentialTransferDiscriminator", web3_js.getU8Decoder()],
    ["proofInstructionOffset", web3_js.getI8Decoder()]
  ]);
}
function getEmptyConfidentialTransferAccountInstructionDataCodec() {
  return web3_js.combineCodec(
    getEmptyConfidentialTransferAccountInstructionDataEncoder(),
    getEmptyConfidentialTransferAccountInstructionDataDecoder()
  );
}
function getEmptyConfidentialTransferAccountInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    token: { value: input.token ?? null, isWritable: true },
    instructionsSysvarOrContextState: {
      value: input.instructionsSysvarOrContextState ?? null,
      isWritable: false
    },
    record: { value: input.record ?? null, isWritable: false },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.instructionsSysvarOrContextState.value) {
    accounts.instructionsSysvarOrContextState.value = "Sysvar1nstructions1111111111111111111111111";
  }
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.token),
      getAccountMeta(accounts.instructionsSysvarOrContextState),
      getAccountMeta(accounts.record),
      getAccountMeta(accounts.authority),
      ...remainingAccounts
    ],
    programAddress,
    data: getEmptyConfidentialTransferAccountInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseEmptyConfidentialTransferAccountInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  const getNextOptionalAccount = () => {
    const accountMeta = getNextAccount();
    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS ? void 0 : accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      token: getNextAccount(),
      instructionsSysvarOrContextState: getNextAccount(),
      record: getNextOptionalAccount(),
      authority: getNextAccount()
    },
    data: getEmptyConfidentialTransferAccountInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var ENABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR = 27;
function getEnableConfidentialCreditsDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(ENABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR);
}
var ENABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 9;
function getEnableConfidentialCreditsConfidentialTransferDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    ENABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR
  );
}
function getEnableConfidentialCreditsInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["confidentialTransferDiscriminator", web3_js.getU8Encoder()]
    ]),
    (value) => ({
      ...value,
      discriminator: ENABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR,
      confidentialTransferDiscriminator: ENABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR
    })
  );
}
function getEnableConfidentialCreditsInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["confidentialTransferDiscriminator", web3_js.getU8Decoder()]
  ]);
}
function getEnableConfidentialCreditsInstructionDataCodec() {
  return web3_js.combineCodec(
    getEnableConfidentialCreditsInstructionDataEncoder(),
    getEnableConfidentialCreditsInstructionDataDecoder()
  );
}
function getEnableConfidentialCreditsInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    token: { value: input.token ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.token),
      getAccountMeta(accounts.authority),
      ...remainingAccounts
    ],
    programAddress,
    data: getEnableConfidentialCreditsInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseEnableConfidentialCreditsInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      token: getNextAccount(),
      authority: getNextAccount()
    },
    data: getEnableConfidentialCreditsInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var ENABLE_CPI_GUARD_DISCRIMINATOR = 34;
function getEnableCpiGuardDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(ENABLE_CPI_GUARD_DISCRIMINATOR);
}
var ENABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR = 0;
function getEnableCpiGuardCpiGuardDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(ENABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR);
}
function getEnableCpiGuardInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["cpiGuardDiscriminator", web3_js.getU8Encoder()]
    ]),
    (value) => ({
      ...value,
      discriminator: ENABLE_CPI_GUARD_DISCRIMINATOR,
      cpiGuardDiscriminator: ENABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR
    })
  );
}
function getEnableCpiGuardInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["cpiGuardDiscriminator", web3_js.getU8Decoder()]
  ]);
}
function getEnableCpiGuardInstructionDataCodec() {
  return web3_js.combineCodec(
    getEnableCpiGuardInstructionDataEncoder(),
    getEnableCpiGuardInstructionDataDecoder()
  );
}
function getEnableCpiGuardInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    token: { value: input.token ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.token),
      getAccountMeta(accounts.owner),
      ...remainingAccounts
    ],
    programAddress,
    data: getEnableCpiGuardInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseEnableCpiGuardInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      token: getNextAccount(),
      owner: getNextAccount()
    },
    data: getEnableCpiGuardInstructionDataDecoder().decode(instruction.data)
  };
}
var ENABLE_HARVEST_TO_MINT_DISCRIMINATOR = 37;
function getEnableHarvestToMintDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(ENABLE_HARVEST_TO_MINT_DISCRIMINATOR);
}
var ENABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 4;
function getEnableHarvestToMintConfidentialTransferFeeDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    ENABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR
  );
}
function getEnableHarvestToMintInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["confidentialTransferFeeDiscriminator", web3_js.getU8Encoder()]
    ]),
    (value) => ({
      ...value,
      discriminator: ENABLE_HARVEST_TO_MINT_DISCRIMINATOR,
      confidentialTransferFeeDiscriminator: ENABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR
    })
  );
}
function getEnableHarvestToMintInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["confidentialTransferFeeDiscriminator", web3_js.getU8Decoder()]
  ]);
}
function getEnableHarvestToMintInstructionDataCodec() {
  return web3_js.combineCodec(
    getEnableHarvestToMintInstructionDataEncoder(),
    getEnableHarvestToMintInstructionDataDecoder()
  );
}
function getEnableHarvestToMintInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    mint: { value: input.mint ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.authority),
      ...remainingAccounts
    ],
    programAddress,
    data: getEnableHarvestToMintInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseEnableHarvestToMintInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      mint: getNextAccount(),
      authority: getNextAccount()
    },
    data: getEnableHarvestToMintInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var ENABLE_MEMO_TRANSFERS_DISCRIMINATOR = 30;
function getEnableMemoTransfersDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(ENABLE_MEMO_TRANSFERS_DISCRIMINATOR);
}
var ENABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR = 0;
function getEnableMemoTransfersMemoTransfersDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    ENABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR
  );
}
function getEnableMemoTransfersInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["memoTransfersDiscriminator", web3_js.getU8Encoder()]
    ]),
    (value) => ({
      ...value,
      discriminator: ENABLE_MEMO_TRANSFERS_DISCRIMINATOR,
      memoTransfersDiscriminator: ENABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR
    })
  );
}
function getEnableMemoTransfersInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["memoTransfersDiscriminator", web3_js.getU8Decoder()]
  ]);
}
function getEnableMemoTransfersInstructionDataCodec() {
  return web3_js.combineCodec(
    getEnableMemoTransfersInstructionDataEncoder(),
    getEnableMemoTransfersInstructionDataDecoder()
  );
}
function getEnableMemoTransfersInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    token: { value: input.token ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.token),
      getAccountMeta(accounts.owner),
      ...remainingAccounts
    ],
    programAddress,
    data: getEnableMemoTransfersInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseEnableMemoTransfersInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      token: getNextAccount(),
      owner: getNextAccount()
    },
    data: getEnableMemoTransfersInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var ENABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR = 27;
function getEnableNonConfidentialCreditsDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(ENABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR);
}
var ENABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 11;
function getEnableNonConfidentialCreditsConfidentialTransferDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    ENABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR
  );
}
function getEnableNonConfidentialCreditsInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["confidentialTransferDiscriminator", web3_js.getU8Encoder()]
    ]),
    (value) => ({
      ...value,
      discriminator: ENABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR,
      confidentialTransferDiscriminator: ENABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR
    })
  );
}
function getEnableNonConfidentialCreditsInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["confidentialTransferDiscriminator", web3_js.getU8Decoder()]
  ]);
}
function getEnableNonConfidentialCreditsInstructionDataCodec() {
  return web3_js.combineCodec(
    getEnableNonConfidentialCreditsInstructionDataEncoder(),
    getEnableNonConfidentialCreditsInstructionDataDecoder()
  );
}
function getEnableNonConfidentialCreditsInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    token: { value: input.token ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.token),
      getAccountMeta(accounts.authority),
      ...remainingAccounts
    ],
    programAddress,
    data: getEnableNonConfidentialCreditsInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseEnableNonConfidentialCreditsInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      token: getNextAccount(),
      authority: getNextAccount()
    },
    data: getEnableNonConfidentialCreditsInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var FREEZE_ACCOUNT_DISCRIMINATOR = 10;
function getFreezeAccountDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(FREEZE_ACCOUNT_DISCRIMINATOR);
}
function getFreezeAccountInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([["discriminator", web3_js.getU8Encoder()]]),
    (value) => ({ ...value, discriminator: FREEZE_ACCOUNT_DISCRIMINATOR })
  );
}
function getFreezeAccountInstructionDataDecoder() {
  return web3_js.getStructDecoder([["discriminator", web3_js.getU8Decoder()]]);
}
function getFreezeAccountInstructionDataCodec() {
  return web3_js.combineCodec(
    getFreezeAccountInstructionDataEncoder(),
    getFreezeAccountInstructionDataDecoder()
  );
}
function getFreezeAccountInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    account: { value: input.account ?? null, isWritable: true },
    mint: { value: input.mint ?? null, isWritable: false },
    owner: { value: input.owner ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.account),
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.owner),
      ...remainingAccounts
    ],
    programAddress,
    data: getFreezeAccountInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseFreezeAccountInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      account: getNextAccount(),
      mint: getNextAccount(),
      owner: getNextAccount()
    },
    data: getFreezeAccountInstructionDataDecoder().decode(instruction.data)
  };
}
var GET_ACCOUNT_DATA_SIZE_DISCRIMINATOR = 21;
function getGetAccountDataSizeDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(GET_ACCOUNT_DATA_SIZE_DISCRIMINATOR);
}
function getGetAccountDataSizeInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([["discriminator", web3_js.getU8Encoder()]]),
    (value) => ({
      ...value,
      discriminator: GET_ACCOUNT_DATA_SIZE_DISCRIMINATOR
    })
  );
}
function getGetAccountDataSizeInstructionDataDecoder() {
  return web3_js.getStructDecoder([["discriminator", web3_js.getU8Decoder()]]);
}
function getGetAccountDataSizeInstructionDataCodec() {
  return web3_js.combineCodec(
    getGetAccountDataSizeInstructionDataEncoder(),
    getGetAccountDataSizeInstructionDataDecoder()
  );
}
function getGetAccountDataSizeInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    mint: { value: input.mint ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [getAccountMeta(accounts.mint)],
    programAddress,
    data: getGetAccountDataSizeInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseGetAccountDataSizeInstruction(instruction) {
  if (instruction.accounts.length < 1) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      mint: getNextAccount()
    },
    data: getGetAccountDataSizeInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var HARVEST_WITHHELD_TOKENS_TO_MINT_DISCRIMINATOR = 26;
function getHarvestWithheldTokensToMintDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(HARVEST_WITHHELD_TOKENS_TO_MINT_DISCRIMINATOR);
}
var HARVEST_WITHHELD_TOKENS_TO_MINT_TRANSFER_FEE_DISCRIMINATOR = 4;
function getHarvestWithheldTokensToMintTransferFeeDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    HARVEST_WITHHELD_TOKENS_TO_MINT_TRANSFER_FEE_DISCRIMINATOR
  );
}
function getHarvestWithheldTokensToMintInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["transferFeeDiscriminator", web3_js.getU8Encoder()]
    ]),
    (value) => ({
      ...value,
      discriminator: HARVEST_WITHHELD_TOKENS_TO_MINT_DISCRIMINATOR,
      transferFeeDiscriminator: HARVEST_WITHHELD_TOKENS_TO_MINT_TRANSFER_FEE_DISCRIMINATOR
    })
  );
}
function getHarvestWithheldTokensToMintInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["transferFeeDiscriminator", web3_js.getU8Decoder()]
  ]);
}
function getHarvestWithheldTokensToMintInstructionDataCodec() {
  return web3_js.combineCodec(
    getHarvestWithheldTokensToMintInstructionDataEncoder(),
    getHarvestWithheldTokensToMintInstructionDataDecoder()
  );
}
function getHarvestWithheldTokensToMintInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    mint: { value: input.mint ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = args.sources.map((address) => ({
    address,
    role: web3_js.AccountRole.WRITABLE
  }));
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [getAccountMeta(accounts.mint), ...remainingAccounts],
    programAddress,
    data: getHarvestWithheldTokensToMintInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseHarvestWithheldTokensToMintInstruction(instruction) {
  if (instruction.accounts.length < 1) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      mint: getNextAccount()
    },
    data: getHarvestWithheldTokensToMintInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 37;
function getHarvestWithheldTokensToMintForConfidentialTransferFeeDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR
  );
}
var HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 3;
function getHarvestWithheldTokensToMintForConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR
  );
}
function getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["confidentialTransferFeeDiscriminator", web3_js.getU8Encoder()]
    ]),
    (value) => ({
      ...value,
      discriminator: HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,
      confidentialTransferFeeDiscriminator: HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR
    })
  );
}
function getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["confidentialTransferFeeDiscriminator", web3_js.getU8Decoder()]
  ]);
}
function getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataCodec() {
  return web3_js.combineCodec(
    getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataEncoder(),
    getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataDecoder()
  );
}
function getHarvestWithheldTokensToMintForConfidentialTransferFeeInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    mint: { value: input.mint ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.sources ?? []).map(
    (address) => ({ address, role: web3_js.AccountRole.WRITABLE })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [getAccountMeta(accounts.mint), ...remainingAccounts],
    programAddress,
    data: getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataEncoder().encode(
      {}
    )
  };
  return instruction;
}
function parseHarvestWithheldTokensToMintForConfidentialTransferFeeInstruction(instruction) {
  if (instruction.accounts.length < 1) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      mint: getNextAccount()
    },
    data: getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var INITIALIZE_ACCOUNT_DISCRIMINATOR = 1;
function getInitializeAccountDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(INITIALIZE_ACCOUNT_DISCRIMINATOR);
}
function getInitializeAccountInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([["discriminator", web3_js.getU8Encoder()]]),
    (value) => ({ ...value, discriminator: INITIALIZE_ACCOUNT_DISCRIMINATOR })
  );
}
function getInitializeAccountInstructionDataDecoder() {
  return web3_js.getStructDecoder([["discriminator", web3_js.getU8Decoder()]]);
}
function getInitializeAccountInstructionDataCodec() {
  return web3_js.combineCodec(
    getInitializeAccountInstructionDataEncoder(),
    getInitializeAccountInstructionDataDecoder()
  );
}
function getInitializeAccountInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    account: { value: input.account ?? null, isWritable: true },
    mint: { value: input.mint ?? null, isWritable: false },
    owner: { value: input.owner ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.account),
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.rent)
    ],
    programAddress,
    data: getInitializeAccountInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseInitializeAccountInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      account: getNextAccount(),
      mint: getNextAccount(),
      owner: getNextAccount(),
      rent: getNextAccount()
    },
    data: getInitializeAccountInstructionDataDecoder().decode(instruction.data)
  };
}
var INITIALIZE_ACCOUNT2_DISCRIMINATOR = 16;
function getInitializeAccount2DiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(INITIALIZE_ACCOUNT2_DISCRIMINATOR);
}
function getInitializeAccount2InstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["owner", web3_js.getAddressEncoder()]
    ]),
    (value) => ({ ...value, discriminator: INITIALIZE_ACCOUNT2_DISCRIMINATOR })
  );
}
function getInitializeAccount2InstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["owner", web3_js.getAddressDecoder()]
  ]);
}
function getInitializeAccount2InstructionDataCodec() {
  return web3_js.combineCodec(
    getInitializeAccount2InstructionDataEncoder(),
    getInitializeAccount2InstructionDataDecoder()
  );
}
function getInitializeAccount2Instruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    account: { value: input.account ?? null, isWritable: true },
    mint: { value: input.mint ?? null, isWritable: false },
    rent: { value: input.rent ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.account),
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.rent)
    ],
    programAddress,
    data: getInitializeAccount2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeAccount2Instruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      account: getNextAccount(),
      mint: getNextAccount(),
      rent: getNextAccount()
    },
    data: getInitializeAccount2InstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var INITIALIZE_ACCOUNT3_DISCRIMINATOR = 18;
function getInitializeAccount3DiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(INITIALIZE_ACCOUNT3_DISCRIMINATOR);
}
function getInitializeAccount3InstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["owner", web3_js.getAddressEncoder()]
    ]),
    (value) => ({ ...value, discriminator: INITIALIZE_ACCOUNT3_DISCRIMINATOR })
  );
}
function getInitializeAccount3InstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["owner", web3_js.getAddressDecoder()]
  ]);
}
function getInitializeAccount3InstructionDataCodec() {
  return web3_js.combineCodec(
    getInitializeAccount3InstructionDataEncoder(),
    getInitializeAccount3InstructionDataDecoder()
  );
}
function getInitializeAccount3Instruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    account: { value: input.account ?? null, isWritable: true },
    mint: { value: input.mint ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [getAccountMeta(accounts.account), getAccountMeta(accounts.mint)],
    programAddress,
    data: getInitializeAccount3InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeAccount3Instruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      account: getNextAccount(),
      mint: getNextAccount()
    },
    data: getInitializeAccount3InstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 37;
function getInitializeConfidentialTransferFeeDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR
  );
}
var INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 0;
function getInitializeConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR
  );
}
function getInitializeConfidentialTransferFeeInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["confidentialTransferFeeDiscriminator", web3_js.getU8Encoder()],
      [
        "authority",
        web3_js.getOptionEncoder(web3_js.getAddressEncoder(), {
          prefix: null,
          noneValue: "zeroes"
        })
      ],
      [
        "withdrawWithheldAuthorityElGamalPubkey",
        web3_js.getOptionEncoder(web3_js.getAddressEncoder(), {
          prefix: null,
          noneValue: "zeroes"
        })
      ]
    ]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,
      confidentialTransferFeeDiscriminator: INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR
    })
  );
}
function getInitializeConfidentialTransferFeeInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["confidentialTransferFeeDiscriminator", web3_js.getU8Decoder()],
    [
      "authority",
      web3_js.getOptionDecoder(web3_js.getAddressDecoder(), {
        prefix: null,
        noneValue: "zeroes"
      })
    ],
    [
      "withdrawWithheldAuthorityElGamalPubkey",
      web3_js.getOptionDecoder(web3_js.getAddressDecoder(), {
        prefix: null,
        noneValue: "zeroes"
      })
    ]
  ]);
}
function getInitializeConfidentialTransferFeeInstructionDataCodec() {
  return web3_js.combineCodec(
    getInitializeConfidentialTransferFeeInstructionDataEncoder(),
    getInitializeConfidentialTransferFeeInstructionDataDecoder()
  );
}
function getInitializeConfidentialTransferFeeInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    mint: { value: input.mint ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [getAccountMeta(accounts.mint)],
    programAddress,
    data: getInitializeConfidentialTransferFeeInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeConfidentialTransferFeeInstruction(instruction) {
  if (instruction.accounts.length < 1) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      mint: getNextAccount()
    },
    data: getInitializeConfidentialTransferFeeInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR = 27;
function getInitializeConfidentialTransferMintDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR
  );
}
var INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 0;
function getInitializeConfidentialTransferMintConfidentialTransferDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR
  );
}
function getInitializeConfidentialTransferMintInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["confidentialTransferDiscriminator", web3_js.getU8Encoder()],
      [
        "authority",
        web3_js.getOptionEncoder(web3_js.getAddressEncoder(), {
          prefix: null,
          noneValue: "zeroes"
        })
      ],
      ["autoApproveNewAccounts", web3_js.getBooleanEncoder()],
      [
        "auditorElgamalPubkey",
        web3_js.getOptionEncoder(web3_js.getAddressEncoder(), {
          prefix: null,
          noneValue: "zeroes"
        })
      ]
    ]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR,
      confidentialTransferDiscriminator: INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR
    })
  );
}
function getInitializeConfidentialTransferMintInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["confidentialTransferDiscriminator", web3_js.getU8Decoder()],
    [
      "authority",
      web3_js.getOptionDecoder(web3_js.getAddressDecoder(), {
        prefix: null,
        noneValue: "zeroes"
      })
    ],
    ["autoApproveNewAccounts", web3_js.getBooleanDecoder()],
    [
      "auditorElgamalPubkey",
      web3_js.getOptionDecoder(web3_js.getAddressDecoder(), {
        prefix: null,
        noneValue: "zeroes"
      })
    ]
  ]);
}
function getInitializeConfidentialTransferMintInstructionDataCodec() {
  return web3_js.combineCodec(
    getInitializeConfidentialTransferMintInstructionDataEncoder(),
    getInitializeConfidentialTransferMintInstructionDataDecoder()
  );
}
function getInitializeConfidentialTransferMintInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    mint: { value: input.mint ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [getAccountMeta(accounts.mint)],
    programAddress,
    data: getInitializeConfidentialTransferMintInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeConfidentialTransferMintInstruction(instruction) {
  if (instruction.accounts.length < 1) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      mint: getNextAccount()
    },
    data: getInitializeConfidentialTransferMintInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var INITIALIZE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR = 28;
function getInitializeDefaultAccountStateDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(INITIALIZE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR);
}
var INITIALIZE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR = 0;
function getInitializeDefaultAccountStateDefaultAccountStateDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    INITIALIZE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR
  );
}
function getInitializeDefaultAccountStateInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["defaultAccountStateDiscriminator", web3_js.getU8Encoder()],
      ["state", getAccountStateEncoder()]
    ]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR,
      defaultAccountStateDiscriminator: INITIALIZE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR
    })
  );
}
function getInitializeDefaultAccountStateInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["defaultAccountStateDiscriminator", web3_js.getU8Decoder()],
    ["state", getAccountStateDecoder()]
  ]);
}
function getInitializeDefaultAccountStateInstructionDataCodec() {
  return web3_js.combineCodec(
    getInitializeDefaultAccountStateInstructionDataEncoder(),
    getInitializeDefaultAccountStateInstructionDataDecoder()
  );
}
function getInitializeDefaultAccountStateInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    mint: { value: input.mint ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [getAccountMeta(accounts.mint)],
    programAddress,
    data: getInitializeDefaultAccountStateInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeDefaultAccountStateInstruction(instruction) {
  if (instruction.accounts.length < 1) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      mint: getNextAccount()
    },
    data: getInitializeDefaultAccountStateInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var INITIALIZE_GROUP_MEMBER_POINTER_DISCRIMINATOR = 41;
function getInitializeGroupMemberPointerDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(INITIALIZE_GROUP_MEMBER_POINTER_DISCRIMINATOR);
}
var INITIALIZE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR = 0;
function getInitializeGroupMemberPointerGroupMemberPointerDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    INITIALIZE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR
  );
}
function getInitializeGroupMemberPointerInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["groupMemberPointerDiscriminator", web3_js.getU8Encoder()],
      [
        "authority",
        web3_js.getOptionEncoder(web3_js.getAddressEncoder(), {
          prefix: null,
          noneValue: "zeroes"
        })
      ],
      [
        "memberAddress",
        web3_js.getOptionEncoder(web3_js.getAddressEncoder(), {
          prefix: null,
          noneValue: "zeroes"
        })
      ]
    ]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_GROUP_MEMBER_POINTER_DISCRIMINATOR,
      groupMemberPointerDiscriminator: INITIALIZE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR
    })
  );
}
function getInitializeGroupMemberPointerInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["groupMemberPointerDiscriminator", web3_js.getU8Decoder()],
    [
      "authority",
      web3_js.getOptionDecoder(web3_js.getAddressDecoder(), {
        prefix: null,
        noneValue: "zeroes"
      })
    ],
    [
      "memberAddress",
      web3_js.getOptionDecoder(web3_js.getAddressDecoder(), {
        prefix: null,
        noneValue: "zeroes"
      })
    ]
  ]);
}
function getInitializeGroupMemberPointerInstructionDataCodec() {
  return web3_js.combineCodec(
    getInitializeGroupMemberPointerInstructionDataEncoder(),
    getInitializeGroupMemberPointerInstructionDataDecoder()
  );
}
function getInitializeGroupMemberPointerInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    mint: { value: input.mint ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [getAccountMeta(accounts.mint)],
    programAddress,
    data: getInitializeGroupMemberPointerInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeGroupMemberPointerInstruction(instruction) {
  if (instruction.accounts.length < 1) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      mint: getNextAccount()
    },
    data: getInitializeGroupMemberPointerInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var INITIALIZE_GROUP_POINTER_DISCRIMINATOR = 40;
function getInitializeGroupPointerDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(INITIALIZE_GROUP_POINTER_DISCRIMINATOR);
}
var INITIALIZE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR = 0;
function getInitializeGroupPointerGroupPointerDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    INITIALIZE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR
  );
}
function getInitializeGroupPointerInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["groupPointerDiscriminator", web3_js.getU8Encoder()],
      [
        "authority",
        web3_js.getOptionEncoder(web3_js.getAddressEncoder(), {
          prefix: null,
          noneValue: "zeroes"
        })
      ],
      [
        "groupAddress",
        web3_js.getOptionEncoder(web3_js.getAddressEncoder(), {
          prefix: null,
          noneValue: "zeroes"
        })
      ]
    ]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_GROUP_POINTER_DISCRIMINATOR,
      groupPointerDiscriminator: INITIALIZE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR
    })
  );
}
function getInitializeGroupPointerInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["groupPointerDiscriminator", web3_js.getU8Decoder()],
    [
      "authority",
      web3_js.getOptionDecoder(web3_js.getAddressDecoder(), {
        prefix: null,
        noneValue: "zeroes"
      })
    ],
    [
      "groupAddress",
      web3_js.getOptionDecoder(web3_js.getAddressDecoder(), {
        prefix: null,
        noneValue: "zeroes"
      })
    ]
  ]);
}
function getInitializeGroupPointerInstructionDataCodec() {
  return web3_js.combineCodec(
    getInitializeGroupPointerInstructionDataEncoder(),
    getInitializeGroupPointerInstructionDataDecoder()
  );
}
function getInitializeGroupPointerInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    mint: { value: input.mint ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [getAccountMeta(accounts.mint)],
    programAddress,
    data: getInitializeGroupPointerInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeGroupPointerInstruction(instruction) {
  if (instruction.accounts.length < 1) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      mint: getNextAccount()
    },
    data: getInitializeGroupPointerInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var INITIALIZE_IMMUTABLE_OWNER_DISCRIMINATOR = 22;
function getInitializeImmutableOwnerDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(INITIALIZE_IMMUTABLE_OWNER_DISCRIMINATOR);
}
function getInitializeImmutableOwnerInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([["discriminator", web3_js.getU8Encoder()]]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_IMMUTABLE_OWNER_DISCRIMINATOR
    })
  );
}
function getInitializeImmutableOwnerInstructionDataDecoder() {
  return web3_js.getStructDecoder([["discriminator", web3_js.getU8Decoder()]]);
}
function getInitializeImmutableOwnerInstructionDataCodec() {
  return web3_js.combineCodec(
    getInitializeImmutableOwnerInstructionDataEncoder(),
    getInitializeImmutableOwnerInstructionDataDecoder()
  );
}
function getInitializeImmutableOwnerInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    account: { value: input.account ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [getAccountMeta(accounts.account)],
    programAddress,
    data: getInitializeImmutableOwnerInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseInitializeImmutableOwnerInstruction(instruction) {
  if (instruction.accounts.length < 1) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      account: getNextAccount()
    },
    data: getInitializeImmutableOwnerInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var INITIALIZE_INTEREST_BEARING_MINT_DISCRIMINATOR = 33;
function getInitializeInterestBearingMintDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(INITIALIZE_INTEREST_BEARING_MINT_DISCRIMINATOR);
}
var INITIALIZE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR = 0;
function getInitializeInterestBearingMintInterestBearingMintDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    INITIALIZE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR
  );
}
function getInitializeInterestBearingMintInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["interestBearingMintDiscriminator", web3_js.getU8Encoder()],
      [
        "rateAuthority",
        web3_js.getOptionEncoder(web3_js.getAddressEncoder(), {
          prefix: null,
          noneValue: "zeroes"
        })
      ],
      ["rate", web3_js.getI16Encoder()]
    ]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_INTEREST_BEARING_MINT_DISCRIMINATOR,
      interestBearingMintDiscriminator: INITIALIZE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR
    })
  );
}
function getInitializeInterestBearingMintInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["interestBearingMintDiscriminator", web3_js.getU8Decoder()],
    [
      "rateAuthority",
      web3_js.getOptionDecoder(web3_js.getAddressDecoder(), {
        prefix: null,
        noneValue: "zeroes"
      })
    ],
    ["rate", web3_js.getI16Decoder()]
  ]);
}
function getInitializeInterestBearingMintInstructionDataCodec() {
  return web3_js.combineCodec(
    getInitializeInterestBearingMintInstructionDataEncoder(),
    getInitializeInterestBearingMintInstructionDataDecoder()
  );
}
function getInitializeInterestBearingMintInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    mint: { value: input.mint ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [getAccountMeta(accounts.mint)],
    programAddress,
    data: getInitializeInterestBearingMintInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeInterestBearingMintInstruction(instruction) {
  if (instruction.accounts.length < 1) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      mint: getNextAccount()
    },
    data: getInitializeInterestBearingMintInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var INITIALIZE_METADATA_POINTER_DISCRIMINATOR = 39;
function getInitializeMetadataPointerDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(INITIALIZE_METADATA_POINTER_DISCRIMINATOR);
}
var INITIALIZE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR = 0;
function getInitializeMetadataPointerMetadataPointerDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    INITIALIZE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR
  );
}
function getInitializeMetadataPointerInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["metadataPointerDiscriminator", web3_js.getU8Encoder()],
      [
        "authority",
        web3_js.getOptionEncoder(web3_js.getAddressEncoder(), {
          prefix: null,
          noneValue: "zeroes"
        })
      ],
      [
        "metadataAddress",
        web3_js.getOptionEncoder(web3_js.getAddressEncoder(), {
          prefix: null,
          noneValue: "zeroes"
        })
      ]
    ]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_METADATA_POINTER_DISCRIMINATOR,
      metadataPointerDiscriminator: INITIALIZE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR
    })
  );
}
function getInitializeMetadataPointerInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["metadataPointerDiscriminator", web3_js.getU8Decoder()],
    [
      "authority",
      web3_js.getOptionDecoder(web3_js.getAddressDecoder(), {
        prefix: null,
        noneValue: "zeroes"
      })
    ],
    [
      "metadataAddress",
      web3_js.getOptionDecoder(web3_js.getAddressDecoder(), {
        prefix: null,
        noneValue: "zeroes"
      })
    ]
  ]);
}
function getInitializeMetadataPointerInstructionDataCodec() {
  return web3_js.combineCodec(
    getInitializeMetadataPointerInstructionDataEncoder(),
    getInitializeMetadataPointerInstructionDataDecoder()
  );
}
function getInitializeMetadataPointerInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    mint: { value: input.mint ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [getAccountMeta(accounts.mint)],
    programAddress,
    data: getInitializeMetadataPointerInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeMetadataPointerInstruction(instruction) {
  if (instruction.accounts.length < 1) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      mint: getNextAccount()
    },
    data: getInitializeMetadataPointerInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var INITIALIZE_MINT_DISCRIMINATOR = 0;
function getInitializeMintDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(INITIALIZE_MINT_DISCRIMINATOR);
}
function getInitializeMintInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["decimals", web3_js.getU8Encoder()],
      ["mintAuthority", web3_js.getAddressEncoder()],
      ["freezeAuthority", web3_js.getOptionEncoder(web3_js.getAddressEncoder())]
    ]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_MINT_DISCRIMINATOR,
      freezeAuthority: value.freezeAuthority ?? web3_js.none()
    })
  );
}
function getInitializeMintInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["decimals", web3_js.getU8Decoder()],
    ["mintAuthority", web3_js.getAddressDecoder()],
    ["freezeAuthority", web3_js.getOptionDecoder(web3_js.getAddressDecoder())]
  ]);
}
function getInitializeMintInstructionDataCodec() {
  return web3_js.combineCodec(
    getInitializeMintInstructionDataEncoder(),
    getInitializeMintInstructionDataDecoder()
  );
}
function getInitializeMintInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    mint: { value: input.mint ?? null, isWritable: true },
    rent: { value: input.rent ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [getAccountMeta(accounts.mint), getAccountMeta(accounts.rent)],
    programAddress,
    data: getInitializeMintInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeMintInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      mint: getNextAccount(),
      rent: getNextAccount()
    },
    data: getInitializeMintInstructionDataDecoder().decode(instruction.data)
  };
}
var INITIALIZE_MINT2_DISCRIMINATOR = 20;
function getInitializeMint2DiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(INITIALIZE_MINT2_DISCRIMINATOR);
}
function getInitializeMint2InstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["decimals", web3_js.getU8Encoder()],
      ["mintAuthority", web3_js.getAddressEncoder()],
      ["freezeAuthority", web3_js.getOptionEncoder(web3_js.getAddressEncoder())]
    ]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_MINT2_DISCRIMINATOR,
      freezeAuthority: value.freezeAuthority ?? web3_js.none()
    })
  );
}
function getInitializeMint2InstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["decimals", web3_js.getU8Decoder()],
    ["mintAuthority", web3_js.getAddressDecoder()],
    ["freezeAuthority", web3_js.getOptionDecoder(web3_js.getAddressDecoder())]
  ]);
}
function getInitializeMint2InstructionDataCodec() {
  return web3_js.combineCodec(
    getInitializeMint2InstructionDataEncoder(),
    getInitializeMint2InstructionDataDecoder()
  );
}
function getInitializeMint2Instruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    mint: { value: input.mint ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [getAccountMeta(accounts.mint)],
    programAddress,
    data: getInitializeMint2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeMint2Instruction(instruction) {
  if (instruction.accounts.length < 1) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      mint: getNextAccount()
    },
    data: getInitializeMint2InstructionDataDecoder().decode(instruction.data)
  };
}
var INITIALIZE_MINT_CLOSE_AUTHORITY_DISCRIMINATOR = 25;
function getInitializeMintCloseAuthorityDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(INITIALIZE_MINT_CLOSE_AUTHORITY_DISCRIMINATOR);
}
function getInitializeMintCloseAuthorityInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["closeAuthority", web3_js.getOptionEncoder(web3_js.getAddressEncoder())]
    ]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_MINT_CLOSE_AUTHORITY_DISCRIMINATOR
    })
  );
}
function getInitializeMintCloseAuthorityInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["closeAuthority", web3_js.getOptionDecoder(web3_js.getAddressDecoder())]
  ]);
}
function getInitializeMintCloseAuthorityInstructionDataCodec() {
  return web3_js.combineCodec(
    getInitializeMintCloseAuthorityInstructionDataEncoder(),
    getInitializeMintCloseAuthorityInstructionDataDecoder()
  );
}
function getInitializeMintCloseAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    mint: { value: input.mint ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [getAccountMeta(accounts.mint)],
    programAddress,
    data: getInitializeMintCloseAuthorityInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeMintCloseAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 1) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      mint: getNextAccount()
    },
    data: getInitializeMintCloseAuthorityInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var INITIALIZE_MULTISIG_DISCRIMINATOR = 2;
function getInitializeMultisigDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(INITIALIZE_MULTISIG_DISCRIMINATOR);
}
function getInitializeMultisigInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["m", web3_js.getU8Encoder()]
    ]),
    (value) => ({ ...value, discriminator: INITIALIZE_MULTISIG_DISCRIMINATOR })
  );
}
function getInitializeMultisigInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["m", web3_js.getU8Decoder()]
  ]);
}
function getInitializeMultisigInstructionDataCodec() {
  return web3_js.combineCodec(
    getInitializeMultisigInstructionDataEncoder(),
    getInitializeMultisigInstructionDataDecoder()
  );
}
function getInitializeMultisigInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    multisig: { value: input.multisig ?? null, isWritable: true },
    rent: { value: input.rent ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.rent.value) {
    accounts.rent.value = "SysvarRent111111111111111111111111111111111";
  }
  const remainingAccounts = args.signers.map((address) => ({
    address,
    role: web3_js.AccountRole.READONLY
  }));
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.multisig),
      getAccountMeta(accounts.rent),
      ...remainingAccounts
    ],
    programAddress,
    data: getInitializeMultisigInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeMultisigInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      multisig: getNextAccount(),
      rent: getNextAccount()
    },
    data: getInitializeMultisigInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var INITIALIZE_MULTISIG2_DISCRIMINATOR = 19;
function getInitializeMultisig2DiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(INITIALIZE_MULTISIG2_DISCRIMINATOR);
}
function getInitializeMultisig2InstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["m", web3_js.getU8Encoder()]
    ]),
    (value) => ({ ...value, discriminator: INITIALIZE_MULTISIG2_DISCRIMINATOR })
  );
}
function getInitializeMultisig2InstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["m", web3_js.getU8Decoder()]
  ]);
}
function getInitializeMultisig2InstructionDataCodec() {
  return web3_js.combineCodec(
    getInitializeMultisig2InstructionDataEncoder(),
    getInitializeMultisig2InstructionDataDecoder()
  );
}
function getInitializeMultisig2Instruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    multisig: { value: input.multisig ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = args.signers.map((address) => ({
    address,
    role: web3_js.AccountRole.READONLY
  }));
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [getAccountMeta(accounts.multisig), ...remainingAccounts],
    programAddress,
    data: getInitializeMultisig2InstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeMultisig2Instruction(instruction) {
  if (instruction.accounts.length < 1) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      multisig: getNextAccount()
    },
    data: getInitializeMultisig2InstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var INITIALIZE_NON_TRANSFERABLE_MINT_DISCRIMINATOR = 32;
function getInitializeNonTransferableMintDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(INITIALIZE_NON_TRANSFERABLE_MINT_DISCRIMINATOR);
}
function getInitializeNonTransferableMintInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([["discriminator", web3_js.getU8Encoder()]]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_NON_TRANSFERABLE_MINT_DISCRIMINATOR
    })
  );
}
function getInitializeNonTransferableMintInstructionDataDecoder() {
  return web3_js.getStructDecoder([["discriminator", web3_js.getU8Decoder()]]);
}
function getInitializeNonTransferableMintInstructionDataCodec() {
  return web3_js.combineCodec(
    getInitializeNonTransferableMintInstructionDataEncoder(),
    getInitializeNonTransferableMintInstructionDataDecoder()
  );
}
function getInitializeNonTransferableMintInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    mint: { value: input.mint ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [getAccountMeta(accounts.mint)],
    programAddress,
    data: getInitializeNonTransferableMintInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseInitializeNonTransferableMintInstruction(instruction) {
  if (instruction.accounts.length < 1) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      mint: getNextAccount()
    },
    data: getInitializeNonTransferableMintInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var INITIALIZE_PERMANENT_DELEGATE_DISCRIMINATOR = 35;
function getInitializePermanentDelegateDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(INITIALIZE_PERMANENT_DELEGATE_DISCRIMINATOR);
}
function getInitializePermanentDelegateInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["delegate", web3_js.getAddressEncoder()]
    ]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_PERMANENT_DELEGATE_DISCRIMINATOR
    })
  );
}
function getInitializePermanentDelegateInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["delegate", web3_js.getAddressDecoder()]
  ]);
}
function getInitializePermanentDelegateInstructionDataCodec() {
  return web3_js.combineCodec(
    getInitializePermanentDelegateInstructionDataEncoder(),
    getInitializePermanentDelegateInstructionDataDecoder()
  );
}
function getInitializePermanentDelegateInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    mint: { value: input.mint ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [getAccountMeta(accounts.mint)],
    programAddress,
    data: getInitializePermanentDelegateInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializePermanentDelegateInstruction(instruction) {
  if (instruction.accounts.length < 1) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      mint: getNextAccount()
    },
    data: getInitializePermanentDelegateInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var INITIALIZE_TOKEN_GROUP_DISCRIMINATOR = new Uint8Array([
  121,
  113,
  108,
  39,
  54,
  51,
  0,
  4
]);
function getInitializeTokenGroupDiscriminatorBytes() {
  return web3_js.getBytesEncoder().encode(INITIALIZE_TOKEN_GROUP_DISCRIMINATOR);
}
function getInitializeTokenGroupInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getBytesEncoder()],
      [
        "updateAuthority",
        web3_js.getOptionEncoder(web3_js.getAddressEncoder(), {
          prefix: null,
          noneValue: "zeroes"
        })
      ],
      ["maxSize", web3_js.getU64Encoder()]
    ]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_TOKEN_GROUP_DISCRIMINATOR
    })
  );
}
function getInitializeTokenGroupInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getBytesDecoder()],
    [
      "updateAuthority",
      web3_js.getOptionDecoder(web3_js.getAddressDecoder(), {
        prefix: null,
        noneValue: "zeroes"
      })
    ],
    ["maxSize", web3_js.getU64Decoder()]
  ]);
}
function getInitializeTokenGroupInstructionDataCodec() {
  return web3_js.combineCodec(
    getInitializeTokenGroupInstructionDataEncoder(),
    getInitializeTokenGroupInstructionDataDecoder()
  );
}
function getInitializeTokenGroupInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    group: { value: input.group ?? null, isWritable: true },
    mint: { value: input.mint ?? null, isWritable: false },
    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.group),
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.mintAuthority)
    ],
    programAddress,
    data: getInitializeTokenGroupInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeTokenGroupInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      group: getNextAccount(),
      mint: getNextAccount(),
      mintAuthority: getNextAccount()
    },
    data: getInitializeTokenGroupInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var INITIALIZE_TOKEN_GROUP_MEMBER_DISCRIMINATOR = new Uint8Array([
  152,
  32,
  222,
  176,
  223,
  237,
  116,
  134
]);
function getInitializeTokenGroupMemberDiscriminatorBytes() {
  return web3_js.getBytesEncoder().encode(INITIALIZE_TOKEN_GROUP_MEMBER_DISCRIMINATOR);
}
function getInitializeTokenGroupMemberInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([["discriminator", web3_js.getBytesEncoder()]]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_TOKEN_GROUP_MEMBER_DISCRIMINATOR
    })
  );
}
function getInitializeTokenGroupMemberInstructionDataDecoder() {
  return web3_js.getStructDecoder([["discriminator", web3_js.getBytesDecoder()]]);
}
function getInitializeTokenGroupMemberInstructionDataCodec() {
  return web3_js.combineCodec(
    getInitializeTokenGroupMemberInstructionDataEncoder(),
    getInitializeTokenGroupMemberInstructionDataDecoder()
  );
}
function getInitializeTokenGroupMemberInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    member: { value: input.member ?? null, isWritable: true },
    memberMint: { value: input.memberMint ?? null, isWritable: false },
    memberMintAuthority: {
      value: input.memberMintAuthority ?? null,
      isWritable: false
    },
    group: { value: input.group ?? null, isWritable: true },
    groupUpdateAuthority: {
      value: input.groupUpdateAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.member),
      getAccountMeta(accounts.memberMint),
      getAccountMeta(accounts.memberMintAuthority),
      getAccountMeta(accounts.group),
      getAccountMeta(accounts.groupUpdateAuthority)
    ],
    programAddress,
    data: getInitializeTokenGroupMemberInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseInitializeTokenGroupMemberInstruction(instruction) {
  if (instruction.accounts.length < 5) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      member: getNextAccount(),
      memberMint: getNextAccount(),
      memberMintAuthority: getNextAccount(),
      group: getNextAccount(),
      groupUpdateAuthority: getNextAccount()
    },
    data: getInitializeTokenGroupMemberInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var INITIALIZE_TOKEN_METADATA_DISCRIMINATOR = new Uint8Array([
  210,
  225,
  30,
  162,
  88,
  184,
  77,
  141
]);
function getInitializeTokenMetadataDiscriminatorBytes() {
  return web3_js.getBytesEncoder().encode(INITIALIZE_TOKEN_METADATA_DISCRIMINATOR);
}
function getInitializeTokenMetadataInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getBytesEncoder()],
      ["name", web3_js.addEncoderSizePrefix(web3_js.getUtf8Encoder(), web3_js.getU32Encoder())],
      ["symbol", web3_js.addEncoderSizePrefix(web3_js.getUtf8Encoder(), web3_js.getU32Encoder())],
      ["uri", web3_js.addEncoderSizePrefix(web3_js.getUtf8Encoder(), web3_js.getU32Encoder())]
    ]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_TOKEN_METADATA_DISCRIMINATOR
    })
  );
}
function getInitializeTokenMetadataInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getBytesDecoder()],
    ["name", web3_js.addDecoderSizePrefix(web3_js.getUtf8Decoder(), web3_js.getU32Decoder())],
    ["symbol", web3_js.addDecoderSizePrefix(web3_js.getUtf8Decoder(), web3_js.getU32Decoder())],
    ["uri", web3_js.addDecoderSizePrefix(web3_js.getUtf8Decoder(), web3_js.getU32Decoder())]
  ]);
}
function getInitializeTokenMetadataInstructionDataCodec() {
  return web3_js.combineCodec(
    getInitializeTokenMetadataInstructionDataEncoder(),
    getInitializeTokenMetadataInstructionDataDecoder()
  );
}
function getInitializeTokenMetadataInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    metadata: { value: input.metadata ?? null, isWritable: true },
    updateAuthority: {
      value: input.updateAuthority ?? null,
      isWritable: false
    },
    mint: { value: input.mint ?? null, isWritable: false },
    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.metadata),
      getAccountMeta(accounts.updateAuthority),
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.mintAuthority)
    ],
    programAddress,
    data: getInitializeTokenMetadataInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeTokenMetadataInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      metadata: getNextAccount(),
      updateAuthority: getNextAccount(),
      mint: getNextAccount(),
      mintAuthority: getNextAccount()
    },
    data: getInitializeTokenMetadataInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var INITIALIZE_TRANSFER_FEE_CONFIG_DISCRIMINATOR = 26;
function getInitializeTransferFeeConfigDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(INITIALIZE_TRANSFER_FEE_CONFIG_DISCRIMINATOR);
}
var INITIALIZE_TRANSFER_FEE_CONFIG_TRANSFER_FEE_DISCRIMINATOR = 0;
function getInitializeTransferFeeConfigTransferFeeDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    INITIALIZE_TRANSFER_FEE_CONFIG_TRANSFER_FEE_DISCRIMINATOR
  );
}
function getInitializeTransferFeeConfigInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["transferFeeDiscriminator", web3_js.getU8Encoder()],
      ["transferFeeConfigAuthority", web3_js.getOptionEncoder(web3_js.getAddressEncoder())],
      ["withdrawWithheldAuthority", web3_js.getOptionEncoder(web3_js.getAddressEncoder())],
      ["transferFeeBasisPoints", web3_js.getU16Encoder()],
      ["maximumFee", web3_js.getU64Encoder()]
    ]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_TRANSFER_FEE_CONFIG_DISCRIMINATOR,
      transferFeeDiscriminator: INITIALIZE_TRANSFER_FEE_CONFIG_TRANSFER_FEE_DISCRIMINATOR
    })
  );
}
function getInitializeTransferFeeConfigInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["transferFeeDiscriminator", web3_js.getU8Decoder()],
    ["transferFeeConfigAuthority", web3_js.getOptionDecoder(web3_js.getAddressDecoder())],
    ["withdrawWithheldAuthority", web3_js.getOptionDecoder(web3_js.getAddressDecoder())],
    ["transferFeeBasisPoints", web3_js.getU16Decoder()],
    ["maximumFee", web3_js.getU64Decoder()]
  ]);
}
function getInitializeTransferFeeConfigInstructionDataCodec() {
  return web3_js.combineCodec(
    getInitializeTransferFeeConfigInstructionDataEncoder(),
    getInitializeTransferFeeConfigInstructionDataDecoder()
  );
}
function getInitializeTransferFeeConfigInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    mint: { value: input.mint ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [getAccountMeta(accounts.mint)],
    programAddress,
    data: getInitializeTransferFeeConfigInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeTransferFeeConfigInstruction(instruction) {
  if (instruction.accounts.length < 1) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      mint: getNextAccount()
    },
    data: getInitializeTransferFeeConfigInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var INITIALIZE_TRANSFER_HOOK_DISCRIMINATOR = 36;
function getInitializeTransferHookDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(INITIALIZE_TRANSFER_HOOK_DISCRIMINATOR);
}
var INITIALIZE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR = 0;
function getInitializeTransferHookTransferHookDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    INITIALIZE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR
  );
}
function getInitializeTransferHookInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["transferHookDiscriminator", web3_js.getU8Encoder()],
      [
        "authority",
        web3_js.getOptionEncoder(web3_js.getAddressEncoder(), {
          prefix: null,
          noneValue: "zeroes"
        })
      ],
      [
        "programId",
        web3_js.getOptionEncoder(web3_js.getAddressEncoder(), {
          prefix: null,
          noneValue: "zeroes"
        })
      ]
    ]),
    (value) => ({
      ...value,
      discriminator: INITIALIZE_TRANSFER_HOOK_DISCRIMINATOR,
      transferHookDiscriminator: INITIALIZE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR
    })
  );
}
function getInitializeTransferHookInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["transferHookDiscriminator", web3_js.getU8Decoder()],
    [
      "authority",
      web3_js.getOptionDecoder(web3_js.getAddressDecoder(), {
        prefix: null,
        noneValue: "zeroes"
      })
    ],
    [
      "programId",
      web3_js.getOptionDecoder(web3_js.getAddressDecoder(), {
        prefix: null,
        noneValue: "zeroes"
      })
    ]
  ]);
}
function getInitializeTransferHookInstructionDataCodec() {
  return web3_js.combineCodec(
    getInitializeTransferHookInstructionDataEncoder(),
    getInitializeTransferHookInstructionDataDecoder()
  );
}
function getInitializeTransferHookInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    mint: { value: input.mint ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [getAccountMeta(accounts.mint)],
    programAddress,
    data: getInitializeTransferHookInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseInitializeTransferHookInstruction(instruction) {
  if (instruction.accounts.length < 1) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      mint: getNextAccount()
    },
    data: getInitializeTransferHookInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var MINT_TO_DISCRIMINATOR = 7;
function getMintToDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(MINT_TO_DISCRIMINATOR);
}
function getMintToInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["amount", web3_js.getU64Encoder()]
    ]),
    (value) => ({ ...value, discriminator: MINT_TO_DISCRIMINATOR })
  );
}
function getMintToInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["amount", web3_js.getU64Decoder()]
  ]);
}
function getMintToInstructionDataCodec() {
  return web3_js.combineCodec(
    getMintToInstructionDataEncoder(),
    getMintToInstructionDataDecoder()
  );
}
function getMintToInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    mint: { value: input.mint ?? null, isWritable: true },
    token: { value: input.token ?? null, isWritable: true },
    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.token),
      getAccountMeta(accounts.mintAuthority),
      ...remainingAccounts
    ],
    programAddress,
    data: getMintToInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseMintToInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      mint: getNextAccount(),
      token: getNextAccount(),
      mintAuthority: getNextAccount()
    },
    data: getMintToInstructionDataDecoder().decode(instruction.data)
  };
}
var MINT_TO_CHECKED_DISCRIMINATOR = 14;
function getMintToCheckedDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(MINT_TO_CHECKED_DISCRIMINATOR);
}
function getMintToCheckedInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["amount", web3_js.getU64Encoder()],
      ["decimals", web3_js.getU8Encoder()]
    ]),
    (value) => ({ ...value, discriminator: MINT_TO_CHECKED_DISCRIMINATOR })
  );
}
function getMintToCheckedInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["amount", web3_js.getU64Decoder()],
    ["decimals", web3_js.getU8Decoder()]
  ]);
}
function getMintToCheckedInstructionDataCodec() {
  return web3_js.combineCodec(
    getMintToCheckedInstructionDataEncoder(),
    getMintToCheckedInstructionDataDecoder()
  );
}
function getMintToCheckedInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    mint: { value: input.mint ?? null, isWritable: true },
    token: { value: input.token ?? null, isWritable: true },
    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.token),
      getAccountMeta(accounts.mintAuthority),
      ...remainingAccounts
    ],
    programAddress,
    data: getMintToCheckedInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseMintToCheckedInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      mint: getNextAccount(),
      token: getNextAccount(),
      mintAuthority: getNextAccount()
    },
    data: getMintToCheckedInstructionDataDecoder().decode(instruction.data)
  };
}
var REALLOCATE_DISCRIMINATOR = 29;
function getReallocateDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(REALLOCATE_DISCRIMINATOR);
}
function getReallocateInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      [
        "newExtensionTypes",
        web3_js.getArrayEncoder(getExtensionTypeEncoder(), { size: "remainder" })
      ]
    ]),
    (value) => ({ ...value, discriminator: REALLOCATE_DISCRIMINATOR })
  );
}
function getReallocateInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    [
      "newExtensionTypes",
      web3_js.getArrayDecoder(getExtensionTypeDecoder(), { size: "remainder" })
    ]
  ]);
}
function getReallocateInstructionDataCodec() {
  return web3_js.combineCodec(
    getReallocateInstructionDataEncoder(),
    getReallocateInstructionDataDecoder()
  );
}
function getReallocateInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    token: { value: input.token ?? null, isWritable: true },
    payer: { value: input.payer ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    owner: { value: input.owner ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value = "11111111111111111111111111111111";
  }
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.token),
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.owner),
      ...remainingAccounts
    ],
    programAddress,
    data: getReallocateInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseReallocateInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      token: getNextAccount(),
      payer: getNextAccount(),
      systemProgram: getNextAccount(),
      owner: getNextAccount()
    },
    data: getReallocateInstructionDataDecoder().decode(instruction.data)
  };
}
var RECOVER_NESTED_ASSOCIATED_TOKEN_DISCRIMINATOR = 2;
function getRecoverNestedAssociatedTokenDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(RECOVER_NESTED_ASSOCIATED_TOKEN_DISCRIMINATOR);
}
function getRecoverNestedAssociatedTokenInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([["discriminator", web3_js.getU8Encoder()]]),
    (value) => ({
      ...value,
      discriminator: RECOVER_NESTED_ASSOCIATED_TOKEN_DISCRIMINATOR
    })
  );
}
function getRecoverNestedAssociatedTokenInstructionDataDecoder() {
  return web3_js.getStructDecoder([["discriminator", web3_js.getU8Decoder()]]);
}
function getRecoverNestedAssociatedTokenInstructionDataCodec() {
  return web3_js.combineCodec(
    getRecoverNestedAssociatedTokenInstructionDataEncoder(),
    getRecoverNestedAssociatedTokenInstructionDataDecoder()
  );
}
async function getRecoverNestedAssociatedTokenInstructionAsync(input, config) {
  const programAddress = config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;
  const originalAccounts = {
    nestedAssociatedAccountAddress: {
      value: input.nestedAssociatedAccountAddress ?? null,
      isWritable: true
    },
    nestedTokenMintAddress: {
      value: input.nestedTokenMintAddress ?? null,
      isWritable: false
    },
    destinationAssociatedAccountAddress: {
      value: input.destinationAssociatedAccountAddress ?? null,
      isWritable: true
    },
    ownerAssociatedAccountAddress: {
      value: input.ownerAssociatedAccountAddress ?? null,
      isWritable: false
    },
    ownerTokenMintAddress: {
      value: input.ownerTokenMintAddress ?? null,
      isWritable: false
    },
    walletAddress: { value: input.walletAddress ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb";
  }
  if (!accounts.ownerAssociatedAccountAddress.value) {
    accounts.ownerAssociatedAccountAddress.value = await findAssociatedTokenPda(
      {
        owner: expectAddress(accounts.walletAddress.value),
        tokenProgram: expectAddress(accounts.tokenProgram.value),
        mint: expectAddress(accounts.ownerTokenMintAddress.value)
      }
    );
  }
  if (!accounts.nestedAssociatedAccountAddress.value) {
    accounts.nestedAssociatedAccountAddress.value = await findAssociatedTokenPda({
      owner: expectAddress(accounts.ownerAssociatedAccountAddress.value),
      tokenProgram: expectAddress(accounts.tokenProgram.value),
      mint: expectAddress(accounts.nestedTokenMintAddress.value)
    });
  }
  if (!accounts.destinationAssociatedAccountAddress.value) {
    accounts.destinationAssociatedAccountAddress.value = await findAssociatedTokenPda({
      owner: expectAddress(accounts.walletAddress.value),
      tokenProgram: expectAddress(accounts.tokenProgram.value),
      mint: expectAddress(accounts.nestedTokenMintAddress.value)
    });
  }
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.nestedAssociatedAccountAddress),
      getAccountMeta(accounts.nestedTokenMintAddress),
      getAccountMeta(accounts.destinationAssociatedAccountAddress),
      getAccountMeta(accounts.ownerAssociatedAccountAddress),
      getAccountMeta(accounts.ownerTokenMintAddress),
      getAccountMeta(accounts.walletAddress),
      getAccountMeta(accounts.tokenProgram)
    ],
    programAddress,
    data: getRecoverNestedAssociatedTokenInstructionDataEncoder().encode({})
  };
  return instruction;
}
function getRecoverNestedAssociatedTokenInstruction(input, config) {
  const programAddress = config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;
  const originalAccounts = {
    nestedAssociatedAccountAddress: {
      value: input.nestedAssociatedAccountAddress ?? null,
      isWritable: true
    },
    nestedTokenMintAddress: {
      value: input.nestedTokenMintAddress ?? null,
      isWritable: false
    },
    destinationAssociatedAccountAddress: {
      value: input.destinationAssociatedAccountAddress ?? null,
      isWritable: true
    },
    ownerAssociatedAccountAddress: {
      value: input.ownerAssociatedAccountAddress ?? null,
      isWritable: false
    },
    ownerTokenMintAddress: {
      value: input.ownerTokenMintAddress ?? null,
      isWritable: false
    },
    walletAddress: { value: input.walletAddress ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value = "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb";
  }
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.nestedAssociatedAccountAddress),
      getAccountMeta(accounts.nestedTokenMintAddress),
      getAccountMeta(accounts.destinationAssociatedAccountAddress),
      getAccountMeta(accounts.ownerAssociatedAccountAddress),
      getAccountMeta(accounts.ownerTokenMintAddress),
      getAccountMeta(accounts.walletAddress),
      getAccountMeta(accounts.tokenProgram)
    ],
    programAddress,
    data: getRecoverNestedAssociatedTokenInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseRecoverNestedAssociatedTokenInstruction(instruction) {
  if (instruction.accounts.length < 7) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      nestedAssociatedAccountAddress: getNextAccount(),
      nestedTokenMintAddress: getNextAccount(),
      destinationAssociatedAccountAddress: getNextAccount(),
      ownerAssociatedAccountAddress: getNextAccount(),
      ownerTokenMintAddress: getNextAccount(),
      walletAddress: getNextAccount(),
      tokenProgram: getNextAccount()
    },
    data: getRecoverNestedAssociatedTokenInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var REMOVE_TOKEN_METADATA_KEY_DISCRIMINATOR = new Uint8Array([
  234,
  18,
  32,
  56,
  89,
  141,
  37,
  181
]);
function getRemoveTokenMetadataKeyDiscriminatorBytes() {
  return web3_js.getBytesEncoder().encode(REMOVE_TOKEN_METADATA_KEY_DISCRIMINATOR);
}
function getRemoveTokenMetadataKeyInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getBytesEncoder()],
      ["idempotent", web3_js.getBooleanEncoder()],
      ["key", web3_js.addEncoderSizePrefix(web3_js.getUtf8Encoder(), web3_js.getU32Encoder())]
    ]),
    (value) => ({
      ...value,
      discriminator: REMOVE_TOKEN_METADATA_KEY_DISCRIMINATOR,
      idempotent: value.idempotent ?? false
    })
  );
}
function getRemoveTokenMetadataKeyInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getBytesDecoder()],
    ["idempotent", web3_js.getBooleanDecoder()],
    ["key", web3_js.addDecoderSizePrefix(web3_js.getUtf8Decoder(), web3_js.getU32Decoder())]
  ]);
}
function getRemoveTokenMetadataKeyInstructionDataCodec() {
  return web3_js.combineCodec(
    getRemoveTokenMetadataKeyInstructionDataEncoder(),
    getRemoveTokenMetadataKeyInstructionDataDecoder()
  );
}
function getRemoveTokenMetadataKeyInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    metadata: { value: input.metadata ?? null, isWritable: true },
    updateAuthority: {
      value: input.updateAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.metadata),
      getAccountMeta(accounts.updateAuthority)
    ],
    programAddress,
    data: getRemoveTokenMetadataKeyInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseRemoveTokenMetadataKeyInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      metadata: getNextAccount(),
      updateAuthority: getNextAccount()
    },
    data: getRemoveTokenMetadataKeyInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var REVOKE_DISCRIMINATOR = 5;
function getRevokeDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(REVOKE_DISCRIMINATOR);
}
function getRevokeInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([["discriminator", web3_js.getU8Encoder()]]),
    (value) => ({ ...value, discriminator: REVOKE_DISCRIMINATOR })
  );
}
function getRevokeInstructionDataDecoder() {
  return web3_js.getStructDecoder([["discriminator", web3_js.getU8Decoder()]]);
}
function getRevokeInstructionDataCodec() {
  return web3_js.combineCodec(
    getRevokeInstructionDataEncoder(),
    getRevokeInstructionDataDecoder()
  );
}
function getRevokeInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    source: { value: input.source ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.source),
      getAccountMeta(accounts.owner),
      ...remainingAccounts
    ],
    programAddress,
    data: getRevokeInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseRevokeInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      source: getNextAccount(),
      owner: getNextAccount()
    },
    data: getRevokeInstructionDataDecoder().decode(instruction.data)
  };
}
var SET_AUTHORITY_DISCRIMINATOR = 6;
function getSetAuthorityDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(SET_AUTHORITY_DISCRIMINATOR);
}
function getSetAuthorityInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["authorityType", getAuthorityTypeEncoder()],
      ["newAuthority", web3_js.getOptionEncoder(web3_js.getAddressEncoder())]
    ]),
    (value) => ({ ...value, discriminator: SET_AUTHORITY_DISCRIMINATOR })
  );
}
function getSetAuthorityInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["authorityType", getAuthorityTypeDecoder()],
    ["newAuthority", web3_js.getOptionDecoder(web3_js.getAddressDecoder())]
  ]);
}
function getSetAuthorityInstructionDataCodec() {
  return web3_js.combineCodec(
    getSetAuthorityInstructionDataEncoder(),
    getSetAuthorityInstructionDataDecoder()
  );
}
function getSetAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    owned: { value: input.owned ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.owned),
      getAccountMeta(accounts.owner),
      ...remainingAccounts
    ],
    programAddress,
    data: getSetAuthorityInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      owned: getNextAccount(),
      owner: getNextAccount()
    },
    data: getSetAuthorityInstructionDataDecoder().decode(instruction.data)
  };
}
var SET_TRANSFER_FEE_DISCRIMINATOR = 26;
function getSetTransferFeeDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(SET_TRANSFER_FEE_DISCRIMINATOR);
}
var SET_TRANSFER_FEE_TRANSFER_FEE_DISCRIMINATOR = 5;
function getSetTransferFeeTransferFeeDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(SET_TRANSFER_FEE_TRANSFER_FEE_DISCRIMINATOR);
}
function getSetTransferFeeInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["transferFeeDiscriminator", web3_js.getU8Encoder()],
      ["transferFeeBasisPoints", web3_js.getU16Encoder()],
      ["maximumFee", web3_js.getU64Encoder()]
    ]),
    (value) => ({
      ...value,
      discriminator: SET_TRANSFER_FEE_DISCRIMINATOR,
      transferFeeDiscriminator: SET_TRANSFER_FEE_TRANSFER_FEE_DISCRIMINATOR
    })
  );
}
function getSetTransferFeeInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["transferFeeDiscriminator", web3_js.getU8Decoder()],
    ["transferFeeBasisPoints", web3_js.getU16Decoder()],
    ["maximumFee", web3_js.getU64Decoder()]
  ]);
}
function getSetTransferFeeInstructionDataCodec() {
  return web3_js.combineCodec(
    getSetTransferFeeInstructionDataEncoder(),
    getSetTransferFeeInstructionDataDecoder()
  );
}
function getSetTransferFeeInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    mint: { value: input.mint ?? null, isWritable: true },
    transferFeeConfigAuthority: {
      value: input.transferFeeConfigAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.transferFeeConfigAuthority),
      ...remainingAccounts
    ],
    programAddress,
    data: getSetTransferFeeInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseSetTransferFeeInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      mint: getNextAccount(),
      transferFeeConfigAuthority: getNextAccount()
    },
    data: getSetTransferFeeInstructionDataDecoder().decode(instruction.data)
  };
}
var SYNC_NATIVE_DISCRIMINATOR = 17;
function getSyncNativeDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(SYNC_NATIVE_DISCRIMINATOR);
}
function getSyncNativeInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([["discriminator", web3_js.getU8Encoder()]]),
    (value) => ({ ...value, discriminator: SYNC_NATIVE_DISCRIMINATOR })
  );
}
function getSyncNativeInstructionDataDecoder() {
  return web3_js.getStructDecoder([["discriminator", web3_js.getU8Decoder()]]);
}
function getSyncNativeInstructionDataCodec() {
  return web3_js.combineCodec(
    getSyncNativeInstructionDataEncoder(),
    getSyncNativeInstructionDataDecoder()
  );
}
function getSyncNativeInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    account: { value: input.account ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [getAccountMeta(accounts.account)],
    programAddress,
    data: getSyncNativeInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseSyncNativeInstruction(instruction) {
  if (instruction.accounts.length < 1) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      account: getNextAccount()
    },
    data: getSyncNativeInstructionDataDecoder().decode(instruction.data)
  };
}
var THAW_ACCOUNT_DISCRIMINATOR = 11;
function getThawAccountDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(THAW_ACCOUNT_DISCRIMINATOR);
}
function getThawAccountInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([["discriminator", web3_js.getU8Encoder()]]),
    (value) => ({ ...value, discriminator: THAW_ACCOUNT_DISCRIMINATOR })
  );
}
function getThawAccountInstructionDataDecoder() {
  return web3_js.getStructDecoder([["discriminator", web3_js.getU8Decoder()]]);
}
function getThawAccountInstructionDataCodec() {
  return web3_js.combineCodec(
    getThawAccountInstructionDataEncoder(),
    getThawAccountInstructionDataDecoder()
  );
}
function getThawAccountInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    account: { value: input.account ?? null, isWritable: true },
    mint: { value: input.mint ?? null, isWritable: false },
    owner: { value: input.owner ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.account),
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.owner),
      ...remainingAccounts
    ],
    programAddress,
    data: getThawAccountInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseThawAccountInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      account: getNextAccount(),
      mint: getNextAccount(),
      owner: getNextAccount()
    },
    data: getThawAccountInstructionDataDecoder().decode(instruction.data)
  };
}
var TRANSFER_DISCRIMINATOR = 3;
function getTransferDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(TRANSFER_DISCRIMINATOR);
}
function getTransferInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["amount", web3_js.getU64Encoder()]
    ]),
    (value) => ({ ...value, discriminator: TRANSFER_DISCRIMINATOR })
  );
}
function getTransferInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["amount", web3_js.getU64Decoder()]
  ]);
}
function getTransferInstructionDataCodec() {
  return web3_js.combineCodec(
    getTransferInstructionDataEncoder(),
    getTransferInstructionDataDecoder()
  );
}
function getTransferInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    source: { value: input.source ?? null, isWritable: true },
    destination: { value: input.destination ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.source),
      getAccountMeta(accounts.destination),
      getAccountMeta(accounts.authority),
      ...remainingAccounts
    ],
    programAddress,
    data: getTransferInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseTransferInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      source: getNextAccount(),
      destination: getNextAccount(),
      authority: getNextAccount()
    },
    data: getTransferInstructionDataDecoder().decode(instruction.data)
  };
}
var TRANSFER_CHECKED_DISCRIMINATOR = 12;
function getTransferCheckedDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(TRANSFER_CHECKED_DISCRIMINATOR);
}
function getTransferCheckedInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["amount", web3_js.getU64Encoder()],
      ["decimals", web3_js.getU8Encoder()]
    ]),
    (value) => ({ ...value, discriminator: TRANSFER_CHECKED_DISCRIMINATOR })
  );
}
function getTransferCheckedInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["amount", web3_js.getU64Decoder()],
    ["decimals", web3_js.getU8Decoder()]
  ]);
}
function getTransferCheckedInstructionDataCodec() {
  return web3_js.combineCodec(
    getTransferCheckedInstructionDataEncoder(),
    getTransferCheckedInstructionDataDecoder()
  );
}
function getTransferCheckedInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    source: { value: input.source ?? null, isWritable: true },
    mint: { value: input.mint ?? null, isWritable: false },
    destination: { value: input.destination ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.source),
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.destination),
      getAccountMeta(accounts.authority),
      ...remainingAccounts
    ],
    programAddress,
    data: getTransferCheckedInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseTransferCheckedInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      source: getNextAccount(),
      mint: getNextAccount(),
      destination: getNextAccount(),
      authority: getNextAccount()
    },
    data: getTransferCheckedInstructionDataDecoder().decode(instruction.data)
  };
}
var TRANSFER_CHECKED_WITH_FEE_DISCRIMINATOR = 26;
function getTransferCheckedWithFeeDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(TRANSFER_CHECKED_WITH_FEE_DISCRIMINATOR);
}
var TRANSFER_CHECKED_WITH_FEE_TRANSFER_FEE_DISCRIMINATOR = 1;
function getTransferCheckedWithFeeTransferFeeDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    TRANSFER_CHECKED_WITH_FEE_TRANSFER_FEE_DISCRIMINATOR
  );
}
function getTransferCheckedWithFeeInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["transferFeeDiscriminator", web3_js.getU8Encoder()],
      ["amount", web3_js.getU64Encoder()],
      ["decimals", web3_js.getU8Encoder()],
      ["fee", web3_js.getU64Encoder()]
    ]),
    (value) => ({
      ...value,
      discriminator: TRANSFER_CHECKED_WITH_FEE_DISCRIMINATOR,
      transferFeeDiscriminator: TRANSFER_CHECKED_WITH_FEE_TRANSFER_FEE_DISCRIMINATOR
    })
  );
}
function getTransferCheckedWithFeeInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["transferFeeDiscriminator", web3_js.getU8Decoder()],
    ["amount", web3_js.getU64Decoder()],
    ["decimals", web3_js.getU8Decoder()],
    ["fee", web3_js.getU64Decoder()]
  ]);
}
function getTransferCheckedWithFeeInstructionDataCodec() {
  return web3_js.combineCodec(
    getTransferCheckedWithFeeInstructionDataEncoder(),
    getTransferCheckedWithFeeInstructionDataDecoder()
  );
}
function getTransferCheckedWithFeeInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    source: { value: input.source ?? null, isWritable: true },
    mint: { value: input.mint ?? null, isWritable: false },
    destination: { value: input.destination ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.source),
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.destination),
      getAccountMeta(accounts.authority),
      ...remainingAccounts
    ],
    programAddress,
    data: getTransferCheckedWithFeeInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseTransferCheckedWithFeeInstruction(instruction) {
  if (instruction.accounts.length < 4) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      source: getNextAccount(),
      mint: getNextAccount(),
      destination: getNextAccount(),
      authority: getNextAccount()
    },
    data: getTransferCheckedWithFeeInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var UI_AMOUNT_TO_AMOUNT_DISCRIMINATOR = 24;
function getUiAmountToAmountDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(UI_AMOUNT_TO_AMOUNT_DISCRIMINATOR);
}
function getUiAmountToAmountInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["uiAmount", web3_js.getUtf8Encoder()]
    ]),
    (value) => ({ ...value, discriminator: UI_AMOUNT_TO_AMOUNT_DISCRIMINATOR })
  );
}
function getUiAmountToAmountInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["uiAmount", web3_js.getUtf8Decoder()]
  ]);
}
function getUiAmountToAmountInstructionDataCodec() {
  return web3_js.combineCodec(
    getUiAmountToAmountInstructionDataEncoder(),
    getUiAmountToAmountInstructionDataDecoder()
  );
}
function getUiAmountToAmountInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    mint: { value: input.mint ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [getAccountMeta(accounts.mint)],
    programAddress,
    data: getUiAmountToAmountInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseUiAmountToAmountInstruction(instruction) {
  if (instruction.accounts.length < 1) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      mint: getNextAccount()
    },
    data: getUiAmountToAmountInstructionDataDecoder().decode(instruction.data)
  };
}
var UPDATE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR = 27;
function getUpdateConfidentialTransferMintDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(UPDATE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR);
}
var UPDATE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 1;
function getUpdateConfidentialTransferMintConfidentialTransferDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    UPDATE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR
  );
}
function getUpdateConfidentialTransferMintInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["confidentialTransferDiscriminator", web3_js.getU8Encoder()],
      ["autoApproveNewAccounts", web3_js.getBooleanEncoder()],
      [
        "auditorElgamalPubkey",
        web3_js.getOptionEncoder(web3_js.getAddressEncoder(), {
          prefix: null,
          noneValue: "zeroes"
        })
      ]
    ]),
    (value) => ({
      ...value,
      discriminator: UPDATE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR,
      confidentialTransferDiscriminator: UPDATE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR
    })
  );
}
function getUpdateConfidentialTransferMintInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["confidentialTransferDiscriminator", web3_js.getU8Decoder()],
    ["autoApproveNewAccounts", web3_js.getBooleanDecoder()],
    [
      "auditorElgamalPubkey",
      web3_js.getOptionDecoder(web3_js.getAddressDecoder(), {
        prefix: null,
        noneValue: "zeroes"
      })
    ]
  ]);
}
function getUpdateConfidentialTransferMintInstructionDataCodec() {
  return web3_js.combineCodec(
    getUpdateConfidentialTransferMintInstructionDataEncoder(),
    getUpdateConfidentialTransferMintInstructionDataDecoder()
  );
}
function getUpdateConfidentialTransferMintInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    mint: { value: input.mint ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.authority)
    ],
    programAddress,
    data: getUpdateConfidentialTransferMintInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseUpdateConfidentialTransferMintInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      mint: getNextAccount(),
      authority: getNextAccount()
    },
    data: getUpdateConfidentialTransferMintInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var UPDATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR = 28;
function getUpdateDefaultAccountStateDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(UPDATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR);
}
var UPDATE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR = 1;
function getUpdateDefaultAccountStateDefaultAccountStateDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    UPDATE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR
  );
}
function getUpdateDefaultAccountStateInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["defaultAccountStateDiscriminator", web3_js.getU8Encoder()],
      ["state", getAccountStateEncoder()]
    ]),
    (value) => ({
      ...value,
      discriminator: UPDATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR,
      defaultAccountStateDiscriminator: UPDATE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR
    })
  );
}
function getUpdateDefaultAccountStateInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["defaultAccountStateDiscriminator", web3_js.getU8Decoder()],
    ["state", getAccountStateDecoder()]
  ]);
}
function getUpdateDefaultAccountStateInstructionDataCodec() {
  return web3_js.combineCodec(
    getUpdateDefaultAccountStateInstructionDataEncoder(),
    getUpdateDefaultAccountStateInstructionDataDecoder()
  );
}
function getUpdateDefaultAccountStateInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    mint: { value: input.mint ?? null, isWritable: true },
    freezeAuthority: {
      value: input.freezeAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.freezeAuthority),
      ...remainingAccounts
    ],
    programAddress,
    data: getUpdateDefaultAccountStateInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseUpdateDefaultAccountStateInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      mint: getNextAccount(),
      freezeAuthority: getNextAccount()
    },
    data: getUpdateDefaultAccountStateInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var UPDATE_GROUP_MEMBER_POINTER_DISCRIMINATOR = 41;
function getUpdateGroupMemberPointerDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(UPDATE_GROUP_MEMBER_POINTER_DISCRIMINATOR);
}
var UPDATE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR = 1;
function getUpdateGroupMemberPointerGroupMemberPointerDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    UPDATE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR
  );
}
function getUpdateGroupMemberPointerInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["groupMemberPointerDiscriminator", web3_js.getU8Encoder()],
      [
        "memberAddress",
        web3_js.getOptionEncoder(web3_js.getAddressEncoder(), {
          prefix: null,
          noneValue: "zeroes"
        })
      ]
    ]),
    (value) => ({
      ...value,
      discriminator: UPDATE_GROUP_MEMBER_POINTER_DISCRIMINATOR,
      groupMemberPointerDiscriminator: UPDATE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR
    })
  );
}
function getUpdateGroupMemberPointerInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["groupMemberPointerDiscriminator", web3_js.getU8Decoder()],
    [
      "memberAddress",
      web3_js.getOptionDecoder(web3_js.getAddressDecoder(), {
        prefix: null,
        noneValue: "zeroes"
      })
    ]
  ]);
}
function getUpdateGroupMemberPointerInstructionDataCodec() {
  return web3_js.combineCodec(
    getUpdateGroupMemberPointerInstructionDataEncoder(),
    getUpdateGroupMemberPointerInstructionDataDecoder()
  );
}
function getUpdateGroupMemberPointerInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    mint: { value: input.mint ?? null, isWritable: true },
    groupMemberPointerAuthority: {
      value: input.groupMemberPointerAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.groupMemberPointerAuthority),
      ...remainingAccounts
    ],
    programAddress,
    data: getUpdateGroupMemberPointerInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseUpdateGroupMemberPointerInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      mint: getNextAccount(),
      groupMemberPointerAuthority: getNextAccount()
    },
    data: getUpdateGroupMemberPointerInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var UPDATE_GROUP_POINTER_DISCRIMINATOR = 40;
function getUpdateGroupPointerDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(UPDATE_GROUP_POINTER_DISCRIMINATOR);
}
var UPDATE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR = 1;
function getUpdateGroupPointerGroupPointerDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    UPDATE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR
  );
}
function getUpdateGroupPointerInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["groupPointerDiscriminator", web3_js.getU8Encoder()],
      [
        "groupAddress",
        web3_js.getOptionEncoder(web3_js.getAddressEncoder(), {
          prefix: null,
          noneValue: "zeroes"
        })
      ]
    ]),
    (value) => ({
      ...value,
      discriminator: UPDATE_GROUP_POINTER_DISCRIMINATOR,
      groupPointerDiscriminator: UPDATE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR
    })
  );
}
function getUpdateGroupPointerInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["groupPointerDiscriminator", web3_js.getU8Decoder()],
    [
      "groupAddress",
      web3_js.getOptionDecoder(web3_js.getAddressDecoder(), {
        prefix: null,
        noneValue: "zeroes"
      })
    ]
  ]);
}
function getUpdateGroupPointerInstructionDataCodec() {
  return web3_js.combineCodec(
    getUpdateGroupPointerInstructionDataEncoder(),
    getUpdateGroupPointerInstructionDataDecoder()
  );
}
function getUpdateGroupPointerInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    mint: { value: input.mint ?? null, isWritable: true },
    groupPointerAuthority: {
      value: input.groupPointerAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.groupPointerAuthority),
      ...remainingAccounts
    ],
    programAddress,
    data: getUpdateGroupPointerInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseUpdateGroupPointerInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      mint: getNextAccount(),
      groupPointerAuthority: getNextAccount()
    },
    data: getUpdateGroupPointerInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var UPDATE_METADATA_POINTER_DISCRIMINATOR = 39;
function getUpdateMetadataPointerDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(UPDATE_METADATA_POINTER_DISCRIMINATOR);
}
var UPDATE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR = 1;
function getUpdateMetadataPointerMetadataPointerDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    UPDATE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR
  );
}
function getUpdateMetadataPointerInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["metadataPointerDiscriminator", web3_js.getU8Encoder()],
      [
        "metadataAddress",
        web3_js.getOptionEncoder(web3_js.getAddressEncoder(), {
          prefix: null,
          noneValue: "zeroes"
        })
      ]
    ]),
    (value) => ({
      ...value,
      discriminator: UPDATE_METADATA_POINTER_DISCRIMINATOR,
      metadataPointerDiscriminator: UPDATE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR
    })
  );
}
function getUpdateMetadataPointerInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["metadataPointerDiscriminator", web3_js.getU8Decoder()],
    [
      "metadataAddress",
      web3_js.getOptionDecoder(web3_js.getAddressDecoder(), {
        prefix: null,
        noneValue: "zeroes"
      })
    ]
  ]);
}
function getUpdateMetadataPointerInstructionDataCodec() {
  return web3_js.combineCodec(
    getUpdateMetadataPointerInstructionDataEncoder(),
    getUpdateMetadataPointerInstructionDataDecoder()
  );
}
function getUpdateMetadataPointerInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    mint: { value: input.mint ?? null, isWritable: true },
    metadataPointerAuthority: {
      value: input.metadataPointerAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.metadataPointerAuthority),
      ...remainingAccounts
    ],
    programAddress,
    data: getUpdateMetadataPointerInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseUpdateMetadataPointerInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      mint: getNextAccount(),
      metadataPointerAuthority: getNextAccount()
    },
    data: getUpdateMetadataPointerInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var UPDATE_RATE_INTEREST_BEARING_MINT_DISCRIMINATOR = 33;
function getUpdateRateInterestBearingMintDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(UPDATE_RATE_INTEREST_BEARING_MINT_DISCRIMINATOR);
}
var UPDATE_RATE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR = 1;
function getUpdateRateInterestBearingMintInterestBearingMintDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    UPDATE_RATE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR
  );
}
function getUpdateRateInterestBearingMintInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["interestBearingMintDiscriminator", web3_js.getU8Encoder()],
      ["rate", web3_js.getI16Encoder()]
    ]),
    (value) => ({
      ...value,
      discriminator: UPDATE_RATE_INTEREST_BEARING_MINT_DISCRIMINATOR,
      interestBearingMintDiscriminator: UPDATE_RATE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR
    })
  );
}
function getUpdateRateInterestBearingMintInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["interestBearingMintDiscriminator", web3_js.getU8Decoder()],
    ["rate", web3_js.getI16Decoder()]
  ]);
}
function getUpdateRateInterestBearingMintInstructionDataCodec() {
  return web3_js.combineCodec(
    getUpdateRateInterestBearingMintInstructionDataEncoder(),
    getUpdateRateInterestBearingMintInstructionDataDecoder()
  );
}
function getUpdateRateInterestBearingMintInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    mint: { value: input.mint ?? null, isWritable: true },
    rateAuthority: { value: input.rateAuthority ?? null, isWritable: true }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.rateAuthority),
      ...remainingAccounts
    ],
    programAddress,
    data: getUpdateRateInterestBearingMintInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseUpdateRateInterestBearingMintInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      mint: getNextAccount(),
      rateAuthority: getNextAccount()
    },
    data: getUpdateRateInterestBearingMintInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var UPDATE_TOKEN_GROUP_MAX_SIZE_DISCRIMINATOR = new Uint8Array([
  108,
  37,
  171,
  143,
  248,
  30,
  18,
  110
]);
function getUpdateTokenGroupMaxSizeDiscriminatorBytes() {
  return web3_js.getBytesEncoder().encode(UPDATE_TOKEN_GROUP_MAX_SIZE_DISCRIMINATOR);
}
function getUpdateTokenGroupMaxSizeInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getBytesEncoder()],
      ["maxSize", web3_js.getU64Encoder()]
    ]),
    (value) => ({
      ...value,
      discriminator: UPDATE_TOKEN_GROUP_MAX_SIZE_DISCRIMINATOR
    })
  );
}
function getUpdateTokenGroupMaxSizeInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getBytesDecoder()],
    ["maxSize", web3_js.getU64Decoder()]
  ]);
}
function getUpdateTokenGroupMaxSizeInstructionDataCodec() {
  return web3_js.combineCodec(
    getUpdateTokenGroupMaxSizeInstructionDataEncoder(),
    getUpdateTokenGroupMaxSizeInstructionDataDecoder()
  );
}
function getUpdateTokenGroupMaxSizeInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    group: { value: input.group ?? null, isWritable: true },
    updateAuthority: {
      value: input.updateAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.group),
      getAccountMeta(accounts.updateAuthority)
    ],
    programAddress,
    data: getUpdateTokenGroupMaxSizeInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseUpdateTokenGroupMaxSizeInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      group: getNextAccount(),
      updateAuthority: getNextAccount()
    },
    data: getUpdateTokenGroupMaxSizeInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var UPDATE_TOKEN_GROUP_UPDATE_AUTHORITY_DISCRIMINATOR = new Uint8Array(
  [161, 105, 88, 1, 237, 221, 216, 203]
);
function getUpdateTokenGroupUpdateAuthorityDiscriminatorBytes() {
  return web3_js.getBytesEncoder().encode(
    UPDATE_TOKEN_GROUP_UPDATE_AUTHORITY_DISCRIMINATOR
  );
}
function getUpdateTokenGroupUpdateAuthorityInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getBytesEncoder()],
      [
        "newUpdateAuthority",
        web3_js.getOptionEncoder(web3_js.getAddressEncoder(), {
          prefix: null,
          noneValue: "zeroes"
        })
      ]
    ]),
    (value) => ({
      ...value,
      discriminator: UPDATE_TOKEN_GROUP_UPDATE_AUTHORITY_DISCRIMINATOR
    })
  );
}
function getUpdateTokenGroupUpdateAuthorityInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getBytesDecoder()],
    [
      "newUpdateAuthority",
      web3_js.getOptionDecoder(web3_js.getAddressDecoder(), {
        prefix: null,
        noneValue: "zeroes"
      })
    ]
  ]);
}
function getUpdateTokenGroupUpdateAuthorityInstructionDataCodec() {
  return web3_js.combineCodec(
    getUpdateTokenGroupUpdateAuthorityInstructionDataEncoder(),
    getUpdateTokenGroupUpdateAuthorityInstructionDataDecoder()
  );
}
function getUpdateTokenGroupUpdateAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    group: { value: input.group ?? null, isWritable: true },
    updateAuthority: {
      value: input.updateAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.group),
      getAccountMeta(accounts.updateAuthority)
    ],
    programAddress,
    data: getUpdateTokenGroupUpdateAuthorityInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseUpdateTokenGroupUpdateAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      group: getNextAccount(),
      updateAuthority: getNextAccount()
    },
    data: getUpdateTokenGroupUpdateAuthorityInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var UPDATE_TOKEN_METADATA_FIELD_DISCRIMINATOR = new Uint8Array([
  221,
  233,
  49,
  45,
  181,
  202,
  220,
  200
]);
function getUpdateTokenMetadataFieldDiscriminatorBytes() {
  return web3_js.getBytesEncoder().encode(UPDATE_TOKEN_METADATA_FIELD_DISCRIMINATOR);
}
function getUpdateTokenMetadataFieldInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getBytesEncoder()],
      ["field", getTokenMetadataFieldEncoder()],
      ["value", web3_js.addEncoderSizePrefix(web3_js.getUtf8Encoder(), web3_js.getU32Encoder())]
    ]),
    (value) => ({
      ...value,
      discriminator: UPDATE_TOKEN_METADATA_FIELD_DISCRIMINATOR
    })
  );
}
function getUpdateTokenMetadataFieldInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getBytesDecoder()],
    ["field", getTokenMetadataFieldDecoder()],
    ["value", web3_js.addDecoderSizePrefix(web3_js.getUtf8Decoder(), web3_js.getU32Decoder())]
  ]);
}
function getUpdateTokenMetadataFieldInstructionDataCodec() {
  return web3_js.combineCodec(
    getUpdateTokenMetadataFieldInstructionDataEncoder(),
    getUpdateTokenMetadataFieldInstructionDataDecoder()
  );
}
function getUpdateTokenMetadataFieldInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    metadata: { value: input.metadata ?? null, isWritable: true },
    updateAuthority: {
      value: input.updateAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.metadata),
      getAccountMeta(accounts.updateAuthority)
    ],
    programAddress,
    data: getUpdateTokenMetadataFieldInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseUpdateTokenMetadataFieldInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      metadata: getNextAccount(),
      updateAuthority: getNextAccount()
    },
    data: getUpdateTokenMetadataFieldInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var UPDATE_TOKEN_METADATA_UPDATE_AUTHORITY_DISCRIMINATOR = new Uint8Array([215, 228, 166, 228, 84, 100, 86, 123]);
function getUpdateTokenMetadataUpdateAuthorityDiscriminatorBytes() {
  return web3_js.getBytesEncoder().encode(
    UPDATE_TOKEN_METADATA_UPDATE_AUTHORITY_DISCRIMINATOR
  );
}
function getUpdateTokenMetadataUpdateAuthorityInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getBytesEncoder()],
      [
        "newUpdateAuthority",
        web3_js.getOptionEncoder(web3_js.getAddressEncoder(), {
          prefix: null,
          noneValue: "zeroes"
        })
      ]
    ]),
    (value) => ({
      ...value,
      discriminator: UPDATE_TOKEN_METADATA_UPDATE_AUTHORITY_DISCRIMINATOR
    })
  );
}
function getUpdateTokenMetadataUpdateAuthorityInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getBytesDecoder()],
    [
      "newUpdateAuthority",
      web3_js.getOptionDecoder(web3_js.getAddressDecoder(), {
        prefix: null,
        noneValue: "zeroes"
      })
    ]
  ]);
}
function getUpdateTokenMetadataUpdateAuthorityInstructionDataCodec() {
  return web3_js.combineCodec(
    getUpdateTokenMetadataUpdateAuthorityInstructionDataEncoder(),
    getUpdateTokenMetadataUpdateAuthorityInstructionDataDecoder()
  );
}
function getUpdateTokenMetadataUpdateAuthorityInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    metadata: { value: input.metadata ?? null, isWritable: true },
    updateAuthority: {
      value: input.updateAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.metadata),
      getAccountMeta(accounts.updateAuthority)
    ],
    programAddress,
    data: getUpdateTokenMetadataUpdateAuthorityInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseUpdateTokenMetadataUpdateAuthorityInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      metadata: getNextAccount(),
      updateAuthority: getNextAccount()
    },
    data: getUpdateTokenMetadataUpdateAuthorityInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var UPDATE_TRANSFER_HOOK_DISCRIMINATOR = 36;
function getUpdateTransferHookDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(UPDATE_TRANSFER_HOOK_DISCRIMINATOR);
}
var UPDATE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR = 1;
function getUpdateTransferHookTransferHookDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    UPDATE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR
  );
}
function getUpdateTransferHookInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["transferHookDiscriminator", web3_js.getU8Encoder()],
      [
        "programId",
        web3_js.getOptionEncoder(web3_js.getAddressEncoder(), {
          prefix: null,
          noneValue: "zeroes"
        })
      ]
    ]),
    (value) => ({
      ...value,
      discriminator: UPDATE_TRANSFER_HOOK_DISCRIMINATOR,
      transferHookDiscriminator: UPDATE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR
    })
  );
}
function getUpdateTransferHookInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["transferHookDiscriminator", web3_js.getU8Decoder()],
    [
      "programId",
      web3_js.getOptionDecoder(web3_js.getAddressDecoder(), {
        prefix: null,
        noneValue: "zeroes"
      })
    ]
  ]);
}
function getUpdateTransferHookInstructionDataCodec() {
  return web3_js.combineCodec(
    getUpdateTransferHookInstructionDataEncoder(),
    getUpdateTransferHookInstructionDataDecoder()
  );
}
function getUpdateTransferHookInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    mint: { value: input.mint ?? null, isWritable: true },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.authority),
      ...remainingAccounts
    ],
    programAddress,
    data: getUpdateTransferHookInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseUpdateTransferHookInstruction(instruction) {
  if (instruction.accounts.length < 2) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      mint: getNextAccount(),
      authority: getNextAccount()
    },
    data: getUpdateTransferHookInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var WITHDRAW_EXCESS_LAMPORTS_DISCRIMINATOR = 38;
function getWithdrawExcessLamportsDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(WITHDRAW_EXCESS_LAMPORTS_DISCRIMINATOR);
}
function getWithdrawExcessLamportsInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([["discriminator", web3_js.getU8Encoder()]]),
    (value) => ({
      ...value,
      discriminator: WITHDRAW_EXCESS_LAMPORTS_DISCRIMINATOR
    })
  );
}
function getWithdrawExcessLamportsInstructionDataDecoder() {
  return web3_js.getStructDecoder([["discriminator", web3_js.getU8Decoder()]]);
}
function getWithdrawExcessLamportsInstructionDataCodec() {
  return web3_js.combineCodec(
    getWithdrawExcessLamportsInstructionDataEncoder(),
    getWithdrawExcessLamportsInstructionDataDecoder()
  );
}
function getWithdrawExcessLamportsInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    sourceAccount: { value: input.sourceAccount ?? null, isWritable: true },
    destinationAccount: {
      value: input.destinationAccount ?? null,
      isWritable: true
    },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.sourceAccount),
      getAccountMeta(accounts.destinationAccount),
      getAccountMeta(accounts.authority),
      ...remainingAccounts
    ],
    programAddress,
    data: getWithdrawExcessLamportsInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseWithdrawExcessLamportsInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      sourceAccount: getNextAccount(),
      destinationAccount: getNextAccount(),
      authority: getNextAccount()
    },
    data: getWithdrawExcessLamportsInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_DISCRIMINATOR = 26;
function getWithdrawWithheldTokensFromAccountsDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_DISCRIMINATOR
  );
}
var WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_TRANSFER_FEE_DISCRIMINATOR = 3;
function getWithdrawWithheldTokensFromAccountsTransferFeeDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_TRANSFER_FEE_DISCRIMINATOR
  );
}
function getWithdrawWithheldTokensFromAccountsInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["transferFeeDiscriminator", web3_js.getU8Encoder()],
      ["numTokenAccounts", web3_js.getU8Encoder()]
    ]),
    (value) => ({
      ...value,
      discriminator: WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_DISCRIMINATOR,
      transferFeeDiscriminator: WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_TRANSFER_FEE_DISCRIMINATOR
    })
  );
}
function getWithdrawWithheldTokensFromAccountsInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["transferFeeDiscriminator", web3_js.getU8Decoder()],
    ["numTokenAccounts", web3_js.getU8Decoder()]
  ]);
}
function getWithdrawWithheldTokensFromAccountsInstructionDataCodec() {
  return web3_js.combineCodec(
    getWithdrawWithheldTokensFromAccountsInstructionDataEncoder(),
    getWithdrawWithheldTokensFromAccountsInstructionDataDecoder()
  );
}
function getWithdrawWithheldTokensFromAccountsInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    mint: { value: input.mint ?? null, isWritable: false },
    feeReceiver: { value: input.feeReceiver ?? null, isWritable: true },
    withdrawWithheldAuthority: {
      value: input.withdrawWithheldAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = [
    ...(args.multiSigners ?? []).map((signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })),
    ...args.sources.map((address) => ({ address, role: web3_js.AccountRole.WRITABLE }))
  ];
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.feeReceiver),
      getAccountMeta(accounts.withdrawWithheldAuthority),
      ...remainingAccounts
    ],
    programAddress,
    data: getWithdrawWithheldTokensFromAccountsInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseWithdrawWithheldTokensFromAccountsInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      mint: getNextAccount(),
      feeReceiver: getNextAccount(),
      withdrawWithheldAuthority: getNextAccount()
    },
    data: getWithdrawWithheldTokensFromAccountsInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 37;
function getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR
  );
}
var WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 2;
function getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR
  );
}
function getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["confidentialTransferFeeDiscriminator", web3_js.getU8Encoder()],
      ["numTokenAccounts", web3_js.getU8Encoder()],
      ["proofInstructionOffset", web3_js.getI8Encoder()],
      ["newDecryptableAvailableBalance", getDecryptableBalanceEncoder()]
    ]),
    (value) => ({
      ...value,
      discriminator: WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,
      confidentialTransferFeeDiscriminator: WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR
    })
  );
}
function getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["confidentialTransferFeeDiscriminator", web3_js.getU8Decoder()],
    ["numTokenAccounts", web3_js.getU8Decoder()],
    ["proofInstructionOffset", web3_js.getI8Decoder()],
    ["newDecryptableAvailableBalance", getDecryptableBalanceDecoder()]
  ]);
}
function getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataCodec() {
  return web3_js.combineCodec(
    getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataEncoder(),
    getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataDecoder()
  );
}
function getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    mint: { value: input.mint ?? null, isWritable: false },
    destination: { value: input.destination ?? null, isWritable: true },
    instructionsSysvarOrContextState: {
      value: input.instructionsSysvarOrContextState ?? null,
      isWritable: false
    },
    record: { value: input.record ?? null, isWritable: false },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.destination),
      getAccountMeta(accounts.instructionsSysvarOrContextState),
      getAccountMeta(accounts.record),
      getAccountMeta(accounts.authority),
      ...remainingAccounts
    ],
    programAddress,
    data: getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction(instruction) {
  if (instruction.accounts.length < 5) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  const getNextOptionalAccount = () => {
    const accountMeta = getNextAccount();
    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS ? void 0 : accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      mint: getNextAccount(),
      destination: getNextAccount(),
      instructionsSysvarOrContextState: getNextAccount(),
      record: getNextOptionalAccount(),
      authority: getNextAccount()
    },
    data: getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var WITHDRAW_WITHHELD_TOKENS_FROM_MINT_DISCRIMINATOR = 26;
function getWithdrawWithheldTokensFromMintDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    WITHDRAW_WITHHELD_TOKENS_FROM_MINT_DISCRIMINATOR
  );
}
var WITHDRAW_WITHHELD_TOKENS_FROM_MINT_TRANSFER_FEE_DISCRIMINATOR = 2;
function getWithdrawWithheldTokensFromMintTransferFeeDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    WITHDRAW_WITHHELD_TOKENS_FROM_MINT_TRANSFER_FEE_DISCRIMINATOR
  );
}
function getWithdrawWithheldTokensFromMintInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["transferFeeDiscriminator", web3_js.getU8Encoder()]
    ]),
    (value) => ({
      ...value,
      discriminator: WITHDRAW_WITHHELD_TOKENS_FROM_MINT_DISCRIMINATOR,
      transferFeeDiscriminator: WITHDRAW_WITHHELD_TOKENS_FROM_MINT_TRANSFER_FEE_DISCRIMINATOR
    })
  );
}
function getWithdrawWithheldTokensFromMintInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["transferFeeDiscriminator", web3_js.getU8Decoder()]
  ]);
}
function getWithdrawWithheldTokensFromMintInstructionDataCodec() {
  return web3_js.combineCodec(
    getWithdrawWithheldTokensFromMintInstructionDataEncoder(),
    getWithdrawWithheldTokensFromMintInstructionDataDecoder()
  );
}
function getWithdrawWithheldTokensFromMintInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    mint: { value: input.mint ?? null, isWritable: true },
    feeReceiver: { value: input.feeReceiver ?? null, isWritable: true },
    withdrawWithheldAuthority: {
      value: input.withdrawWithheldAuthority ?? null,
      isWritable: false
    }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.feeReceiver),
      getAccountMeta(accounts.withdrawWithheldAuthority),
      ...remainingAccounts
    ],
    programAddress,
    data: getWithdrawWithheldTokensFromMintInstructionDataEncoder().encode({})
  };
  return instruction;
}
function parseWithdrawWithheldTokensFromMintInstruction(instruction) {
  if (instruction.accounts.length < 3) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      mint: getNextAccount(),
      feeReceiver: getNextAccount(),
      withdrawWithheldAuthority: getNextAccount()
    },
    data: getWithdrawWithheldTokensFromMintInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
var WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 37;
function getWithdrawWithheldTokensFromMintForConfidentialTransferFeeDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR
  );
}
var WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 1;
function getWithdrawWithheldTokensFromMintForConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes() {
  return web3_js.getU8Encoder().encode(
    WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR
  );
}
function getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataEncoder() {
  return web3_js.transformEncoder(
    web3_js.getStructEncoder([
      ["discriminator", web3_js.getU8Encoder()],
      ["confidentialTransferFeeDiscriminator", web3_js.getU8Encoder()],
      ["proofInstructionOffset", web3_js.getI8Encoder()],
      ["newDecryptableAvailableBalance", getDecryptableBalanceEncoder()]
    ]),
    (value) => ({
      ...value,
      discriminator: WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,
      confidentialTransferFeeDiscriminator: WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR
    })
  );
}
function getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataDecoder() {
  return web3_js.getStructDecoder([
    ["discriminator", web3_js.getU8Decoder()],
    ["confidentialTransferFeeDiscriminator", web3_js.getU8Decoder()],
    ["proofInstructionOffset", web3_js.getI8Decoder()],
    ["newDecryptableAvailableBalance", getDecryptableBalanceDecoder()]
  ]);
}
function getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataCodec() {
  return web3_js.combineCodec(
    getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataEncoder(),
    getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataDecoder()
  );
}
function getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction(input, config) {
  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;
  const originalAccounts = {
    mint: { value: input.mint ?? null, isWritable: true },
    destination: { value: input.destination ?? null, isWritable: true },
    instructionsSysvarOrContextState: {
      value: input.instructionsSysvarOrContextState ?? null,
      isWritable: false
    },
    record: { value: input.record ?? null, isWritable: false },
    authority: { value: input.authority ?? null, isWritable: false }
  };
  const accounts = originalAccounts;
  const args = { ...input };
  const remainingAccounts = (args.multiSigners ?? []).map(
    (signer) => ({
      address: signer.address,
      role: web3_js.AccountRole.READONLY_SIGNER,
      signer
    })
  );
  const getAccountMeta = getAccountMetaFactory(programAddress);
  const instruction = {
    accounts: [
      getAccountMeta(accounts.mint),
      getAccountMeta(accounts.destination),
      getAccountMeta(accounts.instructionsSysvarOrContextState),
      getAccountMeta(accounts.record),
      getAccountMeta(accounts.authority),
      ...remainingAccounts
    ],
    programAddress,
    data: getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataEncoder().encode(
      args
    )
  };
  return instruction;
}
function parseWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction(instruction) {
  if (instruction.accounts.length < 5) {
    throw new Error("Not enough accounts");
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts[accountIndex];
    accountIndex += 1;
    return accountMeta;
  };
  const getNextOptionalAccount = () => {
    const accountMeta = getNextAccount();
    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS ? void 0 : accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      mint: getNextAccount(),
      destination: getNextAccount(),
      instructionsSysvarOrContextState: getNextAccount(),
      record: getNextOptionalAccount(),
      authority: getNextAccount()
    },
    data: getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataDecoder().decode(
      instruction.data
    )
  };
}
function getPreInitializeInstructionsForMintExtensions(mint, extensions) {
  return extensions.flatMap((extension2) => {
    switch (extension2.__kind) {
      case "ConfidentialTransferMint":
        return [
          getInitializeConfidentialTransferMintInstruction({
            mint,
            ...extension2
          })
        ];
      case "DefaultAccountState":
        return [
          getInitializeDefaultAccountStateInstruction({
            mint,
            state: extension2.state
          })
        ];
      case "TransferFeeConfig":
        return [
          getInitializeTransferFeeConfigInstruction({
            mint,
            transferFeeConfigAuthority: extension2.transferFeeConfigAuthority,
            withdrawWithheldAuthority: extension2.withdrawWithheldAuthority,
            transferFeeBasisPoints: extension2.newerTransferFee.transferFeeBasisPoints,
            maximumFee: extension2.newerTransferFee.maximumFee
          })
        ];
      case "MetadataPointer":
        return [
          getInitializeMetadataPointerInstruction({
            mint,
            authority: extension2.authority,
            metadataAddress: extension2.metadataAddress
          })
        ];
      case "InterestBearingConfig":
        return [
          getInitializeInterestBearingMintInstruction({
            mint,
            rateAuthority: extension2.rateAuthority,
            rate: extension2.currentRate
          })
        ];
      case "GroupPointer":
        return [
          getInitializeGroupPointerInstruction({
            mint,
            authority: extension2.authority,
            groupAddress: extension2.groupAddress
          })
        ];
      case "GroupMemberPointer":
        return [
          getInitializeGroupMemberPointerInstruction({
            mint,
            authority: extension2.authority,
            memberAddress: extension2.memberAddress
          })
        ];
      case "NonTransferable":
        return getInitializeNonTransferableMintInstruction({ mint });
      case "TransferHook":
        return [
          getInitializeTransferHookInstruction({
            mint,
            authority: extension2.authority,
            programId: extension2.programId
          })
        ];
      case "PermanentDelegate":
        return getInitializePermanentDelegateInstruction({
          mint,
          delegate: extension2.delegate
        });
      case "ConfidentialTransferFee":
        return [
          getInitializeConfidentialTransferFeeInstruction({
            mint,
            authority: extension2.authority,
            withdrawWithheldAuthorityElGamalPubkey: extension2.elgamalPubkey
          })
        ];
      case "MintCloseAuthority":
        return getInitializeMintCloseAuthorityInstruction({
          closeAuthority: extension2.closeAuthority,
          mint
        });
      default:
        return [];
    }
  });
}
function getPostInitializeInstructionsForMintExtensions(mint, authority, extensions) {
  return extensions.flatMap((extension2) => {
    switch (extension2.__kind) {
      case "TokenMetadata":
        const tokenMetadataUpdateAuthority = web3_js.isOption(extension2.updateAuthority) ? extension2.updateAuthority : web3_js.wrapNullable(extension2.updateAuthority);
        if (web3_js.isNone(tokenMetadataUpdateAuthority)) {
          return [];
        }
        return [
          getInitializeTokenMetadataInstruction({
            metadata: mint,
            updateAuthority: tokenMetadataUpdateAuthority.value,
            mint,
            mintAuthority: authority,
            name: extension2.name,
            symbol: extension2.symbol,
            uri: extension2.uri
          })
        ];
      case "TokenGroup":
        return [
          getInitializeTokenGroupInstruction({
            group: mint,
            updateAuthority: web3_js.isOption(extension2.updateAuthority) ? extension2.updateAuthority : web3_js.wrapNullable(extension2.updateAuthority),
            mint,
            mintAuthority: authority,
            maxSize: extension2.maxSize
          })
        ];
      default:
        return [];
    }
  });
}
function getPostInitializeInstructionsForTokenExtensions(token, owner, extensions, multiSigners) {
  return extensions.flatMap((extension2) => {
    switch (extension2.__kind) {
      case "MemoTransfer":
        return [
          extension2.requireIncomingTransferMemos ? getEnableMemoTransfersInstruction({ owner, token, multiSigners }) : getDisableMemoTransfersInstruction({
            owner,
            token,
            multiSigners
          })
        ];
      case "CpiGuard":
        return [
          extension2.lockCpi ? getEnableCpiGuardInstruction({ owner, token, multiSigners }) : getDisableCpiGuardInstruction({
            owner,
            token,
            multiSigners
          })
        ];
      default:
        return [];
    }
  });
}
var TOKEN_BASE_SIZE = 165;
function getTokenSize(extensions) {
  if (extensions == null) return TOKEN_BASE_SIZE;
  const tvlEncoder = web3_js.getHiddenPrefixEncoder(
    web3_js.getArrayEncoder(getExtensionEncoder(), { size: "remainder" }),
    [web3_js.getConstantEncoder(web3_js.getU8Encoder().encode(2))]
  );
  return TOKEN_BASE_SIZE + tvlEncoder.encode(extensions).length;
}
var MINT_BASE_SIZE = 82;
function getMintSize(extensions) {
  if (extensions == null) return MINT_BASE_SIZE;
  const tvlEncoder = web3_js.getHiddenPrefixEncoder(
    web3_js.getArrayEncoder(getExtensionEncoder(), { size: "remainder" }),
    [web3_js.getConstantEncoder(web3_js.padLeftEncoder(web3_js.getU8Encoder(), 83).encode(1))]
  );
  return MINT_BASE_SIZE + tvlEncoder.encode(extensions).length;
}

exports.AMOUNT_TO_UI_AMOUNT_DISCRIMINATOR = AMOUNT_TO_UI_AMOUNT_DISCRIMINATOR;
exports.APPLY_CONFIDENTIAL_PENDING_BALANCE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = APPLY_CONFIDENTIAL_PENDING_BALANCE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR;
exports.APPLY_CONFIDENTIAL_PENDING_BALANCE_DISCRIMINATOR = APPLY_CONFIDENTIAL_PENDING_BALANCE_DISCRIMINATOR;
exports.APPROVE_CHECKED_DISCRIMINATOR = APPROVE_CHECKED_DISCRIMINATOR;
exports.APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR;
exports.APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR = APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR;
exports.APPROVE_DISCRIMINATOR = APPROVE_DISCRIMINATOR;
exports.ASSOCIATED_TOKEN_ERROR__INVALID_OWNER = ASSOCIATED_TOKEN_ERROR__INVALID_OWNER;
exports.ASSOCIATED_TOKEN_PROGRAM_ADDRESS = ASSOCIATED_TOKEN_PROGRAM_ADDRESS;
exports.AccountState = AccountState;
exports.AssociatedTokenInstruction = AssociatedTokenInstruction;
exports.AuthorityType = AuthorityType;
exports.BURN_CHECKED_DISCRIMINATOR = BURN_CHECKED_DISCRIMINATOR;
exports.BURN_DISCRIMINATOR = BURN_DISCRIMINATOR;
exports.CLOSE_ACCOUNT_DISCRIMINATOR = CLOSE_ACCOUNT_DISCRIMINATOR;
exports.CONFIDENTIAL_DEPOSIT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = CONFIDENTIAL_DEPOSIT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR;
exports.CONFIDENTIAL_DEPOSIT_DISCRIMINATOR = CONFIDENTIAL_DEPOSIT_DISCRIMINATOR;
exports.CONFIDENTIAL_TRANSFER_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = CONFIDENTIAL_TRANSFER_CONFIDENTIAL_TRANSFER_DISCRIMINATOR;
exports.CONFIDENTIAL_TRANSFER_DISCRIMINATOR = CONFIDENTIAL_TRANSFER_DISCRIMINATOR;
exports.CONFIDENTIAL_TRANSFER_WITH_FEE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = CONFIDENTIAL_TRANSFER_WITH_FEE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR;
exports.CONFIDENTIAL_TRANSFER_WITH_FEE_DISCRIMINATOR = CONFIDENTIAL_TRANSFER_WITH_FEE_DISCRIMINATOR;
exports.CONFIDENTIAL_WITHDRAW_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = CONFIDENTIAL_WITHDRAW_CONFIDENTIAL_TRANSFER_DISCRIMINATOR;
exports.CONFIDENTIAL_WITHDRAW_DISCRIMINATOR = CONFIDENTIAL_WITHDRAW_DISCRIMINATOR;
exports.CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR;
exports.CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR = CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR;
exports.CREATE_ASSOCIATED_TOKEN_DISCRIMINATOR = CREATE_ASSOCIATED_TOKEN_DISCRIMINATOR;
exports.CREATE_ASSOCIATED_TOKEN_IDEMPOTENT_DISCRIMINATOR = CREATE_ASSOCIATED_TOKEN_IDEMPOTENT_DISCRIMINATOR;
exports.CREATE_NATIVE_MINT_DISCRIMINATOR = CREATE_NATIVE_MINT_DISCRIMINATOR;
exports.DISABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = DISABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR;
exports.DISABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR = DISABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR;
exports.DISABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR = DISABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR;
exports.DISABLE_CPI_GUARD_DISCRIMINATOR = DISABLE_CPI_GUARD_DISCRIMINATOR;
exports.DISABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = DISABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR;
exports.DISABLE_HARVEST_TO_MINT_DISCRIMINATOR = DISABLE_HARVEST_TO_MINT_DISCRIMINATOR;
exports.DISABLE_MEMO_TRANSFERS_DISCRIMINATOR = DISABLE_MEMO_TRANSFERS_DISCRIMINATOR;
exports.DISABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR = DISABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR;
exports.DISABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = DISABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR;
exports.DISABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR = DISABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR;
exports.EMIT_TOKEN_METADATA_DISCRIMINATOR = EMIT_TOKEN_METADATA_DISCRIMINATOR;
exports.EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR;
exports.EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR = EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR;
exports.ENABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = ENABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR;
exports.ENABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR = ENABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR;
exports.ENABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR = ENABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR;
exports.ENABLE_CPI_GUARD_DISCRIMINATOR = ENABLE_CPI_GUARD_DISCRIMINATOR;
exports.ENABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = ENABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR;
exports.ENABLE_HARVEST_TO_MINT_DISCRIMINATOR = ENABLE_HARVEST_TO_MINT_DISCRIMINATOR;
exports.ENABLE_MEMO_TRANSFERS_DISCRIMINATOR = ENABLE_MEMO_TRANSFERS_DISCRIMINATOR;
exports.ENABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR = ENABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR;
exports.ENABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = ENABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR;
exports.ENABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR = ENABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR;
exports.ExtensionType = ExtensionType;
exports.FREEZE_ACCOUNT_DISCRIMINATOR = FREEZE_ACCOUNT_DISCRIMINATOR;
exports.GET_ACCOUNT_DATA_SIZE_DISCRIMINATOR = GET_ACCOUNT_DATA_SIZE_DISCRIMINATOR;
exports.HARVEST_WITHHELD_TOKENS_TO_MINT_DISCRIMINATOR = HARVEST_WITHHELD_TOKENS_TO_MINT_DISCRIMINATOR;
exports.HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR;
exports.HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR;
exports.HARVEST_WITHHELD_TOKENS_TO_MINT_TRANSFER_FEE_DISCRIMINATOR = HARVEST_WITHHELD_TOKENS_TO_MINT_TRANSFER_FEE_DISCRIMINATOR;
exports.INITIALIZE_ACCOUNT2_DISCRIMINATOR = INITIALIZE_ACCOUNT2_DISCRIMINATOR;
exports.INITIALIZE_ACCOUNT3_DISCRIMINATOR = INITIALIZE_ACCOUNT3_DISCRIMINATOR;
exports.INITIALIZE_ACCOUNT_DISCRIMINATOR = INITIALIZE_ACCOUNT_DISCRIMINATOR;
exports.INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR;
exports.INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR;
exports.INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR;
exports.INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR = INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR;
exports.INITIALIZE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR = INITIALIZE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR;
exports.INITIALIZE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR = INITIALIZE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR;
exports.INITIALIZE_GROUP_MEMBER_POINTER_DISCRIMINATOR = INITIALIZE_GROUP_MEMBER_POINTER_DISCRIMINATOR;
exports.INITIALIZE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR = INITIALIZE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR;
exports.INITIALIZE_GROUP_POINTER_DISCRIMINATOR = INITIALIZE_GROUP_POINTER_DISCRIMINATOR;
exports.INITIALIZE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR = INITIALIZE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR;
exports.INITIALIZE_IMMUTABLE_OWNER_DISCRIMINATOR = INITIALIZE_IMMUTABLE_OWNER_DISCRIMINATOR;
exports.INITIALIZE_INTEREST_BEARING_MINT_DISCRIMINATOR = INITIALIZE_INTEREST_BEARING_MINT_DISCRIMINATOR;
exports.INITIALIZE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR = INITIALIZE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR;
exports.INITIALIZE_METADATA_POINTER_DISCRIMINATOR = INITIALIZE_METADATA_POINTER_DISCRIMINATOR;
exports.INITIALIZE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR = INITIALIZE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR;
exports.INITIALIZE_MINT2_DISCRIMINATOR = INITIALIZE_MINT2_DISCRIMINATOR;
exports.INITIALIZE_MINT_CLOSE_AUTHORITY_DISCRIMINATOR = INITIALIZE_MINT_CLOSE_AUTHORITY_DISCRIMINATOR;
exports.INITIALIZE_MINT_DISCRIMINATOR = INITIALIZE_MINT_DISCRIMINATOR;
exports.INITIALIZE_MULTISIG2_DISCRIMINATOR = INITIALIZE_MULTISIG2_DISCRIMINATOR;
exports.INITIALIZE_MULTISIG_DISCRIMINATOR = INITIALIZE_MULTISIG_DISCRIMINATOR;
exports.INITIALIZE_NON_TRANSFERABLE_MINT_DISCRIMINATOR = INITIALIZE_NON_TRANSFERABLE_MINT_DISCRIMINATOR;
exports.INITIALIZE_PERMANENT_DELEGATE_DISCRIMINATOR = INITIALIZE_PERMANENT_DELEGATE_DISCRIMINATOR;
exports.INITIALIZE_TOKEN_GROUP_DISCRIMINATOR = INITIALIZE_TOKEN_GROUP_DISCRIMINATOR;
exports.INITIALIZE_TOKEN_GROUP_MEMBER_DISCRIMINATOR = INITIALIZE_TOKEN_GROUP_MEMBER_DISCRIMINATOR;
exports.INITIALIZE_TOKEN_METADATA_DISCRIMINATOR = INITIALIZE_TOKEN_METADATA_DISCRIMINATOR;
exports.INITIALIZE_TRANSFER_FEE_CONFIG_DISCRIMINATOR = INITIALIZE_TRANSFER_FEE_CONFIG_DISCRIMINATOR;
exports.INITIALIZE_TRANSFER_FEE_CONFIG_TRANSFER_FEE_DISCRIMINATOR = INITIALIZE_TRANSFER_FEE_CONFIG_TRANSFER_FEE_DISCRIMINATOR;
exports.INITIALIZE_TRANSFER_HOOK_DISCRIMINATOR = INITIALIZE_TRANSFER_HOOK_DISCRIMINATOR;
exports.INITIALIZE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR = INITIALIZE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR;
exports.MINT_TO_CHECKED_DISCRIMINATOR = MINT_TO_CHECKED_DISCRIMINATOR;
exports.MINT_TO_DISCRIMINATOR = MINT_TO_DISCRIMINATOR;
exports.REALLOCATE_DISCRIMINATOR = REALLOCATE_DISCRIMINATOR;
exports.RECOVER_NESTED_ASSOCIATED_TOKEN_DISCRIMINATOR = RECOVER_NESTED_ASSOCIATED_TOKEN_DISCRIMINATOR;
exports.REMOVE_TOKEN_METADATA_KEY_DISCRIMINATOR = REMOVE_TOKEN_METADATA_KEY_DISCRIMINATOR;
exports.REVOKE_DISCRIMINATOR = REVOKE_DISCRIMINATOR;
exports.SET_AUTHORITY_DISCRIMINATOR = SET_AUTHORITY_DISCRIMINATOR;
exports.SET_TRANSFER_FEE_DISCRIMINATOR = SET_TRANSFER_FEE_DISCRIMINATOR;
exports.SET_TRANSFER_FEE_TRANSFER_FEE_DISCRIMINATOR = SET_TRANSFER_FEE_TRANSFER_FEE_DISCRIMINATOR;
exports.SYNC_NATIVE_DISCRIMINATOR = SYNC_NATIVE_DISCRIMINATOR;
exports.THAW_ACCOUNT_DISCRIMINATOR = THAW_ACCOUNT_DISCRIMINATOR;
exports.TOKEN_2022_ERROR__ACCOUNT_FROZEN = TOKEN_2022_ERROR__ACCOUNT_FROZEN;
exports.TOKEN_2022_ERROR__ALREADY_IN_USE = TOKEN_2022_ERROR__ALREADY_IN_USE;
exports.TOKEN_2022_ERROR__AUTHORITY_TYPE_NOT_SUPPORTED = TOKEN_2022_ERROR__AUTHORITY_TYPE_NOT_SUPPORTED;
exports.TOKEN_2022_ERROR__FIXED_SUPPLY = TOKEN_2022_ERROR__FIXED_SUPPLY;
exports.TOKEN_2022_ERROR__INSUFFICIENT_FUNDS = TOKEN_2022_ERROR__INSUFFICIENT_FUNDS;
exports.TOKEN_2022_ERROR__INVALID_INSTRUCTION = TOKEN_2022_ERROR__INVALID_INSTRUCTION;
exports.TOKEN_2022_ERROR__INVALID_MINT = TOKEN_2022_ERROR__INVALID_MINT;
exports.TOKEN_2022_ERROR__INVALID_NUMBER_OF_PROVIDED_SIGNERS = TOKEN_2022_ERROR__INVALID_NUMBER_OF_PROVIDED_SIGNERS;
exports.TOKEN_2022_ERROR__INVALID_NUMBER_OF_REQUIRED_SIGNERS = TOKEN_2022_ERROR__INVALID_NUMBER_OF_REQUIRED_SIGNERS;
exports.TOKEN_2022_ERROR__INVALID_STATE = TOKEN_2022_ERROR__INVALID_STATE;
exports.TOKEN_2022_ERROR__MINT_CANNOT_FREEZE = TOKEN_2022_ERROR__MINT_CANNOT_FREEZE;
exports.TOKEN_2022_ERROR__MINT_DECIMALS_MISMATCH = TOKEN_2022_ERROR__MINT_DECIMALS_MISMATCH;
exports.TOKEN_2022_ERROR__MINT_MISMATCH = TOKEN_2022_ERROR__MINT_MISMATCH;
exports.TOKEN_2022_ERROR__NATIVE_NOT_SUPPORTED = TOKEN_2022_ERROR__NATIVE_NOT_SUPPORTED;
exports.TOKEN_2022_ERROR__NON_NATIVE_HAS_BALANCE = TOKEN_2022_ERROR__NON_NATIVE_HAS_BALANCE;
exports.TOKEN_2022_ERROR__NON_NATIVE_NOT_SUPPORTED = TOKEN_2022_ERROR__NON_NATIVE_NOT_SUPPORTED;
exports.TOKEN_2022_ERROR__NOT_RENT_EXEMPT = TOKEN_2022_ERROR__NOT_RENT_EXEMPT;
exports.TOKEN_2022_ERROR__OVERFLOW = TOKEN_2022_ERROR__OVERFLOW;
exports.TOKEN_2022_ERROR__OWNER_MISMATCH = TOKEN_2022_ERROR__OWNER_MISMATCH;
exports.TOKEN_2022_ERROR__UNINITIALIZED_STATE = TOKEN_2022_ERROR__UNINITIALIZED_STATE;
exports.TOKEN_2022_PROGRAM_ADDRESS = TOKEN_2022_PROGRAM_ADDRESS;
exports.TRANSFER_CHECKED_DISCRIMINATOR = TRANSFER_CHECKED_DISCRIMINATOR;
exports.TRANSFER_CHECKED_WITH_FEE_DISCRIMINATOR = TRANSFER_CHECKED_WITH_FEE_DISCRIMINATOR;
exports.TRANSFER_CHECKED_WITH_FEE_TRANSFER_FEE_DISCRIMINATOR = TRANSFER_CHECKED_WITH_FEE_TRANSFER_FEE_DISCRIMINATOR;
exports.TRANSFER_DISCRIMINATOR = TRANSFER_DISCRIMINATOR;
exports.Token2022Account = Token2022Account;
exports.Token2022Instruction = Token2022Instruction;
exports.UI_AMOUNT_TO_AMOUNT_DISCRIMINATOR = UI_AMOUNT_TO_AMOUNT_DISCRIMINATOR;
exports.UPDATE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = UPDATE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR;
exports.UPDATE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR = UPDATE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR;
exports.UPDATE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR = UPDATE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR;
exports.UPDATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR = UPDATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR;
exports.UPDATE_GROUP_MEMBER_POINTER_DISCRIMINATOR = UPDATE_GROUP_MEMBER_POINTER_DISCRIMINATOR;
exports.UPDATE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR = UPDATE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR;
exports.UPDATE_GROUP_POINTER_DISCRIMINATOR = UPDATE_GROUP_POINTER_DISCRIMINATOR;
exports.UPDATE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR = UPDATE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR;
exports.UPDATE_METADATA_POINTER_DISCRIMINATOR = UPDATE_METADATA_POINTER_DISCRIMINATOR;
exports.UPDATE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR = UPDATE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR;
exports.UPDATE_RATE_INTEREST_BEARING_MINT_DISCRIMINATOR = UPDATE_RATE_INTEREST_BEARING_MINT_DISCRIMINATOR;
exports.UPDATE_RATE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR = UPDATE_RATE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR;
exports.UPDATE_TOKEN_GROUP_MAX_SIZE_DISCRIMINATOR = UPDATE_TOKEN_GROUP_MAX_SIZE_DISCRIMINATOR;
exports.UPDATE_TOKEN_GROUP_UPDATE_AUTHORITY_DISCRIMINATOR = UPDATE_TOKEN_GROUP_UPDATE_AUTHORITY_DISCRIMINATOR;
exports.UPDATE_TOKEN_METADATA_FIELD_DISCRIMINATOR = UPDATE_TOKEN_METADATA_FIELD_DISCRIMINATOR;
exports.UPDATE_TOKEN_METADATA_UPDATE_AUTHORITY_DISCRIMINATOR = UPDATE_TOKEN_METADATA_UPDATE_AUTHORITY_DISCRIMINATOR;
exports.UPDATE_TRANSFER_HOOK_DISCRIMINATOR = UPDATE_TRANSFER_HOOK_DISCRIMINATOR;
exports.UPDATE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR = UPDATE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR;
exports.WITHDRAW_EXCESS_LAMPORTS_DISCRIMINATOR = WITHDRAW_EXCESS_LAMPORTS_DISCRIMINATOR;
exports.WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_DISCRIMINATOR = WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_DISCRIMINATOR;
exports.WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR;
exports.WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR;
exports.WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_TRANSFER_FEE_DISCRIMINATOR = WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_TRANSFER_FEE_DISCRIMINATOR;
exports.WITHDRAW_WITHHELD_TOKENS_FROM_MINT_DISCRIMINATOR = WITHDRAW_WITHHELD_TOKENS_FROM_MINT_DISCRIMINATOR;
exports.WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR;
exports.WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR;
exports.WITHDRAW_WITHHELD_TOKENS_FROM_MINT_TRANSFER_FEE_DISCRIMINATOR = WITHDRAW_WITHHELD_TOKENS_FROM_MINT_TRANSFER_FEE_DISCRIMINATOR;
exports.decodeMint = decodeMint;
exports.decodeMultisig = decodeMultisig;
exports.decodeToken = decodeToken;
exports.extension = extension;
exports.fetchAllMaybeMint = fetchAllMaybeMint;
exports.fetchAllMaybeMultisig = fetchAllMaybeMultisig;
exports.fetchAllMaybeToken = fetchAllMaybeToken;
exports.fetchAllMint = fetchAllMint;
exports.fetchAllMultisig = fetchAllMultisig;
exports.fetchAllToken = fetchAllToken;
exports.fetchMaybeMint = fetchMaybeMint;
exports.fetchMaybeMultisig = fetchMaybeMultisig;
exports.fetchMaybeToken = fetchMaybeToken;
exports.fetchMint = fetchMint;
exports.fetchMultisig = fetchMultisig;
exports.fetchToken = fetchToken;
exports.findAssociatedTokenPda = findAssociatedTokenPda;
exports.getAccountStateCodec = getAccountStateCodec;
exports.getAccountStateDecoder = getAccountStateDecoder;
exports.getAccountStateEncoder = getAccountStateEncoder;
exports.getAmountToUiAmountDiscriminatorBytes = getAmountToUiAmountDiscriminatorBytes;
exports.getAmountToUiAmountInstruction = getAmountToUiAmountInstruction;
exports.getAmountToUiAmountInstructionDataCodec = getAmountToUiAmountInstructionDataCodec;
exports.getAmountToUiAmountInstructionDataDecoder = getAmountToUiAmountInstructionDataDecoder;
exports.getAmountToUiAmountInstructionDataEncoder = getAmountToUiAmountInstructionDataEncoder;
exports.getApplyConfidentialPendingBalanceConfidentialTransferDiscriminatorBytes = getApplyConfidentialPendingBalanceConfidentialTransferDiscriminatorBytes;
exports.getApplyConfidentialPendingBalanceDiscriminatorBytes = getApplyConfidentialPendingBalanceDiscriminatorBytes;
exports.getApplyConfidentialPendingBalanceInstruction = getApplyConfidentialPendingBalanceInstruction;
exports.getApplyConfidentialPendingBalanceInstructionDataCodec = getApplyConfidentialPendingBalanceInstructionDataCodec;
exports.getApplyConfidentialPendingBalanceInstructionDataDecoder = getApplyConfidentialPendingBalanceInstructionDataDecoder;
exports.getApplyConfidentialPendingBalanceInstructionDataEncoder = getApplyConfidentialPendingBalanceInstructionDataEncoder;
exports.getApproveCheckedDiscriminatorBytes = getApproveCheckedDiscriminatorBytes;
exports.getApproveCheckedInstruction = getApproveCheckedInstruction;
exports.getApproveCheckedInstructionDataCodec = getApproveCheckedInstructionDataCodec;
exports.getApproveCheckedInstructionDataDecoder = getApproveCheckedInstructionDataDecoder;
exports.getApproveCheckedInstructionDataEncoder = getApproveCheckedInstructionDataEncoder;
exports.getApproveConfidentialTransferAccountConfidentialTransferDiscriminatorBytes = getApproveConfidentialTransferAccountConfidentialTransferDiscriminatorBytes;
exports.getApproveConfidentialTransferAccountDiscriminatorBytes = getApproveConfidentialTransferAccountDiscriminatorBytes;
exports.getApproveConfidentialTransferAccountInstruction = getApproveConfidentialTransferAccountInstruction;
exports.getApproveConfidentialTransferAccountInstructionDataCodec = getApproveConfidentialTransferAccountInstructionDataCodec;
exports.getApproveConfidentialTransferAccountInstructionDataDecoder = getApproveConfidentialTransferAccountInstructionDataDecoder;
exports.getApproveConfidentialTransferAccountInstructionDataEncoder = getApproveConfidentialTransferAccountInstructionDataEncoder;
exports.getApproveDiscriminatorBytes = getApproveDiscriminatorBytes;
exports.getApproveInstruction = getApproveInstruction;
exports.getApproveInstructionDataCodec = getApproveInstructionDataCodec;
exports.getApproveInstructionDataDecoder = getApproveInstructionDataDecoder;
exports.getApproveInstructionDataEncoder = getApproveInstructionDataEncoder;
exports.getAssociatedTokenErrorMessage = getAssociatedTokenErrorMessage;
exports.getAuthorityTypeCodec = getAuthorityTypeCodec;
exports.getAuthorityTypeDecoder = getAuthorityTypeDecoder;
exports.getAuthorityTypeEncoder = getAuthorityTypeEncoder;
exports.getBurnCheckedDiscriminatorBytes = getBurnCheckedDiscriminatorBytes;
exports.getBurnCheckedInstruction = getBurnCheckedInstruction;
exports.getBurnCheckedInstructionDataCodec = getBurnCheckedInstructionDataCodec;
exports.getBurnCheckedInstructionDataDecoder = getBurnCheckedInstructionDataDecoder;
exports.getBurnCheckedInstructionDataEncoder = getBurnCheckedInstructionDataEncoder;
exports.getBurnDiscriminatorBytes = getBurnDiscriminatorBytes;
exports.getBurnInstruction = getBurnInstruction;
exports.getBurnInstructionDataCodec = getBurnInstructionDataCodec;
exports.getBurnInstructionDataDecoder = getBurnInstructionDataDecoder;
exports.getBurnInstructionDataEncoder = getBurnInstructionDataEncoder;
exports.getCloseAccountDiscriminatorBytes = getCloseAccountDiscriminatorBytes;
exports.getCloseAccountInstruction = getCloseAccountInstruction;
exports.getCloseAccountInstructionDataCodec = getCloseAccountInstructionDataCodec;
exports.getCloseAccountInstructionDataDecoder = getCloseAccountInstructionDataDecoder;
exports.getCloseAccountInstructionDataEncoder = getCloseAccountInstructionDataEncoder;
exports.getConfidentialDepositConfidentialTransferDiscriminatorBytes = getConfidentialDepositConfidentialTransferDiscriminatorBytes;
exports.getConfidentialDepositDiscriminatorBytes = getConfidentialDepositDiscriminatorBytes;
exports.getConfidentialDepositInstruction = getConfidentialDepositInstruction;
exports.getConfidentialDepositInstructionDataCodec = getConfidentialDepositInstructionDataCodec;
exports.getConfidentialDepositInstructionDataDecoder = getConfidentialDepositInstructionDataDecoder;
exports.getConfidentialDepositInstructionDataEncoder = getConfidentialDepositInstructionDataEncoder;
exports.getConfidentialTransferConfidentialTransferDiscriminatorBytes = getConfidentialTransferConfidentialTransferDiscriminatorBytes;
exports.getConfidentialTransferDiscriminatorBytes = getConfidentialTransferDiscriminatorBytes;
exports.getConfidentialTransferInstruction = getConfidentialTransferInstruction;
exports.getConfidentialTransferInstructionDataCodec = getConfidentialTransferInstructionDataCodec;
exports.getConfidentialTransferInstructionDataDecoder = getConfidentialTransferInstructionDataDecoder;
exports.getConfidentialTransferInstructionDataEncoder = getConfidentialTransferInstructionDataEncoder;
exports.getConfidentialTransferWithFeeConfidentialTransferDiscriminatorBytes = getConfidentialTransferWithFeeConfidentialTransferDiscriminatorBytes;
exports.getConfidentialTransferWithFeeDiscriminatorBytes = getConfidentialTransferWithFeeDiscriminatorBytes;
exports.getConfidentialTransferWithFeeInstruction = getConfidentialTransferWithFeeInstruction;
exports.getConfidentialTransferWithFeeInstructionDataCodec = getConfidentialTransferWithFeeInstructionDataCodec;
exports.getConfidentialTransferWithFeeInstructionDataDecoder = getConfidentialTransferWithFeeInstructionDataDecoder;
exports.getConfidentialTransferWithFeeInstructionDataEncoder = getConfidentialTransferWithFeeInstructionDataEncoder;
exports.getConfidentialWithdrawConfidentialTransferDiscriminatorBytes = getConfidentialWithdrawConfidentialTransferDiscriminatorBytes;
exports.getConfidentialWithdrawDiscriminatorBytes = getConfidentialWithdrawDiscriminatorBytes;
exports.getConfidentialWithdrawInstruction = getConfidentialWithdrawInstruction;
exports.getConfidentialWithdrawInstructionDataCodec = getConfidentialWithdrawInstructionDataCodec;
exports.getConfidentialWithdrawInstructionDataDecoder = getConfidentialWithdrawInstructionDataDecoder;
exports.getConfidentialWithdrawInstructionDataEncoder = getConfidentialWithdrawInstructionDataEncoder;
exports.getConfigureConfidentialTransferAccountConfidentialTransferDiscriminatorBytes = getConfigureConfidentialTransferAccountConfidentialTransferDiscriminatorBytes;
exports.getConfigureConfidentialTransferAccountDiscriminatorBytes = getConfigureConfidentialTransferAccountDiscriminatorBytes;
exports.getConfigureConfidentialTransferAccountInstruction = getConfigureConfidentialTransferAccountInstruction;
exports.getConfigureConfidentialTransferAccountInstructionDataCodec = getConfigureConfidentialTransferAccountInstructionDataCodec;
exports.getConfigureConfidentialTransferAccountInstructionDataDecoder = getConfigureConfidentialTransferAccountInstructionDataDecoder;
exports.getConfigureConfidentialTransferAccountInstructionDataEncoder = getConfigureConfidentialTransferAccountInstructionDataEncoder;
exports.getCreateAssociatedTokenDiscriminatorBytes = getCreateAssociatedTokenDiscriminatorBytes;
exports.getCreateAssociatedTokenIdempotentDiscriminatorBytes = getCreateAssociatedTokenIdempotentDiscriminatorBytes;
exports.getCreateAssociatedTokenIdempotentInstruction = getCreateAssociatedTokenIdempotentInstruction;
exports.getCreateAssociatedTokenIdempotentInstructionAsync = getCreateAssociatedTokenIdempotentInstructionAsync;
exports.getCreateAssociatedTokenIdempotentInstructionDataCodec = getCreateAssociatedTokenIdempotentInstructionDataCodec;
exports.getCreateAssociatedTokenIdempotentInstructionDataDecoder = getCreateAssociatedTokenIdempotentInstructionDataDecoder;
exports.getCreateAssociatedTokenIdempotentInstructionDataEncoder = getCreateAssociatedTokenIdempotentInstructionDataEncoder;
exports.getCreateAssociatedTokenInstruction = getCreateAssociatedTokenInstruction;
exports.getCreateAssociatedTokenInstructionAsync = getCreateAssociatedTokenInstructionAsync;
exports.getCreateAssociatedTokenInstructionDataCodec = getCreateAssociatedTokenInstructionDataCodec;
exports.getCreateAssociatedTokenInstructionDataDecoder = getCreateAssociatedTokenInstructionDataDecoder;
exports.getCreateAssociatedTokenInstructionDataEncoder = getCreateAssociatedTokenInstructionDataEncoder;
exports.getCreateNativeMintDiscriminatorBytes = getCreateNativeMintDiscriminatorBytes;
exports.getCreateNativeMintInstruction = getCreateNativeMintInstruction;
exports.getCreateNativeMintInstructionDataCodec = getCreateNativeMintInstructionDataCodec;
exports.getCreateNativeMintInstructionDataDecoder = getCreateNativeMintInstructionDataDecoder;
exports.getCreateNativeMintInstructionDataEncoder = getCreateNativeMintInstructionDataEncoder;
exports.getDecryptableBalanceCodec = getDecryptableBalanceCodec;
exports.getDecryptableBalanceDecoder = getDecryptableBalanceDecoder;
exports.getDecryptableBalanceEncoder = getDecryptableBalanceEncoder;
exports.getDisableConfidentialCreditsConfidentialTransferDiscriminatorBytes = getDisableConfidentialCreditsConfidentialTransferDiscriminatorBytes;
exports.getDisableConfidentialCreditsDiscriminatorBytes = getDisableConfidentialCreditsDiscriminatorBytes;
exports.getDisableConfidentialCreditsInstruction = getDisableConfidentialCreditsInstruction;
exports.getDisableConfidentialCreditsInstructionDataCodec = getDisableConfidentialCreditsInstructionDataCodec;
exports.getDisableConfidentialCreditsInstructionDataDecoder = getDisableConfidentialCreditsInstructionDataDecoder;
exports.getDisableConfidentialCreditsInstructionDataEncoder = getDisableConfidentialCreditsInstructionDataEncoder;
exports.getDisableCpiGuardCpiGuardDiscriminatorBytes = getDisableCpiGuardCpiGuardDiscriminatorBytes;
exports.getDisableCpiGuardDiscriminatorBytes = getDisableCpiGuardDiscriminatorBytes;
exports.getDisableCpiGuardInstruction = getDisableCpiGuardInstruction;
exports.getDisableCpiGuardInstructionDataCodec = getDisableCpiGuardInstructionDataCodec;
exports.getDisableCpiGuardInstructionDataDecoder = getDisableCpiGuardInstructionDataDecoder;
exports.getDisableCpiGuardInstructionDataEncoder = getDisableCpiGuardInstructionDataEncoder;
exports.getDisableHarvestToMintConfidentialTransferFeeDiscriminatorBytes = getDisableHarvestToMintConfidentialTransferFeeDiscriminatorBytes;
exports.getDisableHarvestToMintDiscriminatorBytes = getDisableHarvestToMintDiscriminatorBytes;
exports.getDisableHarvestToMintInstruction = getDisableHarvestToMintInstruction;
exports.getDisableHarvestToMintInstructionDataCodec = getDisableHarvestToMintInstructionDataCodec;
exports.getDisableHarvestToMintInstructionDataDecoder = getDisableHarvestToMintInstructionDataDecoder;
exports.getDisableHarvestToMintInstructionDataEncoder = getDisableHarvestToMintInstructionDataEncoder;
exports.getDisableMemoTransfersDiscriminatorBytes = getDisableMemoTransfersDiscriminatorBytes;
exports.getDisableMemoTransfersInstruction = getDisableMemoTransfersInstruction;
exports.getDisableMemoTransfersInstructionDataCodec = getDisableMemoTransfersInstructionDataCodec;
exports.getDisableMemoTransfersInstructionDataDecoder = getDisableMemoTransfersInstructionDataDecoder;
exports.getDisableMemoTransfersInstructionDataEncoder = getDisableMemoTransfersInstructionDataEncoder;
exports.getDisableMemoTransfersMemoTransfersDiscriminatorBytes = getDisableMemoTransfersMemoTransfersDiscriminatorBytes;
exports.getDisableNonConfidentialCreditsConfidentialTransferDiscriminatorBytes = getDisableNonConfidentialCreditsConfidentialTransferDiscriminatorBytes;
exports.getDisableNonConfidentialCreditsDiscriminatorBytes = getDisableNonConfidentialCreditsDiscriminatorBytes;
exports.getDisableNonConfidentialCreditsInstruction = getDisableNonConfidentialCreditsInstruction;
exports.getDisableNonConfidentialCreditsInstructionDataCodec = getDisableNonConfidentialCreditsInstructionDataCodec;
exports.getDisableNonConfidentialCreditsInstructionDataDecoder = getDisableNonConfidentialCreditsInstructionDataDecoder;
exports.getDisableNonConfidentialCreditsInstructionDataEncoder = getDisableNonConfidentialCreditsInstructionDataEncoder;
exports.getEmitTokenMetadataDiscriminatorBytes = getEmitTokenMetadataDiscriminatorBytes;
exports.getEmitTokenMetadataInstruction = getEmitTokenMetadataInstruction;
exports.getEmitTokenMetadataInstructionDataCodec = getEmitTokenMetadataInstructionDataCodec;
exports.getEmitTokenMetadataInstructionDataDecoder = getEmitTokenMetadataInstructionDataDecoder;
exports.getEmitTokenMetadataInstructionDataEncoder = getEmitTokenMetadataInstructionDataEncoder;
exports.getEmptyConfidentialTransferAccountConfidentialTransferDiscriminatorBytes = getEmptyConfidentialTransferAccountConfidentialTransferDiscriminatorBytes;
exports.getEmptyConfidentialTransferAccountDiscriminatorBytes = getEmptyConfidentialTransferAccountDiscriminatorBytes;
exports.getEmptyConfidentialTransferAccountInstruction = getEmptyConfidentialTransferAccountInstruction;
exports.getEmptyConfidentialTransferAccountInstructionDataCodec = getEmptyConfidentialTransferAccountInstructionDataCodec;
exports.getEmptyConfidentialTransferAccountInstructionDataDecoder = getEmptyConfidentialTransferAccountInstructionDataDecoder;
exports.getEmptyConfidentialTransferAccountInstructionDataEncoder = getEmptyConfidentialTransferAccountInstructionDataEncoder;
exports.getEnableConfidentialCreditsConfidentialTransferDiscriminatorBytes = getEnableConfidentialCreditsConfidentialTransferDiscriminatorBytes;
exports.getEnableConfidentialCreditsDiscriminatorBytes = getEnableConfidentialCreditsDiscriminatorBytes;
exports.getEnableConfidentialCreditsInstruction = getEnableConfidentialCreditsInstruction;
exports.getEnableConfidentialCreditsInstructionDataCodec = getEnableConfidentialCreditsInstructionDataCodec;
exports.getEnableConfidentialCreditsInstructionDataDecoder = getEnableConfidentialCreditsInstructionDataDecoder;
exports.getEnableConfidentialCreditsInstructionDataEncoder = getEnableConfidentialCreditsInstructionDataEncoder;
exports.getEnableCpiGuardCpiGuardDiscriminatorBytes = getEnableCpiGuardCpiGuardDiscriminatorBytes;
exports.getEnableCpiGuardDiscriminatorBytes = getEnableCpiGuardDiscriminatorBytes;
exports.getEnableCpiGuardInstruction = getEnableCpiGuardInstruction;
exports.getEnableCpiGuardInstructionDataCodec = getEnableCpiGuardInstructionDataCodec;
exports.getEnableCpiGuardInstructionDataDecoder = getEnableCpiGuardInstructionDataDecoder;
exports.getEnableCpiGuardInstructionDataEncoder = getEnableCpiGuardInstructionDataEncoder;
exports.getEnableHarvestToMintConfidentialTransferFeeDiscriminatorBytes = getEnableHarvestToMintConfidentialTransferFeeDiscriminatorBytes;
exports.getEnableHarvestToMintDiscriminatorBytes = getEnableHarvestToMintDiscriminatorBytes;
exports.getEnableHarvestToMintInstruction = getEnableHarvestToMintInstruction;
exports.getEnableHarvestToMintInstructionDataCodec = getEnableHarvestToMintInstructionDataCodec;
exports.getEnableHarvestToMintInstructionDataDecoder = getEnableHarvestToMintInstructionDataDecoder;
exports.getEnableHarvestToMintInstructionDataEncoder = getEnableHarvestToMintInstructionDataEncoder;
exports.getEnableMemoTransfersDiscriminatorBytes = getEnableMemoTransfersDiscriminatorBytes;
exports.getEnableMemoTransfersInstruction = getEnableMemoTransfersInstruction;
exports.getEnableMemoTransfersInstructionDataCodec = getEnableMemoTransfersInstructionDataCodec;
exports.getEnableMemoTransfersInstructionDataDecoder = getEnableMemoTransfersInstructionDataDecoder;
exports.getEnableMemoTransfersInstructionDataEncoder = getEnableMemoTransfersInstructionDataEncoder;
exports.getEnableMemoTransfersMemoTransfersDiscriminatorBytes = getEnableMemoTransfersMemoTransfersDiscriminatorBytes;
exports.getEnableNonConfidentialCreditsConfidentialTransferDiscriminatorBytes = getEnableNonConfidentialCreditsConfidentialTransferDiscriminatorBytes;
exports.getEnableNonConfidentialCreditsDiscriminatorBytes = getEnableNonConfidentialCreditsDiscriminatorBytes;
exports.getEnableNonConfidentialCreditsInstruction = getEnableNonConfidentialCreditsInstruction;
exports.getEnableNonConfidentialCreditsInstructionDataCodec = getEnableNonConfidentialCreditsInstructionDataCodec;
exports.getEnableNonConfidentialCreditsInstructionDataDecoder = getEnableNonConfidentialCreditsInstructionDataDecoder;
exports.getEnableNonConfidentialCreditsInstructionDataEncoder = getEnableNonConfidentialCreditsInstructionDataEncoder;
exports.getEncryptedBalanceCodec = getEncryptedBalanceCodec;
exports.getEncryptedBalanceDecoder = getEncryptedBalanceDecoder;
exports.getEncryptedBalanceEncoder = getEncryptedBalanceEncoder;
exports.getExtensionCodec = getExtensionCodec;
exports.getExtensionDecoder = getExtensionDecoder;
exports.getExtensionEncoder = getExtensionEncoder;
exports.getExtensionTypeCodec = getExtensionTypeCodec;
exports.getExtensionTypeDecoder = getExtensionTypeDecoder;
exports.getExtensionTypeEncoder = getExtensionTypeEncoder;
exports.getFreezeAccountDiscriminatorBytes = getFreezeAccountDiscriminatorBytes;
exports.getFreezeAccountInstruction = getFreezeAccountInstruction;
exports.getFreezeAccountInstructionDataCodec = getFreezeAccountInstructionDataCodec;
exports.getFreezeAccountInstructionDataDecoder = getFreezeAccountInstructionDataDecoder;
exports.getFreezeAccountInstructionDataEncoder = getFreezeAccountInstructionDataEncoder;
exports.getGetAccountDataSizeDiscriminatorBytes = getGetAccountDataSizeDiscriminatorBytes;
exports.getGetAccountDataSizeInstruction = getGetAccountDataSizeInstruction;
exports.getGetAccountDataSizeInstructionDataCodec = getGetAccountDataSizeInstructionDataCodec;
exports.getGetAccountDataSizeInstructionDataDecoder = getGetAccountDataSizeInstructionDataDecoder;
exports.getGetAccountDataSizeInstructionDataEncoder = getGetAccountDataSizeInstructionDataEncoder;
exports.getHarvestWithheldTokensToMintDiscriminatorBytes = getHarvestWithheldTokensToMintDiscriminatorBytes;
exports.getHarvestWithheldTokensToMintForConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes = getHarvestWithheldTokensToMintForConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes;
exports.getHarvestWithheldTokensToMintForConfidentialTransferFeeDiscriminatorBytes = getHarvestWithheldTokensToMintForConfidentialTransferFeeDiscriminatorBytes;
exports.getHarvestWithheldTokensToMintForConfidentialTransferFeeInstruction = getHarvestWithheldTokensToMintForConfidentialTransferFeeInstruction;
exports.getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataCodec = getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataCodec;
exports.getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataDecoder = getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataDecoder;
exports.getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataEncoder = getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataEncoder;
exports.getHarvestWithheldTokensToMintInstruction = getHarvestWithheldTokensToMintInstruction;
exports.getHarvestWithheldTokensToMintInstructionDataCodec = getHarvestWithheldTokensToMintInstructionDataCodec;
exports.getHarvestWithheldTokensToMintInstructionDataDecoder = getHarvestWithheldTokensToMintInstructionDataDecoder;
exports.getHarvestWithheldTokensToMintInstructionDataEncoder = getHarvestWithheldTokensToMintInstructionDataEncoder;
exports.getHarvestWithheldTokensToMintTransferFeeDiscriminatorBytes = getHarvestWithheldTokensToMintTransferFeeDiscriminatorBytes;
exports.getInitializeAccount2DiscriminatorBytes = getInitializeAccount2DiscriminatorBytes;
exports.getInitializeAccount2Instruction = getInitializeAccount2Instruction;
exports.getInitializeAccount2InstructionDataCodec = getInitializeAccount2InstructionDataCodec;
exports.getInitializeAccount2InstructionDataDecoder = getInitializeAccount2InstructionDataDecoder;
exports.getInitializeAccount2InstructionDataEncoder = getInitializeAccount2InstructionDataEncoder;
exports.getInitializeAccount3DiscriminatorBytes = getInitializeAccount3DiscriminatorBytes;
exports.getInitializeAccount3Instruction = getInitializeAccount3Instruction;
exports.getInitializeAccount3InstructionDataCodec = getInitializeAccount3InstructionDataCodec;
exports.getInitializeAccount3InstructionDataDecoder = getInitializeAccount3InstructionDataDecoder;
exports.getInitializeAccount3InstructionDataEncoder = getInitializeAccount3InstructionDataEncoder;
exports.getInitializeAccountDiscriminatorBytes = getInitializeAccountDiscriminatorBytes;
exports.getInitializeAccountInstruction = getInitializeAccountInstruction;
exports.getInitializeAccountInstructionDataCodec = getInitializeAccountInstructionDataCodec;
exports.getInitializeAccountInstructionDataDecoder = getInitializeAccountInstructionDataDecoder;
exports.getInitializeAccountInstructionDataEncoder = getInitializeAccountInstructionDataEncoder;
exports.getInitializeConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes = getInitializeConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes;
exports.getInitializeConfidentialTransferFeeDiscriminatorBytes = getInitializeConfidentialTransferFeeDiscriminatorBytes;
exports.getInitializeConfidentialTransferFeeInstruction = getInitializeConfidentialTransferFeeInstruction;
exports.getInitializeConfidentialTransferFeeInstructionDataCodec = getInitializeConfidentialTransferFeeInstructionDataCodec;
exports.getInitializeConfidentialTransferFeeInstructionDataDecoder = getInitializeConfidentialTransferFeeInstructionDataDecoder;
exports.getInitializeConfidentialTransferFeeInstructionDataEncoder = getInitializeConfidentialTransferFeeInstructionDataEncoder;
exports.getInitializeConfidentialTransferMintConfidentialTransferDiscriminatorBytes = getInitializeConfidentialTransferMintConfidentialTransferDiscriminatorBytes;
exports.getInitializeConfidentialTransferMintDiscriminatorBytes = getInitializeConfidentialTransferMintDiscriminatorBytes;
exports.getInitializeConfidentialTransferMintInstruction = getInitializeConfidentialTransferMintInstruction;
exports.getInitializeConfidentialTransferMintInstructionDataCodec = getInitializeConfidentialTransferMintInstructionDataCodec;
exports.getInitializeConfidentialTransferMintInstructionDataDecoder = getInitializeConfidentialTransferMintInstructionDataDecoder;
exports.getInitializeConfidentialTransferMintInstructionDataEncoder = getInitializeConfidentialTransferMintInstructionDataEncoder;
exports.getInitializeDefaultAccountStateDefaultAccountStateDiscriminatorBytes = getInitializeDefaultAccountStateDefaultAccountStateDiscriminatorBytes;
exports.getInitializeDefaultAccountStateDiscriminatorBytes = getInitializeDefaultAccountStateDiscriminatorBytes;
exports.getInitializeDefaultAccountStateInstruction = getInitializeDefaultAccountStateInstruction;
exports.getInitializeDefaultAccountStateInstructionDataCodec = getInitializeDefaultAccountStateInstructionDataCodec;
exports.getInitializeDefaultAccountStateInstructionDataDecoder = getInitializeDefaultAccountStateInstructionDataDecoder;
exports.getInitializeDefaultAccountStateInstructionDataEncoder = getInitializeDefaultAccountStateInstructionDataEncoder;
exports.getInitializeGroupMemberPointerDiscriminatorBytes = getInitializeGroupMemberPointerDiscriminatorBytes;
exports.getInitializeGroupMemberPointerGroupMemberPointerDiscriminatorBytes = getInitializeGroupMemberPointerGroupMemberPointerDiscriminatorBytes;
exports.getInitializeGroupMemberPointerInstruction = getInitializeGroupMemberPointerInstruction;
exports.getInitializeGroupMemberPointerInstructionDataCodec = getInitializeGroupMemberPointerInstructionDataCodec;
exports.getInitializeGroupMemberPointerInstructionDataDecoder = getInitializeGroupMemberPointerInstructionDataDecoder;
exports.getInitializeGroupMemberPointerInstructionDataEncoder = getInitializeGroupMemberPointerInstructionDataEncoder;
exports.getInitializeGroupPointerDiscriminatorBytes = getInitializeGroupPointerDiscriminatorBytes;
exports.getInitializeGroupPointerGroupPointerDiscriminatorBytes = getInitializeGroupPointerGroupPointerDiscriminatorBytes;
exports.getInitializeGroupPointerInstruction = getInitializeGroupPointerInstruction;
exports.getInitializeGroupPointerInstructionDataCodec = getInitializeGroupPointerInstructionDataCodec;
exports.getInitializeGroupPointerInstructionDataDecoder = getInitializeGroupPointerInstructionDataDecoder;
exports.getInitializeGroupPointerInstructionDataEncoder = getInitializeGroupPointerInstructionDataEncoder;
exports.getInitializeImmutableOwnerDiscriminatorBytes = getInitializeImmutableOwnerDiscriminatorBytes;
exports.getInitializeImmutableOwnerInstruction = getInitializeImmutableOwnerInstruction;
exports.getInitializeImmutableOwnerInstructionDataCodec = getInitializeImmutableOwnerInstructionDataCodec;
exports.getInitializeImmutableOwnerInstructionDataDecoder = getInitializeImmutableOwnerInstructionDataDecoder;
exports.getInitializeImmutableOwnerInstructionDataEncoder = getInitializeImmutableOwnerInstructionDataEncoder;
exports.getInitializeInterestBearingMintDiscriminatorBytes = getInitializeInterestBearingMintDiscriminatorBytes;
exports.getInitializeInterestBearingMintInstruction = getInitializeInterestBearingMintInstruction;
exports.getInitializeInterestBearingMintInstructionDataCodec = getInitializeInterestBearingMintInstructionDataCodec;
exports.getInitializeInterestBearingMintInstructionDataDecoder = getInitializeInterestBearingMintInstructionDataDecoder;
exports.getInitializeInterestBearingMintInstructionDataEncoder = getInitializeInterestBearingMintInstructionDataEncoder;
exports.getInitializeInterestBearingMintInterestBearingMintDiscriminatorBytes = getInitializeInterestBearingMintInterestBearingMintDiscriminatorBytes;
exports.getInitializeMetadataPointerDiscriminatorBytes = getInitializeMetadataPointerDiscriminatorBytes;
exports.getInitializeMetadataPointerInstruction = getInitializeMetadataPointerInstruction;
exports.getInitializeMetadataPointerInstructionDataCodec = getInitializeMetadataPointerInstructionDataCodec;
exports.getInitializeMetadataPointerInstructionDataDecoder = getInitializeMetadataPointerInstructionDataDecoder;
exports.getInitializeMetadataPointerInstructionDataEncoder = getInitializeMetadataPointerInstructionDataEncoder;
exports.getInitializeMetadataPointerMetadataPointerDiscriminatorBytes = getInitializeMetadataPointerMetadataPointerDiscriminatorBytes;
exports.getInitializeMint2DiscriminatorBytes = getInitializeMint2DiscriminatorBytes;
exports.getInitializeMint2Instruction = getInitializeMint2Instruction;
exports.getInitializeMint2InstructionDataCodec = getInitializeMint2InstructionDataCodec;
exports.getInitializeMint2InstructionDataDecoder = getInitializeMint2InstructionDataDecoder;
exports.getInitializeMint2InstructionDataEncoder = getInitializeMint2InstructionDataEncoder;
exports.getInitializeMintCloseAuthorityDiscriminatorBytes = getInitializeMintCloseAuthorityDiscriminatorBytes;
exports.getInitializeMintCloseAuthorityInstruction = getInitializeMintCloseAuthorityInstruction;
exports.getInitializeMintCloseAuthorityInstructionDataCodec = getInitializeMintCloseAuthorityInstructionDataCodec;
exports.getInitializeMintCloseAuthorityInstructionDataDecoder = getInitializeMintCloseAuthorityInstructionDataDecoder;
exports.getInitializeMintCloseAuthorityInstructionDataEncoder = getInitializeMintCloseAuthorityInstructionDataEncoder;
exports.getInitializeMintDiscriminatorBytes = getInitializeMintDiscriminatorBytes;
exports.getInitializeMintInstruction = getInitializeMintInstruction;
exports.getInitializeMintInstructionDataCodec = getInitializeMintInstructionDataCodec;
exports.getInitializeMintInstructionDataDecoder = getInitializeMintInstructionDataDecoder;
exports.getInitializeMintInstructionDataEncoder = getInitializeMintInstructionDataEncoder;
exports.getInitializeMultisig2DiscriminatorBytes = getInitializeMultisig2DiscriminatorBytes;
exports.getInitializeMultisig2Instruction = getInitializeMultisig2Instruction;
exports.getInitializeMultisig2InstructionDataCodec = getInitializeMultisig2InstructionDataCodec;
exports.getInitializeMultisig2InstructionDataDecoder = getInitializeMultisig2InstructionDataDecoder;
exports.getInitializeMultisig2InstructionDataEncoder = getInitializeMultisig2InstructionDataEncoder;
exports.getInitializeMultisigDiscriminatorBytes = getInitializeMultisigDiscriminatorBytes;
exports.getInitializeMultisigInstruction = getInitializeMultisigInstruction;
exports.getInitializeMultisigInstructionDataCodec = getInitializeMultisigInstructionDataCodec;
exports.getInitializeMultisigInstructionDataDecoder = getInitializeMultisigInstructionDataDecoder;
exports.getInitializeMultisigInstructionDataEncoder = getInitializeMultisigInstructionDataEncoder;
exports.getInitializeNonTransferableMintDiscriminatorBytes = getInitializeNonTransferableMintDiscriminatorBytes;
exports.getInitializeNonTransferableMintInstruction = getInitializeNonTransferableMintInstruction;
exports.getInitializeNonTransferableMintInstructionDataCodec = getInitializeNonTransferableMintInstructionDataCodec;
exports.getInitializeNonTransferableMintInstructionDataDecoder = getInitializeNonTransferableMintInstructionDataDecoder;
exports.getInitializeNonTransferableMintInstructionDataEncoder = getInitializeNonTransferableMintInstructionDataEncoder;
exports.getInitializePermanentDelegateDiscriminatorBytes = getInitializePermanentDelegateDiscriminatorBytes;
exports.getInitializePermanentDelegateInstruction = getInitializePermanentDelegateInstruction;
exports.getInitializePermanentDelegateInstructionDataCodec = getInitializePermanentDelegateInstructionDataCodec;
exports.getInitializePermanentDelegateInstructionDataDecoder = getInitializePermanentDelegateInstructionDataDecoder;
exports.getInitializePermanentDelegateInstructionDataEncoder = getInitializePermanentDelegateInstructionDataEncoder;
exports.getInitializeTokenGroupDiscriminatorBytes = getInitializeTokenGroupDiscriminatorBytes;
exports.getInitializeTokenGroupInstruction = getInitializeTokenGroupInstruction;
exports.getInitializeTokenGroupInstructionDataCodec = getInitializeTokenGroupInstructionDataCodec;
exports.getInitializeTokenGroupInstructionDataDecoder = getInitializeTokenGroupInstructionDataDecoder;
exports.getInitializeTokenGroupInstructionDataEncoder = getInitializeTokenGroupInstructionDataEncoder;
exports.getInitializeTokenGroupMemberDiscriminatorBytes = getInitializeTokenGroupMemberDiscriminatorBytes;
exports.getInitializeTokenGroupMemberInstruction = getInitializeTokenGroupMemberInstruction;
exports.getInitializeTokenGroupMemberInstructionDataCodec = getInitializeTokenGroupMemberInstructionDataCodec;
exports.getInitializeTokenGroupMemberInstructionDataDecoder = getInitializeTokenGroupMemberInstructionDataDecoder;
exports.getInitializeTokenGroupMemberInstructionDataEncoder = getInitializeTokenGroupMemberInstructionDataEncoder;
exports.getInitializeTokenMetadataDiscriminatorBytes = getInitializeTokenMetadataDiscriminatorBytes;
exports.getInitializeTokenMetadataInstruction = getInitializeTokenMetadataInstruction;
exports.getInitializeTokenMetadataInstructionDataCodec = getInitializeTokenMetadataInstructionDataCodec;
exports.getInitializeTokenMetadataInstructionDataDecoder = getInitializeTokenMetadataInstructionDataDecoder;
exports.getInitializeTokenMetadataInstructionDataEncoder = getInitializeTokenMetadataInstructionDataEncoder;
exports.getInitializeTransferFeeConfigDiscriminatorBytes = getInitializeTransferFeeConfigDiscriminatorBytes;
exports.getInitializeTransferFeeConfigInstruction = getInitializeTransferFeeConfigInstruction;
exports.getInitializeTransferFeeConfigInstructionDataCodec = getInitializeTransferFeeConfigInstructionDataCodec;
exports.getInitializeTransferFeeConfigInstructionDataDecoder = getInitializeTransferFeeConfigInstructionDataDecoder;
exports.getInitializeTransferFeeConfigInstructionDataEncoder = getInitializeTransferFeeConfigInstructionDataEncoder;
exports.getInitializeTransferFeeConfigTransferFeeDiscriminatorBytes = getInitializeTransferFeeConfigTransferFeeDiscriminatorBytes;
exports.getInitializeTransferHookDiscriminatorBytes = getInitializeTransferHookDiscriminatorBytes;
exports.getInitializeTransferHookInstruction = getInitializeTransferHookInstruction;
exports.getInitializeTransferHookInstructionDataCodec = getInitializeTransferHookInstructionDataCodec;
exports.getInitializeTransferHookInstructionDataDecoder = getInitializeTransferHookInstructionDataDecoder;
exports.getInitializeTransferHookInstructionDataEncoder = getInitializeTransferHookInstructionDataEncoder;
exports.getInitializeTransferHookTransferHookDiscriminatorBytes = getInitializeTransferHookTransferHookDiscriminatorBytes;
exports.getMintCodec = getMintCodec;
exports.getMintDecoder = getMintDecoder;
exports.getMintEncoder = getMintEncoder;
exports.getMintSize = getMintSize;
exports.getMintToCheckedDiscriminatorBytes = getMintToCheckedDiscriminatorBytes;
exports.getMintToCheckedInstruction = getMintToCheckedInstruction;
exports.getMintToCheckedInstructionDataCodec = getMintToCheckedInstructionDataCodec;
exports.getMintToCheckedInstructionDataDecoder = getMintToCheckedInstructionDataDecoder;
exports.getMintToCheckedInstructionDataEncoder = getMintToCheckedInstructionDataEncoder;
exports.getMintToDiscriminatorBytes = getMintToDiscriminatorBytes;
exports.getMintToInstruction = getMintToInstruction;
exports.getMintToInstructionDataCodec = getMintToInstructionDataCodec;
exports.getMintToInstructionDataDecoder = getMintToInstructionDataDecoder;
exports.getMintToInstructionDataEncoder = getMintToInstructionDataEncoder;
exports.getMultisigCodec = getMultisigCodec;
exports.getMultisigDecoder = getMultisigDecoder;
exports.getMultisigEncoder = getMultisigEncoder;
exports.getMultisigSize = getMultisigSize;
exports.getPostInitializeInstructionsForMintExtensions = getPostInitializeInstructionsForMintExtensions;
exports.getPostInitializeInstructionsForTokenExtensions = getPostInitializeInstructionsForTokenExtensions;
exports.getPreInitializeInstructionsForMintExtensions = getPreInitializeInstructionsForMintExtensions;
exports.getReallocateDiscriminatorBytes = getReallocateDiscriminatorBytes;
exports.getReallocateInstruction = getReallocateInstruction;
exports.getReallocateInstructionDataCodec = getReallocateInstructionDataCodec;
exports.getReallocateInstructionDataDecoder = getReallocateInstructionDataDecoder;
exports.getReallocateInstructionDataEncoder = getReallocateInstructionDataEncoder;
exports.getRecoverNestedAssociatedTokenDiscriminatorBytes = getRecoverNestedAssociatedTokenDiscriminatorBytes;
exports.getRecoverNestedAssociatedTokenInstruction = getRecoverNestedAssociatedTokenInstruction;
exports.getRecoverNestedAssociatedTokenInstructionAsync = getRecoverNestedAssociatedTokenInstructionAsync;
exports.getRecoverNestedAssociatedTokenInstructionDataCodec = getRecoverNestedAssociatedTokenInstructionDataCodec;
exports.getRecoverNestedAssociatedTokenInstructionDataDecoder = getRecoverNestedAssociatedTokenInstructionDataDecoder;
exports.getRecoverNestedAssociatedTokenInstructionDataEncoder = getRecoverNestedAssociatedTokenInstructionDataEncoder;
exports.getRemoveTokenMetadataKeyDiscriminatorBytes = getRemoveTokenMetadataKeyDiscriminatorBytes;
exports.getRemoveTokenMetadataKeyInstruction = getRemoveTokenMetadataKeyInstruction;
exports.getRemoveTokenMetadataKeyInstructionDataCodec = getRemoveTokenMetadataKeyInstructionDataCodec;
exports.getRemoveTokenMetadataKeyInstructionDataDecoder = getRemoveTokenMetadataKeyInstructionDataDecoder;
exports.getRemoveTokenMetadataKeyInstructionDataEncoder = getRemoveTokenMetadataKeyInstructionDataEncoder;
exports.getRevokeDiscriminatorBytes = getRevokeDiscriminatorBytes;
exports.getRevokeInstruction = getRevokeInstruction;
exports.getRevokeInstructionDataCodec = getRevokeInstructionDataCodec;
exports.getRevokeInstructionDataDecoder = getRevokeInstructionDataDecoder;
exports.getRevokeInstructionDataEncoder = getRevokeInstructionDataEncoder;
exports.getSetAuthorityDiscriminatorBytes = getSetAuthorityDiscriminatorBytes;
exports.getSetAuthorityInstruction = getSetAuthorityInstruction;
exports.getSetAuthorityInstructionDataCodec = getSetAuthorityInstructionDataCodec;
exports.getSetAuthorityInstructionDataDecoder = getSetAuthorityInstructionDataDecoder;
exports.getSetAuthorityInstructionDataEncoder = getSetAuthorityInstructionDataEncoder;
exports.getSetTransferFeeDiscriminatorBytes = getSetTransferFeeDiscriminatorBytes;
exports.getSetTransferFeeInstruction = getSetTransferFeeInstruction;
exports.getSetTransferFeeInstructionDataCodec = getSetTransferFeeInstructionDataCodec;
exports.getSetTransferFeeInstructionDataDecoder = getSetTransferFeeInstructionDataDecoder;
exports.getSetTransferFeeInstructionDataEncoder = getSetTransferFeeInstructionDataEncoder;
exports.getSetTransferFeeTransferFeeDiscriminatorBytes = getSetTransferFeeTransferFeeDiscriminatorBytes;
exports.getSyncNativeDiscriminatorBytes = getSyncNativeDiscriminatorBytes;
exports.getSyncNativeInstruction = getSyncNativeInstruction;
exports.getSyncNativeInstructionDataCodec = getSyncNativeInstructionDataCodec;
exports.getSyncNativeInstructionDataDecoder = getSyncNativeInstructionDataDecoder;
exports.getSyncNativeInstructionDataEncoder = getSyncNativeInstructionDataEncoder;
exports.getThawAccountDiscriminatorBytes = getThawAccountDiscriminatorBytes;
exports.getThawAccountInstruction = getThawAccountInstruction;
exports.getThawAccountInstructionDataCodec = getThawAccountInstructionDataCodec;
exports.getThawAccountInstructionDataDecoder = getThawAccountInstructionDataDecoder;
exports.getThawAccountInstructionDataEncoder = getThawAccountInstructionDataEncoder;
exports.getToken2022ErrorMessage = getToken2022ErrorMessage;
exports.getTokenCodec = getTokenCodec;
exports.getTokenDecoder = getTokenDecoder;
exports.getTokenEncoder = getTokenEncoder;
exports.getTokenMetadataFieldCodec = getTokenMetadataFieldCodec;
exports.getTokenMetadataFieldDecoder = getTokenMetadataFieldDecoder;
exports.getTokenMetadataFieldEncoder = getTokenMetadataFieldEncoder;
exports.getTokenSize = getTokenSize;
exports.getTransferCheckedDiscriminatorBytes = getTransferCheckedDiscriminatorBytes;
exports.getTransferCheckedInstruction = getTransferCheckedInstruction;
exports.getTransferCheckedInstructionDataCodec = getTransferCheckedInstructionDataCodec;
exports.getTransferCheckedInstructionDataDecoder = getTransferCheckedInstructionDataDecoder;
exports.getTransferCheckedInstructionDataEncoder = getTransferCheckedInstructionDataEncoder;
exports.getTransferCheckedWithFeeDiscriminatorBytes = getTransferCheckedWithFeeDiscriminatorBytes;
exports.getTransferCheckedWithFeeInstruction = getTransferCheckedWithFeeInstruction;
exports.getTransferCheckedWithFeeInstructionDataCodec = getTransferCheckedWithFeeInstructionDataCodec;
exports.getTransferCheckedWithFeeInstructionDataDecoder = getTransferCheckedWithFeeInstructionDataDecoder;
exports.getTransferCheckedWithFeeInstructionDataEncoder = getTransferCheckedWithFeeInstructionDataEncoder;
exports.getTransferCheckedWithFeeTransferFeeDiscriminatorBytes = getTransferCheckedWithFeeTransferFeeDiscriminatorBytes;
exports.getTransferDiscriminatorBytes = getTransferDiscriminatorBytes;
exports.getTransferFeeCodec = getTransferFeeCodec;
exports.getTransferFeeDecoder = getTransferFeeDecoder;
exports.getTransferFeeEncoder = getTransferFeeEncoder;
exports.getTransferInstruction = getTransferInstruction;
exports.getTransferInstructionDataCodec = getTransferInstructionDataCodec;
exports.getTransferInstructionDataDecoder = getTransferInstructionDataDecoder;
exports.getTransferInstructionDataEncoder = getTransferInstructionDataEncoder;
exports.getUiAmountToAmountDiscriminatorBytes = getUiAmountToAmountDiscriminatorBytes;
exports.getUiAmountToAmountInstruction = getUiAmountToAmountInstruction;
exports.getUiAmountToAmountInstructionDataCodec = getUiAmountToAmountInstructionDataCodec;
exports.getUiAmountToAmountInstructionDataDecoder = getUiAmountToAmountInstructionDataDecoder;
exports.getUiAmountToAmountInstructionDataEncoder = getUiAmountToAmountInstructionDataEncoder;
exports.getUpdateConfidentialTransferMintConfidentialTransferDiscriminatorBytes = getUpdateConfidentialTransferMintConfidentialTransferDiscriminatorBytes;
exports.getUpdateConfidentialTransferMintDiscriminatorBytes = getUpdateConfidentialTransferMintDiscriminatorBytes;
exports.getUpdateConfidentialTransferMintInstruction = getUpdateConfidentialTransferMintInstruction;
exports.getUpdateConfidentialTransferMintInstructionDataCodec = getUpdateConfidentialTransferMintInstructionDataCodec;
exports.getUpdateConfidentialTransferMintInstructionDataDecoder = getUpdateConfidentialTransferMintInstructionDataDecoder;
exports.getUpdateConfidentialTransferMintInstructionDataEncoder = getUpdateConfidentialTransferMintInstructionDataEncoder;
exports.getUpdateDefaultAccountStateDefaultAccountStateDiscriminatorBytes = getUpdateDefaultAccountStateDefaultAccountStateDiscriminatorBytes;
exports.getUpdateDefaultAccountStateDiscriminatorBytes = getUpdateDefaultAccountStateDiscriminatorBytes;
exports.getUpdateDefaultAccountStateInstruction = getUpdateDefaultAccountStateInstruction;
exports.getUpdateDefaultAccountStateInstructionDataCodec = getUpdateDefaultAccountStateInstructionDataCodec;
exports.getUpdateDefaultAccountStateInstructionDataDecoder = getUpdateDefaultAccountStateInstructionDataDecoder;
exports.getUpdateDefaultAccountStateInstructionDataEncoder = getUpdateDefaultAccountStateInstructionDataEncoder;
exports.getUpdateGroupMemberPointerDiscriminatorBytes = getUpdateGroupMemberPointerDiscriminatorBytes;
exports.getUpdateGroupMemberPointerGroupMemberPointerDiscriminatorBytes = getUpdateGroupMemberPointerGroupMemberPointerDiscriminatorBytes;
exports.getUpdateGroupMemberPointerInstruction = getUpdateGroupMemberPointerInstruction;
exports.getUpdateGroupMemberPointerInstructionDataCodec = getUpdateGroupMemberPointerInstructionDataCodec;
exports.getUpdateGroupMemberPointerInstructionDataDecoder = getUpdateGroupMemberPointerInstructionDataDecoder;
exports.getUpdateGroupMemberPointerInstructionDataEncoder = getUpdateGroupMemberPointerInstructionDataEncoder;
exports.getUpdateGroupPointerDiscriminatorBytes = getUpdateGroupPointerDiscriminatorBytes;
exports.getUpdateGroupPointerGroupPointerDiscriminatorBytes = getUpdateGroupPointerGroupPointerDiscriminatorBytes;
exports.getUpdateGroupPointerInstruction = getUpdateGroupPointerInstruction;
exports.getUpdateGroupPointerInstructionDataCodec = getUpdateGroupPointerInstructionDataCodec;
exports.getUpdateGroupPointerInstructionDataDecoder = getUpdateGroupPointerInstructionDataDecoder;
exports.getUpdateGroupPointerInstructionDataEncoder = getUpdateGroupPointerInstructionDataEncoder;
exports.getUpdateMetadataPointerDiscriminatorBytes = getUpdateMetadataPointerDiscriminatorBytes;
exports.getUpdateMetadataPointerInstruction = getUpdateMetadataPointerInstruction;
exports.getUpdateMetadataPointerInstructionDataCodec = getUpdateMetadataPointerInstructionDataCodec;
exports.getUpdateMetadataPointerInstructionDataDecoder = getUpdateMetadataPointerInstructionDataDecoder;
exports.getUpdateMetadataPointerInstructionDataEncoder = getUpdateMetadataPointerInstructionDataEncoder;
exports.getUpdateMetadataPointerMetadataPointerDiscriminatorBytes = getUpdateMetadataPointerMetadataPointerDiscriminatorBytes;
exports.getUpdateRateInterestBearingMintDiscriminatorBytes = getUpdateRateInterestBearingMintDiscriminatorBytes;
exports.getUpdateRateInterestBearingMintInstruction = getUpdateRateInterestBearingMintInstruction;
exports.getUpdateRateInterestBearingMintInstructionDataCodec = getUpdateRateInterestBearingMintInstructionDataCodec;
exports.getUpdateRateInterestBearingMintInstructionDataDecoder = getUpdateRateInterestBearingMintInstructionDataDecoder;
exports.getUpdateRateInterestBearingMintInstructionDataEncoder = getUpdateRateInterestBearingMintInstructionDataEncoder;
exports.getUpdateRateInterestBearingMintInterestBearingMintDiscriminatorBytes = getUpdateRateInterestBearingMintInterestBearingMintDiscriminatorBytes;
exports.getUpdateTokenGroupMaxSizeDiscriminatorBytes = getUpdateTokenGroupMaxSizeDiscriminatorBytes;
exports.getUpdateTokenGroupMaxSizeInstruction = getUpdateTokenGroupMaxSizeInstruction;
exports.getUpdateTokenGroupMaxSizeInstructionDataCodec = getUpdateTokenGroupMaxSizeInstructionDataCodec;
exports.getUpdateTokenGroupMaxSizeInstructionDataDecoder = getUpdateTokenGroupMaxSizeInstructionDataDecoder;
exports.getUpdateTokenGroupMaxSizeInstructionDataEncoder = getUpdateTokenGroupMaxSizeInstructionDataEncoder;
exports.getUpdateTokenGroupUpdateAuthorityDiscriminatorBytes = getUpdateTokenGroupUpdateAuthorityDiscriminatorBytes;
exports.getUpdateTokenGroupUpdateAuthorityInstruction = getUpdateTokenGroupUpdateAuthorityInstruction;
exports.getUpdateTokenGroupUpdateAuthorityInstructionDataCodec = getUpdateTokenGroupUpdateAuthorityInstructionDataCodec;
exports.getUpdateTokenGroupUpdateAuthorityInstructionDataDecoder = getUpdateTokenGroupUpdateAuthorityInstructionDataDecoder;
exports.getUpdateTokenGroupUpdateAuthorityInstructionDataEncoder = getUpdateTokenGroupUpdateAuthorityInstructionDataEncoder;
exports.getUpdateTokenMetadataFieldDiscriminatorBytes = getUpdateTokenMetadataFieldDiscriminatorBytes;
exports.getUpdateTokenMetadataFieldInstruction = getUpdateTokenMetadataFieldInstruction;
exports.getUpdateTokenMetadataFieldInstructionDataCodec = getUpdateTokenMetadataFieldInstructionDataCodec;
exports.getUpdateTokenMetadataFieldInstructionDataDecoder = getUpdateTokenMetadataFieldInstructionDataDecoder;
exports.getUpdateTokenMetadataFieldInstructionDataEncoder = getUpdateTokenMetadataFieldInstructionDataEncoder;
exports.getUpdateTokenMetadataUpdateAuthorityDiscriminatorBytes = getUpdateTokenMetadataUpdateAuthorityDiscriminatorBytes;
exports.getUpdateTokenMetadataUpdateAuthorityInstruction = getUpdateTokenMetadataUpdateAuthorityInstruction;
exports.getUpdateTokenMetadataUpdateAuthorityInstructionDataCodec = getUpdateTokenMetadataUpdateAuthorityInstructionDataCodec;
exports.getUpdateTokenMetadataUpdateAuthorityInstructionDataDecoder = getUpdateTokenMetadataUpdateAuthorityInstructionDataDecoder;
exports.getUpdateTokenMetadataUpdateAuthorityInstructionDataEncoder = getUpdateTokenMetadataUpdateAuthorityInstructionDataEncoder;
exports.getUpdateTransferHookDiscriminatorBytes = getUpdateTransferHookDiscriminatorBytes;
exports.getUpdateTransferHookInstruction = getUpdateTransferHookInstruction;
exports.getUpdateTransferHookInstructionDataCodec = getUpdateTransferHookInstructionDataCodec;
exports.getUpdateTransferHookInstructionDataDecoder = getUpdateTransferHookInstructionDataDecoder;
exports.getUpdateTransferHookInstructionDataEncoder = getUpdateTransferHookInstructionDataEncoder;
exports.getUpdateTransferHookTransferHookDiscriminatorBytes = getUpdateTransferHookTransferHookDiscriminatorBytes;
exports.getWithdrawExcessLamportsDiscriminatorBytes = getWithdrawExcessLamportsDiscriminatorBytes;
exports.getWithdrawExcessLamportsInstruction = getWithdrawExcessLamportsInstruction;
exports.getWithdrawExcessLamportsInstructionDataCodec = getWithdrawExcessLamportsInstructionDataCodec;
exports.getWithdrawExcessLamportsInstructionDataDecoder = getWithdrawExcessLamportsInstructionDataDecoder;
exports.getWithdrawExcessLamportsInstructionDataEncoder = getWithdrawExcessLamportsInstructionDataEncoder;
exports.getWithdrawWithheldTokensFromAccountsDiscriminatorBytes = getWithdrawWithheldTokensFromAccountsDiscriminatorBytes;
exports.getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes = getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes;
exports.getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeDiscriminatorBytes = getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeDiscriminatorBytes;
exports.getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction = getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction;
exports.getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataCodec = getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataCodec;
exports.getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataDecoder = getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataDecoder;
exports.getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataEncoder = getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataEncoder;
exports.getWithdrawWithheldTokensFromAccountsInstruction = getWithdrawWithheldTokensFromAccountsInstruction;
exports.getWithdrawWithheldTokensFromAccountsInstructionDataCodec = getWithdrawWithheldTokensFromAccountsInstructionDataCodec;
exports.getWithdrawWithheldTokensFromAccountsInstructionDataDecoder = getWithdrawWithheldTokensFromAccountsInstructionDataDecoder;
exports.getWithdrawWithheldTokensFromAccountsInstructionDataEncoder = getWithdrawWithheldTokensFromAccountsInstructionDataEncoder;
exports.getWithdrawWithheldTokensFromAccountsTransferFeeDiscriminatorBytes = getWithdrawWithheldTokensFromAccountsTransferFeeDiscriminatorBytes;
exports.getWithdrawWithheldTokensFromMintDiscriminatorBytes = getWithdrawWithheldTokensFromMintDiscriminatorBytes;
exports.getWithdrawWithheldTokensFromMintForConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes = getWithdrawWithheldTokensFromMintForConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes;
exports.getWithdrawWithheldTokensFromMintForConfidentialTransferFeeDiscriminatorBytes = getWithdrawWithheldTokensFromMintForConfidentialTransferFeeDiscriminatorBytes;
exports.getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction = getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction;
exports.getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataCodec = getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataCodec;
exports.getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataDecoder = getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataDecoder;
exports.getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataEncoder = getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataEncoder;
exports.getWithdrawWithheldTokensFromMintInstruction = getWithdrawWithheldTokensFromMintInstruction;
exports.getWithdrawWithheldTokensFromMintInstructionDataCodec = getWithdrawWithheldTokensFromMintInstructionDataCodec;
exports.getWithdrawWithheldTokensFromMintInstructionDataDecoder = getWithdrawWithheldTokensFromMintInstructionDataDecoder;
exports.getWithdrawWithheldTokensFromMintInstructionDataEncoder = getWithdrawWithheldTokensFromMintInstructionDataEncoder;
exports.getWithdrawWithheldTokensFromMintTransferFeeDiscriminatorBytes = getWithdrawWithheldTokensFromMintTransferFeeDiscriminatorBytes;
exports.identifyAssociatedTokenInstruction = identifyAssociatedTokenInstruction;
exports.identifyToken2022Account = identifyToken2022Account;
exports.identifyToken2022Instruction = identifyToken2022Instruction;
exports.isAssociatedTokenError = isAssociatedTokenError;
exports.isExtension = isExtension;
exports.isToken2022Error = isToken2022Error;
exports.isTokenMetadataField = isTokenMetadataField;
exports.parseAmountToUiAmountInstruction = parseAmountToUiAmountInstruction;
exports.parseApplyConfidentialPendingBalanceInstruction = parseApplyConfidentialPendingBalanceInstruction;
exports.parseApproveCheckedInstruction = parseApproveCheckedInstruction;
exports.parseApproveConfidentialTransferAccountInstruction = parseApproveConfidentialTransferAccountInstruction;
exports.parseApproveInstruction = parseApproveInstruction;
exports.parseBurnCheckedInstruction = parseBurnCheckedInstruction;
exports.parseBurnInstruction = parseBurnInstruction;
exports.parseCloseAccountInstruction = parseCloseAccountInstruction;
exports.parseConfidentialDepositInstruction = parseConfidentialDepositInstruction;
exports.parseConfidentialTransferInstruction = parseConfidentialTransferInstruction;
exports.parseConfidentialTransferWithFeeInstruction = parseConfidentialTransferWithFeeInstruction;
exports.parseConfidentialWithdrawInstruction = parseConfidentialWithdrawInstruction;
exports.parseConfigureConfidentialTransferAccountInstruction = parseConfigureConfidentialTransferAccountInstruction;
exports.parseCreateAssociatedTokenIdempotentInstruction = parseCreateAssociatedTokenIdempotentInstruction;
exports.parseCreateAssociatedTokenInstruction = parseCreateAssociatedTokenInstruction;
exports.parseCreateNativeMintInstruction = parseCreateNativeMintInstruction;
exports.parseDisableConfidentialCreditsInstruction = parseDisableConfidentialCreditsInstruction;
exports.parseDisableCpiGuardInstruction = parseDisableCpiGuardInstruction;
exports.parseDisableHarvestToMintInstruction = parseDisableHarvestToMintInstruction;
exports.parseDisableMemoTransfersInstruction = parseDisableMemoTransfersInstruction;
exports.parseDisableNonConfidentialCreditsInstruction = parseDisableNonConfidentialCreditsInstruction;
exports.parseEmitTokenMetadataInstruction = parseEmitTokenMetadataInstruction;
exports.parseEmptyConfidentialTransferAccountInstruction = parseEmptyConfidentialTransferAccountInstruction;
exports.parseEnableConfidentialCreditsInstruction = parseEnableConfidentialCreditsInstruction;
exports.parseEnableCpiGuardInstruction = parseEnableCpiGuardInstruction;
exports.parseEnableHarvestToMintInstruction = parseEnableHarvestToMintInstruction;
exports.parseEnableMemoTransfersInstruction = parseEnableMemoTransfersInstruction;
exports.parseEnableNonConfidentialCreditsInstruction = parseEnableNonConfidentialCreditsInstruction;
exports.parseFreezeAccountInstruction = parseFreezeAccountInstruction;
exports.parseGetAccountDataSizeInstruction = parseGetAccountDataSizeInstruction;
exports.parseHarvestWithheldTokensToMintForConfidentialTransferFeeInstruction = parseHarvestWithheldTokensToMintForConfidentialTransferFeeInstruction;
exports.parseHarvestWithheldTokensToMintInstruction = parseHarvestWithheldTokensToMintInstruction;
exports.parseInitializeAccount2Instruction = parseInitializeAccount2Instruction;
exports.parseInitializeAccount3Instruction = parseInitializeAccount3Instruction;
exports.parseInitializeAccountInstruction = parseInitializeAccountInstruction;
exports.parseInitializeConfidentialTransferFeeInstruction = parseInitializeConfidentialTransferFeeInstruction;
exports.parseInitializeConfidentialTransferMintInstruction = parseInitializeConfidentialTransferMintInstruction;
exports.parseInitializeDefaultAccountStateInstruction = parseInitializeDefaultAccountStateInstruction;
exports.parseInitializeGroupMemberPointerInstruction = parseInitializeGroupMemberPointerInstruction;
exports.parseInitializeGroupPointerInstruction = parseInitializeGroupPointerInstruction;
exports.parseInitializeImmutableOwnerInstruction = parseInitializeImmutableOwnerInstruction;
exports.parseInitializeInterestBearingMintInstruction = parseInitializeInterestBearingMintInstruction;
exports.parseInitializeMetadataPointerInstruction = parseInitializeMetadataPointerInstruction;
exports.parseInitializeMint2Instruction = parseInitializeMint2Instruction;
exports.parseInitializeMintCloseAuthorityInstruction = parseInitializeMintCloseAuthorityInstruction;
exports.parseInitializeMintInstruction = parseInitializeMintInstruction;
exports.parseInitializeMultisig2Instruction = parseInitializeMultisig2Instruction;
exports.parseInitializeMultisigInstruction = parseInitializeMultisigInstruction;
exports.parseInitializeNonTransferableMintInstruction = parseInitializeNonTransferableMintInstruction;
exports.parseInitializePermanentDelegateInstruction = parseInitializePermanentDelegateInstruction;
exports.parseInitializeTokenGroupInstruction = parseInitializeTokenGroupInstruction;
exports.parseInitializeTokenGroupMemberInstruction = parseInitializeTokenGroupMemberInstruction;
exports.parseInitializeTokenMetadataInstruction = parseInitializeTokenMetadataInstruction;
exports.parseInitializeTransferFeeConfigInstruction = parseInitializeTransferFeeConfigInstruction;
exports.parseInitializeTransferHookInstruction = parseInitializeTransferHookInstruction;
exports.parseMintToCheckedInstruction = parseMintToCheckedInstruction;
exports.parseMintToInstruction = parseMintToInstruction;
exports.parseReallocateInstruction = parseReallocateInstruction;
exports.parseRecoverNestedAssociatedTokenInstruction = parseRecoverNestedAssociatedTokenInstruction;
exports.parseRemoveTokenMetadataKeyInstruction = parseRemoveTokenMetadataKeyInstruction;
exports.parseRevokeInstruction = parseRevokeInstruction;
exports.parseSetAuthorityInstruction = parseSetAuthorityInstruction;
exports.parseSetTransferFeeInstruction = parseSetTransferFeeInstruction;
exports.parseSyncNativeInstruction = parseSyncNativeInstruction;
exports.parseThawAccountInstruction = parseThawAccountInstruction;
exports.parseTransferCheckedInstruction = parseTransferCheckedInstruction;
exports.parseTransferCheckedWithFeeInstruction = parseTransferCheckedWithFeeInstruction;
exports.parseTransferInstruction = parseTransferInstruction;
exports.parseUiAmountToAmountInstruction = parseUiAmountToAmountInstruction;
exports.parseUpdateConfidentialTransferMintInstruction = parseUpdateConfidentialTransferMintInstruction;
exports.parseUpdateDefaultAccountStateInstruction = parseUpdateDefaultAccountStateInstruction;
exports.parseUpdateGroupMemberPointerInstruction = parseUpdateGroupMemberPointerInstruction;
exports.parseUpdateGroupPointerInstruction = parseUpdateGroupPointerInstruction;
exports.parseUpdateMetadataPointerInstruction = parseUpdateMetadataPointerInstruction;
exports.parseUpdateRateInterestBearingMintInstruction = parseUpdateRateInterestBearingMintInstruction;
exports.parseUpdateTokenGroupMaxSizeInstruction = parseUpdateTokenGroupMaxSizeInstruction;
exports.parseUpdateTokenGroupUpdateAuthorityInstruction = parseUpdateTokenGroupUpdateAuthorityInstruction;
exports.parseUpdateTokenMetadataFieldInstruction = parseUpdateTokenMetadataFieldInstruction;
exports.parseUpdateTokenMetadataUpdateAuthorityInstruction = parseUpdateTokenMetadataUpdateAuthorityInstruction;
exports.parseUpdateTransferHookInstruction = parseUpdateTransferHookInstruction;
exports.parseWithdrawExcessLamportsInstruction = parseWithdrawExcessLamportsInstruction;
exports.parseWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction = parseWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction;
exports.parseWithdrawWithheldTokensFromAccountsInstruction = parseWithdrawWithheldTokensFromAccountsInstruction;
exports.parseWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction = parseWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction;
exports.parseWithdrawWithheldTokensFromMintInstruction = parseWithdrawWithheldTokensFromMintInstruction;
exports.tokenMetadataField = tokenMetadataField;
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map