"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  DEFAULT_ADDRESS: () => DEFAULT_ADDRESS,
  DEFAULT_FUNDER: () => DEFAULT_FUNDER,
  DEFAULT_NATIVE_MINT_WRAPPING_STRATEGY: () => DEFAULT_NATIVE_MINT_WRAPPING_STRATEGY,
  DEFAULT_SLIPPAGE_TOLERANCE_BPS: () => DEFAULT_SLIPPAGE_TOLERANCE_BPS,
  DEFAULT_WHIRLPOOLS_CONFIG_ADDRESSES: () => DEFAULT_WHIRLPOOLS_CONFIG_ADDRESSES,
  DEFAULT_WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS: () => DEFAULT_WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS,
  FUNDER: () => FUNDER,
  NATIVE_MINT_WRAPPING_STRATEGY: () => NATIVE_MINT_WRAPPING_STRATEGY,
  SLIPPAGE_TOLERANCE_BPS: () => SLIPPAGE_TOLERANCE_BPS,
  SPLASH_POOL_TICK_SPACING: () => SPLASH_POOL_TICK_SPACING,
  WHIRLPOOLS_CONFIG_ADDRESS: () => WHIRLPOOLS_CONFIG_ADDRESS,
  WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS: () => WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS,
  closePositionInstructions: () => closePositionInstructions,
  createConcentratedLiquidityPoolInstructions: () => createConcentratedLiquidityPoolInstructions,
  createSplashPoolInstructions: () => createSplashPoolInstructions,
  decreaseLiquidityInstructions: () => decreaseLiquidityInstructions,
  fetchConcentratedLiquidityPool: () => fetchConcentratedLiquidityPool,
  fetchPositionsForOwner: () => fetchPositionsForOwner,
  fetchPositionsInWhirlpool: () => fetchPositionsInWhirlpool,
  fetchSplashPool: () => fetchSplashPool,
  fetchWhirlpoolsByTokenPair: () => fetchWhirlpoolsByTokenPair,
  harvestPositionInstructions: () => harvestPositionInstructions,
  increaseLiquidityInstructions: () => increaseLiquidityInstructions,
  openFullRangePositionInstructions: () => openFullRangePositionInstructions,
  openPositionInstructions: () => openPositionInstructions,
  resetConfiguration: () => resetConfiguration,
  setDefaultFunder: () => setDefaultFunder,
  setDefaultSlippageToleranceBps: () => setDefaultSlippageToleranceBps,
  setNativeMintWrappingStrategy: () => setNativeMintWrappingStrategy,
  setWhirlpoolsConfig: () => setWhirlpoolsConfig,
  swapInstructions: () => swapInstructions
});
module.exports = __toCommonJS(src_exports);

// src/config.ts
var import_whirlpools_client = require("@orca-so/whirlpools-client");
var import_web3 = require("@solana/web3.js");
var DEFAULT_ADDRESS = (0, import_web3.address)("11111111111111111111111111111111");
var DEFAULT_WHIRLPOOLS_CONFIG_ADDRESSES = {
  solanaMainnet: (0, import_web3.address)("2LecshUwdy9xi7meFgHtFJQNSKk4KdTrcpvaB56dP2NQ"),
  solanaDevnet: (0, import_web3.address)("FcrweFY1G9HJAHG5inkGB6pKg1HZ6x9UC2WioAfWrGkR"),
  eclipseMainnet: (0, import_web3.address)("FVG4oDbGv16hqTUbovjyGmtYikn6UBEnazz6RVDMEFwv"),
  eclipseTestnet: (0, import_web3.address)("FPydDjRdZu9sT7HVd6ANhfjh85KLq21Pefr5YWWMRPFp")
};
var DEFAULT_WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS = (0, import_web3.address)(
  "777H5H3Tp9U11uRVRzFwM8BinfiakbaLT8vQpeuhvEiH"
);
var WHIRLPOOLS_CONFIG_ADDRESS = DEFAULT_WHIRLPOOLS_CONFIG_ADDRESSES.solanaMainnet;
var WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS = DEFAULT_WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS;
async function setWhirlpoolsConfig(config) {
  if ((0, import_web3.isAddress)(config)) {
    WHIRLPOOLS_CONFIG_ADDRESS = config;
  } else {
    WHIRLPOOLS_CONFIG_ADDRESS = DEFAULT_WHIRLPOOLS_CONFIG_ADDRESSES[config];
  }
  WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS = await (0, import_whirlpools_client.getWhirlpoolsConfigExtensionAddress)(WHIRLPOOLS_CONFIG_ADDRESS).then(
    (x) => x[0]
  );
}
var SPLASH_POOL_TICK_SPACING = 32896;
var DEFAULT_FUNDER = (0, import_web3.createNoopSigner)(DEFAULT_ADDRESS);
var FUNDER = DEFAULT_FUNDER;
function setDefaultFunder(funder) {
  if (typeof funder === "string") {
    FUNDER = (0, import_web3.createNoopSigner)(funder);
  } else {
    FUNDER = funder ?? (0, import_web3.createNoopSigner)(DEFAULT_ADDRESS);
  }
}
var DEFAULT_SLIPPAGE_TOLERANCE_BPS = 100;
var SLIPPAGE_TOLERANCE_BPS = DEFAULT_SLIPPAGE_TOLERANCE_BPS;
function setDefaultSlippageToleranceBps(slippageToleranceBps) {
  SLIPPAGE_TOLERANCE_BPS = Math.floor(slippageToleranceBps);
}
var DEFAULT_NATIVE_MINT_WRAPPING_STRATEGY = "keypair";
var NATIVE_MINT_WRAPPING_STRATEGY = DEFAULT_NATIVE_MINT_WRAPPING_STRATEGY;
function setNativeMintWrappingStrategy(strategy) {
  NATIVE_MINT_WRAPPING_STRATEGY = strategy;
}
function resetConfiguration() {
  WHIRLPOOLS_CONFIG_ADDRESS = DEFAULT_WHIRLPOOLS_CONFIG_ADDRESSES.solanaMainnet;
  WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS = DEFAULT_WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS;
  FUNDER = DEFAULT_FUNDER;
  SLIPPAGE_TOLERANCE_BPS = DEFAULT_SLIPPAGE_TOLERANCE_BPS;
  NATIVE_MINT_WRAPPING_STRATEGY = DEFAULT_NATIVE_MINT_WRAPPING_STRATEGY;
}

// src/createPool.ts
var import_whirlpools_client2 = require("@orca-so/whirlpools-client");
var import_web33 = require("@solana/web3.js");

// ../../node_modules/@solana/errors/dist/index.node.mjs
var SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = 1;
var SOLANA_ERROR__INVALID_NONCE = 2;
var SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = 3;
var SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = 4;
var SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = 5;
var SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = 6;
var SOLANA_ERROR__MALFORMED_BIGINT_STRING = 7;
var SOLANA_ERROR__MALFORMED_NUMBER_STRING = 8;
var SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = 9;
var SOLANA_ERROR__JSON_RPC__PARSE_ERROR = -32700;
var SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = -32603;
var SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = -32602;
var SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = -32601;
var SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = -32600;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = -32016;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = -32015;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = -32014;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = -32013;
var SOLANA_ERROR__JSON_RPC__SCAN_ERROR = -32012;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = -32011;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = -32010;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = -32009;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = -32008;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = -32007;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = -32006;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = -32005;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = -32004;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = -32003;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = -32002;
var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = -32001;
var SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = 28e5;
var SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = 2800001;
var SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = 2800002;
var SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = 2800003;
var SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = 2800004;
var SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = 2800005;
var SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = 2800006;
var SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = 2800007;
var SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = 2800008;
var SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = 2800009;
var SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = 2800010;
var SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = 323e4;
var SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = 32300001;
var SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = 3230002;
var SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = 3230003;
var SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = 3230004;
var SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = 361e4;
var SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = 3610001;
var SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = 3610002;
var SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = 3610003;
var SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = 3610004;
var SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = 3610005;
var SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = 3610006;
var SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = 3610007;
var SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = 3611e3;
var SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = 3704e3;
var SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = 3704001;
var SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = 3704002;
var SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = 3704003;
var SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = 3704004;
var SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = 4128e3;
var SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = 4128001;
var SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = 4128002;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = 4615e3;
var SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = 4615001;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = 4615002;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = 4615003;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = 4615004;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = 4615005;
var SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = 4615006;
var SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = 4615007;
var SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = 4615008;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = 4615009;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = 4615010;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = 4615011;
var SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = 4615012;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = 4615013;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = 4615014;
var SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = 4615015;
var SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = 4615016;
var SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = 4615017;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = 4615018;
var SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = 4615019;
var SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = 4615020;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = 4615021;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = 4615022;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = 4615023;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 4615024;
var SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = 4615025;
var SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = 4615026;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = 4615027;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = 4615028;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = 4615029;
var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = 4615030;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = 4615031;
var SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = 4615032;
var SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = 4615033;
var SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = 4615034;
var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4615035;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = 4615036;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = 4615037;
var SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = 4615038;
var SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = 4615039;
var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = 4615040;
var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = 4615041;
var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = 4615042;
var SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = 4615043;
var SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = 4615044;
var SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = 4615045;
var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = 4615046;
var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = 4615047;
var SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = 4615048;
var SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = 4615049;
var SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = 4615050;
var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = 4615051;
var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = 4615052;
var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = 4615053;
var SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = 4615054;
var SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = 5508e3;
var SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = 5508001;
var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = 5508002;
var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = 5508003;
var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = 5508004;
var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = 5508005;
var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = 5508006;
var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = 5508007;
var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = 5508008;
var SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = 5508009;
var SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = 5508010;
var SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = 5508011;
var SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = 5663e3;
var SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = 5663001;
var SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = 5663002;
var SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = 5663003;
var SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = 5663004;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = 5663005;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = 5663006;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = 5663007;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = 5663008;
var SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = 5663009;
var SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = 5663010;
var SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = 5663011;
var SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = 5663012;
var SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = 5663013;
var SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE = 5663014;
var SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = 5663015;
var SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = 5663016;
var SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = 5663017;
var SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = 5663018;
var SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT = 5663019;
var SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = 705e4;
var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = 7050001;
var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = 7050002;
var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = 7050003;
var SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = 7050004;
var SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = 7050005;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = 7050006;
var SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = 7050007;
var SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = 7050008;
var SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = 7050009;
var SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = 7050010;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = 7050011;
var SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = 7050012;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = 7050013;
var SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = 7050014;
var SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = 7050015;
var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 7050016;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = 7050017;
var SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = 7050018;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = 7050019;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = 7050020;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = 7050021;
var SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = 7050022;
var SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = 7050023;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = 7050024;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = 7050025;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = 7050026;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = 7050027;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = 7050028;
var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = 7050029;
var SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = 7050030;
var SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = 7050031;
var SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = 7050032;
var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = 7050033;
var SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = 7050034;
var SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = 7050035;
var SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = 7050036;
var SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = 8078e3;
var SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = 8078001;
var SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = 8078002;
var SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = 8078003;
var SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = 8078004;
var SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = 8078005;
var SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = 8078006;
var SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = 8078007;
var SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = 8078008;
var SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = 8078009;
var SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = 8078010;
var SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = 8078011;
var SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = 8078012;
var SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = 8078013;
var SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = 8078014;
var SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = 8078015;
var SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = 8078016;
var SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = 8078017;
var SOLANA_ERROR__CODECS__INVALID_CONSTANT = 8078018;
var SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = 8078019;
var SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = 8078020;
var SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = 8078021;
var SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = 8078022;
var SOLANA_ERROR__RPC__INTEGER_OVERFLOW = 81e5;
var SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = 8100001;
var SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = 8100002;
var SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD = 8100003;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN = 819e4;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = 8190001;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED = 8190002;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED = 8190003;
var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT = 8190004;
var SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING = 99e5;
var SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE = 9900001;
var SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = 9900002;
var SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = 9900003;
var SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED = 9900004;
function encodeValue(value) {
  if (Array.isArray(value)) {
    const commaSeparatedValues = value.map(encodeValue).join(
      "%2C%20"
      /* ", " */
    );
    return "%5B" + commaSeparatedValues + /* "]" */
    "%5D";
  } else if (typeof value === "bigint") {
    return `${value}n`;
  } else {
    return encodeURIComponent(
      String(
        value != null && Object.getPrototypeOf(value) === null ? (
          // Plain objects with no prototype don't have a `toString` method.
          // Convert them before stringifying them.
          { ...value }
        ) : value
      )
    );
  }
}
function encodeObjectContextEntry([key, value]) {
  return `${key}=${encodeValue(value)}`;
}
function encodeContextObject(context) {
  const searchParamsString = Object.entries(context).map(encodeObjectContextEntry).join("&");
  return Buffer.from(searchParamsString, "utf8").toString("base64");
}
var SolanaErrorMessages = {
  [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: "Account not found at address: $address",
  [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]: "Not all accounts were decoded. Encoded accounts found at addresses: $addresses.",
  [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: "Expected decoded account at address: $address",
  [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: "Failed to decode account data at address: $address",
  [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: "Accounts not found at addresses: $addresses",
  [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED]: "Unable to find a viable program address bump seed.",
  [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: "$putativeAddress is not a base58-encoded address.",
  [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]: "Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.",
  [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY]: "The `CryptoKey` must be an `Ed25519` public key.",
  [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE]: "Invalid seeds; point must fall off the Ed25519 curve.",
  [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA]: "Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].",
  [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]: "A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.",
  [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]: "The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.",
  [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]: "Expected program derived address bump to be in the range [0, 255], got: $bump.",
  [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER]: "Program address cannot end with PDA marker.",
  [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.",
  [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.",
  [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]: "The network has progressed past the last block for which this transaction could have been committed.",
  [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]: "Codec [$codecDescription] cannot decode empty byte arrays.",
  [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]: "Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.",
  [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]: "Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].",
  [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]: "Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].",
  [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]: "Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].",
  [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH]: "Encoder and decoder must either both be fixed-size or variable-size.",
  [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]: "Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.",
  [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH]: "Expected a fixed-size codec, got a variable-size one.",
  [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]: "Codec [$codecDescription] expected a positive byte length, got $bytesLength.",
  [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH]: "Expected a variable-size codec, got a fixed-size one.",
  [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]: "Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].",
  [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]: "Codec [$codecDescription] expected $expected bytes, got $bytesLength.",
  [SOLANA_ERROR__CODECS__INVALID_CONSTANT]: "Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].",
  [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]: "Invalid discriminated union variant. Expected one of [$variants], got $value.",
  [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]: "Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.",
  [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]: "Invalid literal union variant. Expected one of [$variants], got $value.",
  [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]: "Expected [$codecDescription] to have $expected items, got $actual.",
  [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: "Invalid value $value for base $base with alphabet $alphabet.",
  [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]: "Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.",
  [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]: "Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.",
  [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]: "Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.",
  [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]: "Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].",
  [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]: "Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.",
  [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED]: "No random values implementation could be found.",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED]: "instruction requires an uninitialized account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED]: "instruction tries to borrow reference for an account which is already borrowed",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: "instruction left account with an outstanding borrowed reference",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED]: "program other than the account's owner changed the size of the account data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL]: "account data too small for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE]: "instruction expected an executable account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT]: "An account does not have enough lamports to be rent-exempt",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW]: "Program arithmetic overflowed",
  [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: "Failed to serialize or deserialize account data: $encodedData",
  [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS]: "Builtin programs must consume compute units",
  [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH]: "Cross-program invocation call depth too deep",
  [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED]: "Computational budget exceeded",
  [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: "custom program error: #$code",
  [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX]: "instruction contains duplicate accounts",
  [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC]: "instruction modifications of multiply-passed account differ",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT]: "executable accounts must be rent exempt",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED]: "instruction changed executable accounts data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE]: "instruction changed the balance of an executable account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED]: "instruction changed executable bit of an account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED]: "instruction modified data of an account it does not own",
  [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND]: "instruction spent from the balance of an account it does not own",
  [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR]: "generic instruction error",
  [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER]: "Provided owner is not allowed",
  [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE]: "Account is immutable",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY]: "Incorrect authority provided",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID]: "incorrect program id for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS]: "insufficient funds for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA]: "invalid account data for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER]: "Invalid account owner",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT]: "invalid program argument",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR]: "program returned invalid error code",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA]: "invalid instruction data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC]: "Failed to reallocate account data",
  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS]: "Provided seeds do not result in a valid address",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED]: "Accounts data allocations exceeded the maximum allowed per transaction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED]: "Max accounts exceeded",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED]: "Max instruction trace length exceeded",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED]: "Length of the seed is too long for address generation",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT]: "An account required by the instruction is missing",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE]: "missing required signature for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID]: "instruction illegally modified the program id of an account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS]: "insufficient account keys for instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION]: "Cross-program invocation with unauthorized signer or writable account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE]: "Failed to create program execution environment",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE]: "Program failed to compile",
  [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE]: "Program failed to complete",
  [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED]: "instruction modified data of a read-only account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE]: "instruction changed the balance of a read-only account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED]: "Cross-program invocation reentrancy not allowed for this instruction",
  [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED]: "instruction modified rent epoch of an account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION]: "sum of account balances before and after instruction do not match",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT]: "instruction requires an initialized account",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: "",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID]: "Unsupported program id",
  [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR]: "Unsupported sysvar",
  [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: "The instruction does not have any accounts.",
  [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: "The instruction does not have any data.",
  [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]: "Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.",
  [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]: "Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.",
  [SOLANA_ERROR__INVALID_NONCE]: "The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`",
  [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]: "Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED]: "Invariant violation: This data publisher does not publish to the channel named `$channelName`. Supported channels include $supportedChannelNames.",
  [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE]: "Invariant violation: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING]: "Invariant violation: WebSocket message iterator is missing state storage. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]: "Invariant violation: Switch statement non-exhaustive. Received unexpected value `$unexpectedValue`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
  [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: "JSON-RPC error: Internal JSON-RPC error ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: "JSON-RPC error: Invalid method parameter(s) ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]: "JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]: "JSON-RPC error: The method does not exist / is not available ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]: "JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)",
  [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: "Minimum context slot has not been reached",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: "Node is unhealthy; behind by $numSlotsBehind slots",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT]: "No snapshot",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: "Transaction simulation failed",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE]: "Transaction history is not available from this node",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: "$__serverMessage",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH]: "Transaction signature length mismatch",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE]: "Transaction signature verification failure",
  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: "$__serverMessage",
  [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: "Key pair bytes must be of length 64, got $byteLength.",
  [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]: "Expected private key bytes with length 32. Actual length: $actualLength.",
  [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]: "Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.",
  [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY]: "The provided private key does not match the provided public key.",
  [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]: "Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.",
  [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE]: "Lamports value must be in the range [0, 2e64-1]",
  [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: "`$value` cannot be parsed as a `BigInt`",
  [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: "`$value` cannot be parsed as a `Number`",
  [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: "No nonce account could be found at address `$nonceAccountAddress`",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN]: "The notification name must end in 'Notifications' and the API must supply a subscription plan creator function for the notification '$notificationName'.",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED]: "WebSocket was closed before payload could be added to the send buffer",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED]: "WebSocket connection closed",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT]: "WebSocket failed to connect",
  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID]: "Failed to obtain a subscription id from the server",
  [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD]: "Could not find an API plan for RPC method: `$method`",
  [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]: "The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`.",
  [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: "HTTP error ($statusCode): $message",
  [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]: "HTTP header(s) forbidden: $headers. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.",
  [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]: "Multiple distinct signers were identified for address `$address`. Please ensure that you are using the same signer instance for each address.",
  [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]: "The provided value does not implement the `KeyPairSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]: "The provided value does not implement the `MessageModifyingSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]: "The provided value does not implement the `MessagePartialSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]: "The provided value does not implement any of the `MessageSigner` interfaces",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]: "The provided value does not implement the `TransactionModifyingSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]: "The provided value does not implement the `TransactionPartialSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]: "The provided value does not implement the `TransactionSendingSigner` interface",
  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]: "The provided value does not implement any of the `TransactionSigner` interfaces",
  [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS]: "More than one `TransactionSendingSigner` was identified.",
  [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING]: "No `TransactionSendingSigner` was identified. Please provide a valid `ITransactionWithSingleSendingSigner` transaction.",
  [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED]: "Wallet account signers do not support signing multiple messages/transactions in a single operation",
  [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: "Cannot export a non-extractable key.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED]: "No digest implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT]: "Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED]: "This runtime does not support the generation of Ed25519 key pairs.\n\nInstall @solana/webcrypto-ed25519-polyfill and call its `install` function before generating keys in environments that do not support Ed25519.\n\nFor a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED]: "No signature verification implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED]: "No key generation implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED]: "No signing implementation could be found.",
  [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED]: "No key export implementation could be found.",
  [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]: "Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: "Transaction processing left an account with an outstanding borrowed reference",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE]: "Account in use",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE]: "Account loaded twice",
  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND]: "Attempt to debit an account but found no record of a prior credit.",
  [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND]: "Transaction loads an address table account that doesn't exist",
  [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED]: "This transaction has already been processed",
  [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND]: "Blockhash not found",
  [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP]: "Loader call chain is too deep",
  [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE]: "Transactions are currently disabled due to cluster maintenance",
  [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]: "Transaction contains a duplicate instruction ($index) that is not allowed",
  [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE]: "Insufficient funds for fee",
  [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]: "Transaction results in an account ($accountIndex) with insufficient funds for rent",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE]: "This account may not be used to pay transaction fees",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX]: "Transaction contains an invalid account reference",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA]: "Transaction loads an address table account with invalid data",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX]: "Transaction address table lookup uses an invalid index",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER]: "Transaction loads an address table account with an invalid owner",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT]: "LoadedAccountsDataSizeLimit set for transaction must be greater than 0.",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION]: "This program may not be used for executing instructions",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT]: "Transaction leaves an account with a lower balance than rent-exempt minimum",
  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT]: "Transaction loads a writable account that cannot be written",
  [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED]: "Transaction exceeded max loaded accounts data size cap",
  [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE]: "Transaction requires a fee but has no signature present",
  [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND]: "Attempt to load a program that does not exist",
  [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]: "Execution of the program referenced by account at index $accountIndex is temporarily restricted.",
  [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED]: "ResanitizationNeeded",
  [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE]: "Transaction failed to sanitize accounts offsets correctly",
  [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE]: "Transaction did not pass signature verification",
  [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS]: "Transaction locked too many accounts",
  [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION]: "Sum of account balances before and after transaction do not match",
  [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: "The transaction failed with the error `$errorName`",
  [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION]: "Transaction version is unsupported",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT]: "Transaction would exceed account data limit within the block",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT]: "Transaction would exceed total account data limit",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT]: "Transaction would exceed max account limit within the block",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT]: "Transaction would exceed max Block Cost Limit",
  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT]: "Transaction would exceed max Vote Cost Limit",
  [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]: "Attempted to sign a transaction with an address that is not a signer for it",
  [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: "Transaction is missing an address at index: $index.",
  [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES]: "Transaction has no expected signers therefore it cannot be encoded",
  [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME]: "Transaction does not have a blockhash lifetime",
  [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME]: "Transaction is not a durable nonce transaction",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]: "Contents of these address lookup tables unknown: $lookupTableAddresses",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]: "Lookup of address at index $highestRequestedIndex failed for lookup table `$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table may have been extended since its contents were retrieved",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING]: "No fee payer set in CompiledTransaction",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]: "Could not find program address at index $index",
  [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT]: "Failed to estimate the compute unit consumption for this transaction message. This is likely because simulating the transaction failed. Inspect the `cause` property of this error to learn more",
  [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT]: "Transaction failed when it was simulated in order to estimate the compute unit consumption. The compute unit estimate provided is for a transaction that failed when simulated and may not be representative of the compute units this transaction would consume if successful. Inspect the `cause` property of this error to learn more",
  [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING]: "Transaction is missing a fee payer.",
  [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING]: "Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.",
  [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE]: "Transaction first instruction is not advance nonce account instruction.",
  [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING]: "Transaction with no instructions cannot be durable nonce transaction.",
  [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]: "This transaction includes an address (`$programAddress`) which is both invoked and set as the fee payer. Program addresses may not pay fees",
  [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]: "This transaction includes an address (`$programAddress`) which is both invoked and marked writable. Program addresses may not be writable",
  [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]: "The transaction message expected the transaction to have $signerAddressesLength signatures, got $signaturesLength.",
  [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: "Transaction is missing signatures for addresses: $addresses.",
  [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]: "Transaction version must be in the range [0, 127]. `$actualVersion` given"
};
var START_INDEX = "i";
var TYPE = "t";
function getHumanReadableErrorMessage(code, context = {}) {
  const messageFormatString = SolanaErrorMessages[code];
  if (messageFormatString.length === 0) {
    return "";
  }
  let state;
  function commitStateUpTo(endIndex) {
    if (state[TYPE] === 2) {
      const variableName = messageFormatString.slice(state[START_INDEX] + 1, endIndex);
      fragments.push(
        variableName in context ? `${context[variableName]}` : `$${variableName}`
      );
    } else if (state[TYPE] === 1) {
      fragments.push(messageFormatString.slice(state[START_INDEX], endIndex));
    }
  }
  const fragments = [];
  messageFormatString.split("").forEach((char, ii) => {
    if (ii === 0) {
      state = {
        [START_INDEX]: 0,
        [TYPE]: messageFormatString[0] === "\\" ? 0 : messageFormatString[0] === "$" ? 2 : 1
        /* Text */
      };
      return;
    }
    let nextState;
    switch (state[TYPE]) {
      case 0:
        nextState = {
          [START_INDEX]: ii,
          [TYPE]: 1
          /* Text */
        };
        break;
      case 1:
        if (char === "\\") {
          nextState = {
            [START_INDEX]: ii,
            [TYPE]: 0
            /* EscapeSequence */
          };
        } else if (char === "$") {
          nextState = {
            [START_INDEX]: ii,
            [TYPE]: 2
            /* Variable */
          };
        }
        break;
      case 2:
        if (char === "\\") {
          nextState = {
            [START_INDEX]: ii,
            [TYPE]: 0
            /* EscapeSequence */
          };
        } else if (char === "$") {
          nextState = {
            [START_INDEX]: ii,
            [TYPE]: 2
            /* Variable */
          };
        } else if (!char.match(/\w/)) {
          nextState = {
            [START_INDEX]: ii,
            [TYPE]: 1
            /* Text */
          };
        }
        break;
    }
    if (nextState) {
      if (state !== nextState) {
        commitStateUpTo(ii);
      }
      state = nextState;
    }
  });
  commitStateUpTo();
  return fragments.join("");
}
function getErrorMessage(code, context = {}) {
  if (process.env.NODE_ENV !== "production") {
    return getHumanReadableErrorMessage(code, context);
  } else {
    let decodingAdviceMessage = `Solana error #${code}; Decode this error by running \`npx @solana/errors decode -- ${code}`;
    if (Object.keys(context).length) {
      decodingAdviceMessage += ` '${encodeContextObject(context)}'`;
    }
    return `${decodingAdviceMessage}\``;
  }
}
var SolanaError = class extends Error {
  cause = this.cause;
  context;
  constructor(...[code, contextAndErrorOptions]) {
    let context;
    let errorOptions;
    if (contextAndErrorOptions) {
      const { cause, ...contextRest } = contextAndErrorOptions;
      if (cause) {
        errorOptions = { cause };
      }
      if (Object.keys(contextRest).length > 0) {
        context = contextRest;
      }
    }
    const message = getErrorMessage(code, context);
    super(message, errorOptions);
    this.context = {
      __code: code,
      ...context
    };
    this.name = "SolanaError";
  }
};

// ../../node_modules/@solana/codecs-core/dist/index.node.mjs
function getEncodedSize(value, encoder) {
  return "fixedSize" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);
}
function createEncoder(encoder) {
  return Object.freeze({
    ...encoder,
    encode: (value) => {
      const bytes = new Uint8Array(getEncodedSize(value, encoder));
      encoder.write(value, bytes, 0);
      return bytes;
    }
  });
}
function createDecoder(decoder) {
  return Object.freeze({
    ...decoder,
    decode: (bytes, offset = 0) => decoder.read(bytes, offset)[0]
  });
}
function isFixedSize(codec) {
  return "fixedSize" in codec && typeof codec.fixedSize === "number";
}
function assertByteArrayIsNotEmptyForCodec(codecDescription, bytes, offset = 0) {
  if (bytes.length - offset <= 0) {
    throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {
      codecDescription
    });
  }
}
function assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes, offset = 0) {
  const bytesLength = bytes.length - offset;
  if (bytesLength < expected) {
    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {
      bytesLength,
      codecDescription,
      expected
    });
  }
}
function transformDecoder(decoder, map) {
  return createDecoder({
    ...decoder,
    read: (bytes, offset) => {
      const [value, newOffset] = decoder.read(bytes, offset);
      return [map(value, bytes, offset), newOffset];
    }
  });
}

// ../../node_modules/@solana/codecs-strings/dist/index.node.mjs
function assertValidBaseString(alphabet4, testValue, givenValue = testValue) {
  if (!testValue.match(new RegExp(`^[${alphabet4}]*$`))) {
    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {
      alphabet: alphabet4,
      base: alphabet4.length,
      value: givenValue
    });
  }
}
var alphabet3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var getBase64Encoder = () => {
  {
    return createEncoder({
      getSizeFromValue: (value) => Buffer.from(value, "base64").length,
      write(value, bytes, offset) {
        assertValidBaseString(alphabet3, value.replace(/=/g, ""));
        const buffer = Buffer.from(value, "base64");
        bytes.set(buffer, offset);
        return buffer.length + offset;
      }
    });
  }
};
var e = globalThis.TextDecoder;
var o = globalThis.TextEncoder;

// ../../node_modules/@solana/accounts/dist/index.node.mjs
function decodeAccount(encodedAccount, decoder) {
  try {
    if ("exists" in encodedAccount && !encodedAccount.exists) {
      return encodedAccount;
    }
    return Object.freeze({ ...encodedAccount, data: decoder.decode(encodedAccount.data) });
  } catch {
    throw new SolanaError(SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT, {
      address: encodedAccount.address
    });
  }
}
function parseBase64RpcAccount(address4, rpcAccount) {
  if (!rpcAccount) return Object.freeze({ address: address4, exists: false });
  const data = getBase64Encoder().encode(rpcAccount.data[0]);
  return Object.freeze({ ...parseBaseAccount(rpcAccount), address: address4, data, exists: true });
}
function parseBaseAccount(rpcAccount) {
  return Object.freeze({
    executable: rpcAccount.executable,
    lamports: rpcAccount.lamports,
    programAddress: rpcAccount.owner
  });
}
async function fetchEncodedAccount(rpc, address4, config = {}) {
  const { abortSignal, ...rpcConfig } = config;
  const response = await rpc.getAccountInfo(address4, { ...rpcConfig, encoding: "base64" }).send({ abortSignal });
  return parseBase64RpcAccount(address4, response.value);
}
function assertAccountExists(account) {
  if (!account.exists) {
    throw new SolanaError(SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND, { address: account.address });
  }
}

// ../../node_modules/@solana/codecs-numbers/dist/index.node.mjs
function isLittleEndian(config) {
  return config?.endian === 1 ? false : true;
}
function numberDecoderFactory(input) {
  return createDecoder({
    fixedSize: input.size,
    read(bytes, offset = 0) {
      assertByteArrayIsNotEmptyForCodec(input.name, bytes, offset);
      assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes, offset);
      const view = new DataView(toArrayBuffer(bytes, offset, input.size));
      return [input.get(view, isLittleEndian(input.config)), offset + input.size];
    }
  });
}
function toArrayBuffer(bytes, offset, length) {
  const bytesOffset = bytes.byteOffset + (offset ?? 0);
  const bytesLength = length ?? bytes.byteLength;
  return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);
}
var getF64Decoder = (config = {}) => numberDecoderFactory({
  config,
  get: (view, le) => view.getFloat64(0, le),
  name: "f64",
  size: 8
});
var getU64Decoder = (config = {}) => numberDecoderFactory({
  config,
  get: (view, le) => view.getBigUint64(0, le),
  name: "u64",
  size: 8
});
var getU8Decoder = () => numberDecoderFactory({
  get: (view) => view.getUint8(0),
  name: "u8",
  size: 1
});

// ../../node_modules/@solana/codecs-data-structures/dist/index.node.mjs
function sumCodecSizes(sizes) {
  return sizes.reduce((all, size) => all === null || size === null ? null : all + size, 0);
}
function getFixedSize(codec) {
  return isFixedSize(codec) ? codec.fixedSize : null;
}
function getMaxSize(codec) {
  return isFixedSize(codec) ? codec.fixedSize : codec.maxSize ?? null;
}
function getStructDecoder(fields) {
  const fieldCodecs = fields.map(([, codec]) => codec);
  const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));
  const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? void 0;
  return createDecoder({
    ...fixedSize === null ? { maxSize } : { fixedSize },
    read: (bytes, offset) => {
      const struct = {};
      fields.forEach(([key, codec]) => {
        const [value, newOffset] = codec.read(bytes, offset);
        offset = newOffset;
        struct[key] = value;
      });
      return [struct, offset];
    }
  });
}

// ../../node_modules/@solana/rpc-types/dist/index.node.mjs
var maxU64Value = 18446744073709551615n;
var memoizedU64Decoder;
function getMemoizedU64Decoder() {
  if (!memoizedU64Decoder) memoizedU64Decoder = getU64Decoder();
  return memoizedU64Decoder;
}
function assertIsLamports(putativeLamports) {
  if (putativeLamports < 0 || putativeLamports > maxU64Value) {
    throw new SolanaError(SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE);
  }
}
function lamports(putativeLamports) {
  assertIsLamports(putativeLamports);
  return putativeLamports;
}
function getDefaultLamportsDecoder() {
  return getLamportsDecoder(getMemoizedU64Decoder());
}
function getLamportsDecoder(innerDecoder) {
  return transformDecoder(
    innerDecoder,
    (value) => lamports(typeof value === "bigint" ? value : BigInt(value))
  );
}
var minI64Value = -9223372036854775808n;

// ../../node_modules/@solana/sysvars/dist/index.node.mjs
var SYSVAR_RENT_ADDRESS = "SysvarRent111111111111111111111111111111111";
async function fetchEncodedSysvarAccount(rpc, address4, config) {
  return await fetchEncodedAccount(rpc, address4, config);
}
function getSysvarRentDecoder() {
  return getStructDecoder([
    ["lamportsPerByteYear", getDefaultLamportsDecoder()],
    ["exemptionThreshold", getF64Decoder()],
    ["burnPercent", getU8Decoder()]
  ]);
}
async function fetchSysvarRent(rpc, config) {
  const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_RENT_ADDRESS, config);
  assertAccountExists(account);
  const decoded = decodeAccount(account, getSysvarRentDecoder());
  return decoded.data;
}
var BITVEC_NUM_BITS = 1024 * 1024;
var BITVEC_LENGTH = BITVEC_NUM_BITS / 64;
var SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE = 1 + // Discriminator
8 + // bitvector length (u64)
BITVEC_LENGTH * 8 + 8 + // Number of bits (u64)
8;

// src/createPool.ts
var import_whirlpools_core = require("@orca-so/whirlpools-core");
var import_token_20222 = require("@solana-program/token-2022");
var import_assert2 = __toESM(require("assert"), 1);

// src/token.ts
var import_token = require("@solana-program/token");
var import_web32 = require("@solana/web3.js");
var import_system = require("@solana-program/system");
var import_token2 = require("@solana-program/token");
var import_token_2022 = require("@solana-program/token-2022");
var import_assert = __toESM(require("assert"), 1);
var NATIVE_MINT = (0, import_web32.address)(
  "So11111111111111111111111111111111111111112"
);
function mintFilter(x) {
  if (NATIVE_MINT_WRAPPING_STRATEGY === "none" || NATIVE_MINT_WRAPPING_STRATEGY === "ata") {
    return true;
  }
  return x != NATIVE_MINT;
}
async function prepareTokenAccountsInstructions(rpc, owner, spec) {
  const mintAddresses = Array.isArray(spec) ? spec : Object.keys(spec);
  const nativeMintIndex = mintAddresses.indexOf(NATIVE_MINT);
  const hasNativeMint = nativeMintIndex !== -1;
  const mints = await (0, import_token.fetchAllMint)(rpc, mintAddresses.filter(mintFilter));
  const tokenAddresses = await Promise.all(
    mints.map(
      (mint) => (0, import_token.findAssociatedTokenPda)({
        owner: owner.address,
        mint: mint.address,
        tokenProgram: mint.programAddress
      }).then((x) => x[0])
    )
  );
  const tokenAccounts = await (0, import_token.fetchAllMaybeToken)(rpc, tokenAddresses);
  const tokenAccountAddresses = {};
  const createInstructions = [];
  const cleanupInstructions = [];
  for (let i = 0; i < mints.length; i++) {
    const mint = mints[i];
    const tokenAccount = tokenAccounts[i];
    tokenAccountAddresses[mint.address] = tokenAccount.address;
    if (tokenAccount.exists) {
      continue;
    }
    createInstructions.push(
      (0, import_token.getCreateAssociatedTokenInstruction)({
        payer: owner,
        owner: owner.address,
        ata: tokenAccount.address,
        mint: mint.address,
        tokenProgram: mint.programAddress
      })
    );
  }
  if (!Array.isArray(spec)) {
    for (let i = 0; i < mints.length; i++) {
      const mint = mints[i];
      if (mint.address === NATIVE_MINT && NATIVE_MINT_WRAPPING_STRATEGY !== "none") {
        continue;
      }
      const tokenAccount = tokenAccounts[i];
      const existingBalance = tokenAccount.exists ? tokenAccount.data.amount : 0n;
      (0, import_assert.default)(
        BigInt(spec[mint.address]) <= existingBalance,
        `Token account for ${mint.address} does not have the required balance`
      );
    }
  }
  if (hasNativeMint && NATIVE_MINT_WRAPPING_STRATEGY === "keypair") {
    const keypair = await (0, import_web32.generateKeyPairSigner)();
    const space = (0, import_token2.getTokenSize)();
    let amount = await rpc.getMinimumBalanceForRentExemption(BigInt(space)).send();
    if (!Array.isArray(spec)) {
      amount = (0, import_web32.lamports)(amount + BigInt(spec[NATIVE_MINT]));
    }
    createInstructions.push(
      (0, import_system.getCreateAccountInstruction)({
        payer: owner,
        newAccount: keypair,
        lamports: amount,
        space,
        programAddress: import_token.TOKEN_PROGRAM_ADDRESS
      }),
      (0, import_token.getInitializeAccount3Instruction)({
        account: keypair.address,
        mint: NATIVE_MINT,
        owner: owner.address
      })
    );
    cleanupInstructions.push(
      (0, import_token.getCloseAccountInstruction)({
        account: keypair.address,
        owner,
        destination: owner.address
      })
    );
    tokenAccountAddresses[NATIVE_MINT] = keypair.address;
  }
  if (hasNativeMint && NATIVE_MINT_WRAPPING_STRATEGY === "seed") {
    const space = (0, import_token2.getTokenSize)();
    let amount = await rpc.getMinimumBalanceForRentExemption(BigInt(space)).send();
    if (!Array.isArray(spec)) {
      amount = (0, import_web32.lamports)(amount + BigInt(spec[NATIVE_MINT]));
    }
    const seed = Date.now().toString();
    const buffer = await crypto.subtle.digest(
      "SHA-256",
      Buffer.concat([
        Buffer.from((0, import_web32.getAddressEncoder)().encode(owner.address)),
        Buffer.from(seed),
        Buffer.from((0, import_web32.getAddressEncoder)().encode(import_token.TOKEN_PROGRAM_ADDRESS))
      ])
    );
    tokenAccountAddresses[NATIVE_MINT] = (0, import_web32.getAddressDecoder)().decode(
      new Uint8Array(buffer)
    );
    createInstructions.push(
      (0, import_system.getCreateAccountWithSeedInstruction)({
        payer: owner,
        newAccount: tokenAccountAddresses[NATIVE_MINT],
        base: owner.address,
        baseAccount: owner,
        seed,
        space,
        amount,
        programAddress: import_token.TOKEN_PROGRAM_ADDRESS
      }),
      (0, import_token.getInitializeAccount3Instruction)({
        account: tokenAccountAddresses[NATIVE_MINT],
        mint: NATIVE_MINT,
        owner: owner.address
      })
    );
    cleanupInstructions.push(
      (0, import_token.getCloseAccountInstruction)({
        account: tokenAccountAddresses[NATIVE_MINT],
        owner,
        destination: owner.address
      })
    );
  }
  if (hasNativeMint && NATIVE_MINT_WRAPPING_STRATEGY === "ata") {
    const account = tokenAccounts[nativeMintIndex];
    const existingBalance = account.exists ? account.data.amount : 0n;
    if (!Array.isArray(spec) && existingBalance < BigInt(spec[NATIVE_MINT])) {
      createInstructions.push(
        (0, import_system.getTransferSolInstruction)({
          source: owner,
          destination: tokenAccountAddresses[NATIVE_MINT],
          amount: BigInt(spec[NATIVE_MINT]) - existingBalance
        }),
        (0, import_token.getSyncNativeInstruction)({
          account: tokenAccountAddresses[NATIVE_MINT]
        })
      );
    }
    if (!account.exists) {
      cleanupInstructions.push(
        (0, import_token.getCloseAccountInstruction)({
          account: account.address,
          owner,
          destination: owner.address
        })
      );
    }
  }
  return {
    createInstructions,
    cleanupInstructions,
    tokenAccountAddresses
  };
}
function getCurrentTransferFee(mint, currentEpoch) {
  if (mint == null || "exists" in mint && !mint.exists || mint.data.extensions.__option === "None") {
    return void 0;
  }
  const feeConfig = mint.data.extensions.value.find(
    (x) => x.__kind === "TransferFeeConfig"
  );
  if (feeConfig == null) {
    return void 0;
  }
  const transferFee = currentEpoch >= feeConfig.newerTransferFee.epoch ? feeConfig.newerTransferFee : feeConfig.olderTransferFee;
  return {
    feeBps: transferFee.transferFeeBasisPoints,
    maxFee: transferFee.maximumFee
  };
}
function getAccountExtensions(mint) {
  if (mint.extensions.__option === "None") {
    return [];
  }
  const extensions = [];
  for (const extension of mint.extensions.value) {
    switch (extension.__kind) {
      case "TransferFeeConfig":
        extensions.push({
          __kind: "TransferFeeAmount",
          withheldAmount: 0n
        });
        break;
      case "NonTransferable":
        extensions.push({
          __kind: "NonTransferableAccount"
        });
        break;
      case "TransferHook":
        extensions.push({
          __kind: "TransferHookAccount",
          transferring: false
        });
        break;
    }
  }
  return extensions;
}
function orderMints(mint1, mint2) {
  const encoder = (0, import_web32.getAddressEncoder)();
  const mint1Bytes = new Uint8Array(encoder.encode(mint1));
  const mint2Bytes = new Uint8Array(encoder.encode(mint2));
  return Buffer.compare(mint1Bytes, mint2Bytes) < 0 ? [mint1, mint2] : [mint2, mint1];
}
function getTokenSizeForMint(mint) {
  const extensions = getAccountExtensions(mint.data);
  return extensions.length === 0 ? (0, import_token2.getTokenSize)() : (0, import_token_2022.getTokenSize)(extensions);
}

// src/sysvar.ts
var ACCOUNT_STORAGE_OVERHEAD = 128;
function calculateMinimumBalanceForRentExemption(rent, dataSize) {
  const dataSizeForRent = BigInt(dataSize + ACCOUNT_STORAGE_OVERHEAD);
  const rentLamportsPerYear = rent.lamportsPerByteYear * dataSizeForRent;
  const minimumBalance = rentLamportsPerYear * BigInt(rent.exemptionThreshold);
  return minimumBalance;
}

// src/createPool.ts
function createSplashPoolInstructions(rpc, tokenMintA, tokenMintB, initialPrice = 1, funder = FUNDER) {
  return createConcentratedLiquidityPoolInstructions(
    rpc,
    tokenMintA,
    tokenMintB,
    SPLASH_POOL_TICK_SPACING,
    initialPrice,
    funder
  );
}
async function createConcentratedLiquidityPoolInstructions(rpc, tokenMintA, tokenMintB, tickSpacing, initialPrice = 1, funder = FUNDER) {
  (0, import_assert2.default)(
    funder.address !== DEFAULT_ADDRESS,
    "Either supply a funder or set the default funder"
  );
  (0, import_assert2.default)(
    orderMints(tokenMintA, tokenMintB)[0] === tokenMintA,
    "Token order needs to be flipped to match the canonical ordering (i.e. sorted on the byte repr. of the mint pubkeys)"
  );
  const instructions = [];
  const rent = await fetchSysvarRent(rpc);
  let nonRefundableRent = 0n;
  const [mintA, mintB] = await (0, import_token_20222.fetchAllMint)(rpc, [tokenMintA, tokenMintB]);
  const decimalsA = mintA.data.decimals;
  const decimalsB = mintB.data.decimals;
  const tokenProgramA = mintA.programAddress;
  const tokenProgramB = mintB.programAddress;
  const initialSqrtPrice = (0, import_whirlpools_core.priceToSqrtPrice)(initialPrice, decimalsA, decimalsB);
  const [
    poolAddress,
    feeTier,
    tokenBadgeA,
    tokenBadgeB,
    tokenVaultA,
    tokenVaultB
  ] = await Promise.all([
    (0, import_whirlpools_client2.getWhirlpoolAddress)(
      WHIRLPOOLS_CONFIG_ADDRESS,
      tokenMintA,
      tokenMintB,
      tickSpacing
    ).then((x) => x[0]),
    (0, import_whirlpools_client2.getFeeTierAddress)(WHIRLPOOLS_CONFIG_ADDRESS, tickSpacing).then((x) => x[0]),
    (0, import_whirlpools_client2.getTokenBadgeAddress)(WHIRLPOOLS_CONFIG_ADDRESS, tokenMintA).then(
      (x) => x[0]
    ),
    (0, import_whirlpools_client2.getTokenBadgeAddress)(WHIRLPOOLS_CONFIG_ADDRESS, tokenMintB).then(
      (x) => x[0]
    ),
    (0, import_web33.generateKeyPairSigner)(),
    (0, import_web33.generateKeyPairSigner)()
  ]);
  instructions.push(
    (0, import_whirlpools_client2.getInitializePoolV2Instruction)({
      whirlpoolsConfig: WHIRLPOOLS_CONFIG_ADDRESS,
      tokenMintA,
      tokenMintB,
      tokenBadgeA,
      tokenBadgeB,
      funder,
      whirlpool: poolAddress,
      tokenVaultA,
      tokenVaultB,
      tokenProgramA,
      tokenProgramB,
      feeTier,
      tickSpacing,
      initialSqrtPrice
    })
  );
  nonRefundableRent += calculateMinimumBalanceForRentExemption(
    rent,
    getTokenSizeForMint(mintA)
  );
  nonRefundableRent += calculateMinimumBalanceForRentExemption(
    rent,
    getTokenSizeForMint(mintB)
  );
  nonRefundableRent += calculateMinimumBalanceForRentExemption(
    rent,
    (0, import_whirlpools_client2.getWhirlpoolSize)()
  );
  const fullRange = (0, import_whirlpools_core.getFullRangeTickIndexes)(tickSpacing);
  const lowerTickIndex = (0, import_whirlpools_core.getTickArrayStartTickIndex)(
    fullRange.tickLowerIndex,
    tickSpacing
  );
  const upperTickIndex = (0, import_whirlpools_core.getTickArrayStartTickIndex)(
    fullRange.tickUpperIndex,
    tickSpacing
  );
  const initialTickIndex = (0, import_whirlpools_core.sqrtPriceToTickIndex)(initialSqrtPrice);
  const currentTickIndex = (0, import_whirlpools_core.getTickArrayStartTickIndex)(
    initialTickIndex,
    tickSpacing
  );
  const tickArrayIndexes = Array.from(
    /* @__PURE__ */ new Set([lowerTickIndex, upperTickIndex, currentTickIndex])
  );
  const tickArrayAddresses = await Promise.all(
    tickArrayIndexes.map(
      (x) => (0, import_whirlpools_client2.getTickArrayAddress)(poolAddress, x).then((x2) => x2[0])
    )
  );
  for (let i = 0; i < tickArrayIndexes.length; i++) {
    instructions.push(
      (0, import_whirlpools_client2.getInitializeTickArrayInstruction)({
        whirlpool: poolAddress,
        funder,
        tickArray: tickArrayAddresses[i],
        startTickIndex: tickArrayIndexes[i]
      })
    );
    nonRefundableRent += calculateMinimumBalanceForRentExemption(
      rent,
      (0, import_whirlpools_client2.getTickArraySize)()
    );
  }
  return {
    instructions,
    poolAddress,
    initializationCost: (0, import_web33.lamports)(nonRefundableRent)
  };
}

// src/decreaseLiquidity.ts
var import_whirlpools_client3 = require("@orca-so/whirlpools-client");
var import_whirlpools_core2 = require("@orca-so/whirlpools-core");
var import_token4 = require("@solana-program/token");
var import_token_20223 = require("@solana-program/token-2022");
var import_memo = require("@solana-program/memo");
var import_assert3 = __toESM(require("assert"), 1);
function getDecreaseLiquidityQuote(param, pool, tickRange, slippageToleranceBps, transferFeeA, transferFeeB) {
  if ("liquidity" in param) {
    return (0, import_whirlpools_core2.decreaseLiquidityQuote)(
      param.liquidity,
      slippageToleranceBps,
      pool.sqrtPrice,
      tickRange.tickLowerIndex,
      tickRange.tickUpperIndex,
      transferFeeA,
      transferFeeB
    );
  } else if ("tokenA" in param) {
    return (0, import_whirlpools_core2.decreaseLiquidityQuoteA)(
      param.tokenA,
      slippageToleranceBps,
      pool.sqrtPrice,
      tickRange.tickLowerIndex,
      tickRange.tickUpperIndex,
      transferFeeA,
      transferFeeB
    );
  } else {
    return (0, import_whirlpools_core2.decreaseLiquidityQuoteB)(
      param.tokenB,
      slippageToleranceBps,
      pool.sqrtPrice,
      tickRange.tickLowerIndex,
      tickRange.tickUpperIndex,
      transferFeeA,
      transferFeeB
    );
  }
}
async function decreaseLiquidityInstructions(rpc, positionMintAddress, param, slippageToleranceBps = SLIPPAGE_TOLERANCE_BPS, authority = FUNDER) {
  (0, import_assert3.default)(
    authority.address !== DEFAULT_ADDRESS,
    "Either supply the authority or set the default funder"
  );
  const positionAddress = await (0, import_whirlpools_client3.getPositionAddress)(positionMintAddress);
  const position = await (0, import_whirlpools_client3.fetchPosition)(rpc, positionAddress[0]);
  const whirlpool = await (0, import_whirlpools_client3.fetchWhirlpool)(rpc, position.data.whirlpool);
  const currentEpoch = await rpc.getEpochInfo().send();
  const [mintA, mintB, positionMint] = await (0, import_token_20223.fetchAllMint)(rpc, [
    whirlpool.data.tokenMintA,
    whirlpool.data.tokenMintB,
    positionMintAddress
  ]);
  const transferFeeA = getCurrentTransferFee(mintA, currentEpoch.epoch);
  const transferFeeB = getCurrentTransferFee(mintB, currentEpoch.epoch);
  const quote = getDecreaseLiquidityQuote(
    param,
    whirlpool.data,
    position.data,
    slippageToleranceBps,
    transferFeeA,
    transferFeeB
  );
  const instructions = [];
  const lowerTickArrayStartIndex = (0, import_whirlpools_core2.getTickArrayStartTickIndex)(
    position.data.tickLowerIndex,
    whirlpool.data.tickSpacing
  );
  const upperTickArrayStartIndex = (0, import_whirlpools_core2.getTickArrayStartTickIndex)(
    position.data.tickUpperIndex,
    whirlpool.data.tickSpacing
  );
  const [positionTokenAccount, tickArrayLower, tickArrayUpper] = await Promise.all([
    (0, import_token4.findAssociatedTokenPda)({
      owner: authority.address,
      mint: positionMintAddress,
      tokenProgram: positionMint.programAddress
    }).then((x) => x[0]),
    (0, import_whirlpools_client3.getTickArrayAddress)(whirlpool.address, lowerTickArrayStartIndex).then(
      (x) => x[0]
    ),
    (0, import_whirlpools_client3.getTickArrayAddress)(whirlpool.address, upperTickArrayStartIndex).then(
      (x) => x[0]
    )
  ]);
  const { createInstructions, cleanupInstructions, tokenAccountAddresses } = await prepareTokenAccountsInstructions(rpc, authority, [
    whirlpool.data.tokenMintA,
    whirlpool.data.tokenMintB
  ]);
  instructions.push(...createInstructions);
  instructions.push(
    (0, import_whirlpools_client3.getDecreaseLiquidityV2Instruction)({
      whirlpool: whirlpool.address,
      positionAuthority: authority,
      position: position.address,
      positionTokenAccount,
      tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],
      tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],
      tokenVaultA: whirlpool.data.tokenVaultA,
      tokenVaultB: whirlpool.data.tokenVaultB,
      tokenMintA: whirlpool.data.tokenMintA,
      tokenMintB: whirlpool.data.tokenMintB,
      tokenProgramA: mintA.programAddress,
      tokenProgramB: mintB.programAddress,
      memoProgram: import_memo.MEMO_PROGRAM_ADDRESS,
      tickArrayLower,
      tickArrayUpper,
      liquidityAmount: quote.liquidityDelta,
      tokenMinA: quote.tokenMinA,
      tokenMinB: quote.tokenMinB,
      remainingAccountsInfo: null
    })
  );
  instructions.push(...cleanupInstructions);
  return { quote, instructions };
}
async function closePositionInstructions(rpc, positionMintAddress, slippageToleranceBps = SLIPPAGE_TOLERANCE_BPS, authority = FUNDER) {
  (0, import_assert3.default)(
    authority.address !== DEFAULT_ADDRESS,
    "Either supply an authority or set the default funder"
  );
  const positionAddress = await (0, import_whirlpools_client3.getPositionAddress)(positionMintAddress);
  const position = await (0, import_whirlpools_client3.fetchPosition)(rpc, positionAddress[0]);
  const whirlpool = await (0, import_whirlpools_client3.fetchWhirlpool)(rpc, position.data.whirlpool);
  const currentEpoch = await rpc.getEpochInfo().send();
  const [mintA, mintB, positionMint, ...rewardMints] = await (0, import_token_20223.fetchAllMaybeMint)(
    rpc,
    [
      whirlpool.data.tokenMintA,
      whirlpool.data.tokenMintB,
      positionMintAddress,
      ...whirlpool.data.rewardInfos.map((x) => x.mint).filter((x) => x !== DEFAULT_ADDRESS)
    ]
  );
  (0, import_assert3.default)(mintA.exists, "Token A not found");
  (0, import_assert3.default)(mintB.exists, "Token B not found");
  (0, import_assert3.default)(positionMint.exists, "Position mint not found");
  const transferFeeA = getCurrentTransferFee(mintA, currentEpoch.epoch);
  const transferFeeB = getCurrentTransferFee(mintB, currentEpoch.epoch);
  const quote = getDecreaseLiquidityQuote(
    { liquidity: position.data.liquidity },
    whirlpool.data,
    position.data,
    slippageToleranceBps,
    transferFeeA,
    transferFeeB
  );
  const lowerTickArrayStartIndex = (0, import_whirlpools_core2.getTickArrayStartTickIndex)(
    position.data.tickLowerIndex,
    whirlpool.data.tickSpacing
  );
  const upperTickArrayStartIndex = (0, import_whirlpools_core2.getTickArrayStartTickIndex)(
    position.data.tickUpperIndex,
    whirlpool.data.tickSpacing
  );
  const [positionTokenAccount, lowerTickArrayAddress, upperTickArrayAddress] = await Promise.all([
    (0, import_token4.findAssociatedTokenPda)({
      owner: authority.address,
      mint: positionMintAddress,
      tokenProgram: positionMint.programAddress
    }).then((x) => x[0]),
    (0, import_whirlpools_client3.getTickArrayAddress)(whirlpool.address, lowerTickArrayStartIndex).then(
      (x) => x[0]
    ),
    (0, import_whirlpools_client3.getTickArrayAddress)(whirlpool.address, upperTickArrayStartIndex).then(
      (x) => x[0]
    )
  ]);
  const [lowerTickArray, upperTickArray] = await (0, import_whirlpools_client3.fetchAllTickArray)(rpc, [
    lowerTickArrayAddress,
    upperTickArrayAddress
  ]);
  const lowerTick = lowerTickArray.data.ticks[(0, import_whirlpools_core2.getTickIndexInArray)(
    position.data.tickLowerIndex,
    lowerTickArrayStartIndex,
    whirlpool.data.tickSpacing
  )];
  const upperTick = upperTickArray.data.ticks[(0, import_whirlpools_core2.getTickIndexInArray)(
    position.data.tickUpperIndex,
    upperTickArrayStartIndex,
    whirlpool.data.tickSpacing
  )];
  const feesQuote = (0, import_whirlpools_core2.collectFeesQuote)(
    whirlpool.data,
    position.data,
    lowerTick,
    upperTick,
    transferFeeA,
    transferFeeB
  );
  const currentUnixTimestamp = BigInt(Math.floor(Date.now() / 1e3));
  const rewardsQuote = (0, import_whirlpools_core2.collectRewardsQuote)(
    whirlpool.data,
    position.data,
    lowerTick,
    upperTick,
    currentUnixTimestamp,
    getCurrentTransferFee(rewardMints[0], currentEpoch.epoch),
    getCurrentTransferFee(rewardMints[1], currentEpoch.epoch),
    getCurrentTransferFee(rewardMints[2], currentEpoch.epoch)
  );
  const requiredMints = /* @__PURE__ */ new Set();
  if (quote.liquidityDelta > 0n || feesQuote.feeOwedA > 0n || feesQuote.feeOwedB > 0n) {
    requiredMints.add(whirlpool.data.tokenMintA);
    requiredMints.add(whirlpool.data.tokenMintB);
  }
  for (let i = 0; i < rewardsQuote.rewards.length; i++) {
    if (rewardsQuote.rewards[i].rewardsOwed > 0n) {
      requiredMints.add(whirlpool.data.rewardInfos[i].mint);
    }
  }
  const { createInstructions, cleanupInstructions, tokenAccountAddresses } = await prepareTokenAccountsInstructions(
    rpc,
    authority,
    Array.from(requiredMints)
  );
  const instructions = [];
  instructions.push(...createInstructions);
  if (quote.liquidityDelta > 0n) {
    instructions.push(
      (0, import_whirlpools_client3.getDecreaseLiquidityV2Instruction)({
        whirlpool: whirlpool.address,
        positionAuthority: authority,
        position: positionAddress[0],
        positionTokenAccount,
        tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],
        tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],
        tokenVaultA: whirlpool.data.tokenVaultA,
        tokenVaultB: whirlpool.data.tokenVaultB,
        tickArrayLower: lowerTickArrayAddress,
        tickArrayUpper: upperTickArrayAddress,
        liquidityAmount: quote.liquidityDelta,
        tokenMinA: quote.tokenMinA,
        tokenMinB: quote.tokenMinB,
        tokenMintA: whirlpool.data.tokenMintA,
        tokenMintB: whirlpool.data.tokenMintB,
        tokenProgramA: mintA.programAddress,
        tokenProgramB: mintB.programAddress,
        memoProgram: import_memo.MEMO_PROGRAM_ADDRESS,
        remainingAccountsInfo: null
      })
    );
  }
  if (feesQuote.feeOwedA > 0n || feesQuote.feeOwedB > 0n) {
    instructions.push(
      (0, import_whirlpools_client3.getCollectFeesV2Instruction)({
        whirlpool: whirlpool.address,
        positionAuthority: authority,
        position: positionAddress[0],
        positionTokenAccount,
        tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],
        tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],
        tokenVaultA: whirlpool.data.tokenVaultA,
        tokenVaultB: whirlpool.data.tokenVaultB,
        tokenMintA: whirlpool.data.tokenMintA,
        tokenMintB: whirlpool.data.tokenMintB,
        tokenProgramA: mintA.programAddress,
        tokenProgramB: mintB.programAddress,
        memoProgram: import_memo.MEMO_PROGRAM_ADDRESS,
        remainingAccountsInfo: null
      })
    );
  }
  for (let i = 0; i < rewardsQuote.rewards.length; i++) {
    if (rewardsQuote.rewards[i].rewardsOwed === 0n) {
      continue;
    }
    const rewardMint = rewardMints[i];
    (0, import_assert3.default)(rewardMint.exists, `Reward mint ${i} not found`);
    instructions.push(
      (0, import_whirlpools_client3.getCollectRewardV2Instruction)({
        whirlpool: whirlpool.address,
        positionAuthority: authority,
        position: positionAddress[0],
        positionTokenAccount,
        rewardOwnerAccount: tokenAccountAddresses[rewardMint.address],
        rewardVault: whirlpool.data.rewardInfos[i].vault,
        rewardIndex: i,
        rewardMint: rewardMint.address,
        rewardTokenProgram: rewardMint.programAddress,
        memoProgram: import_memo.MEMO_PROGRAM_ADDRESS,
        remainingAccountsInfo: null
      })
    );
  }
  switch (positionMint.programAddress) {
    case import_token4.TOKEN_PROGRAM_ADDRESS:
      instructions.push(
        (0, import_whirlpools_client3.getClosePositionInstruction)({
          positionAuthority: authority,
          position: positionAddress[0],
          positionTokenAccount,
          positionMint: positionMintAddress,
          receiver: authority.address
        })
      );
      break;
    case import_token_20223.TOKEN_2022_PROGRAM_ADDRESS:
      instructions.push(
        (0, import_whirlpools_client3.getClosePositionWithTokenExtensionsInstruction)({
          positionAuthority: authority,
          position: positionAddress[0],
          positionTokenAccount,
          positionMint: positionMintAddress,
          receiver: authority.address,
          token2022Program: import_token_20223.TOKEN_2022_PROGRAM_ADDRESS
        })
      );
      break;
    default:
      throw new Error("Invalid token program");
  }
  instructions.push(...cleanupInstructions);
  return {
    instructions,
    quote,
    feesQuote,
    rewardsQuote
  };
}

// src/harvest.ts
var import_whirlpools_core3 = require("@orca-so/whirlpools-core");
var import_whirlpools_client4 = require("@orca-so/whirlpools-client");
var import_token6 = require("@solana-program/token");
var import_token_20224 = require("@solana-program/token-2022");
var import_memo2 = require("@solana-program/memo");
var import_assert4 = __toESM(require("assert"), 1);
async function harvestPositionInstructions(rpc, positionMintAddress, authority = FUNDER) {
  (0, import_assert4.default)(
    authority.address !== DEFAULT_ADDRESS,
    "Either supply an authority or set the default funder"
  );
  const currentEpoch = await rpc.getEpochInfo().send();
  const positionAddress = await (0, import_whirlpools_client4.getPositionAddress)(positionMintAddress);
  const position = await (0, import_whirlpools_client4.fetchPosition)(rpc, positionAddress[0]);
  const whirlpool = await (0, import_whirlpools_client4.fetchWhirlpool)(rpc, position.data.whirlpool);
  const [mintA, mintB, positionMint, ...rewardMints] = await (0, import_token_20224.fetchAllMaybeMint)(
    rpc,
    [
      whirlpool.data.tokenMintA,
      whirlpool.data.tokenMintB,
      positionMintAddress,
      ...whirlpool.data.rewardInfos.map((x) => x.mint).filter((x) => x !== DEFAULT_ADDRESS)
    ]
  );
  (0, import_assert4.default)(mintA.exists, "Token A not found");
  (0, import_assert4.default)(mintB.exists, "Token B not found");
  (0, import_assert4.default)(positionMint.exists, "Position mint not found");
  const lowerTickArrayStartIndex = (0, import_whirlpools_core3.getTickArrayStartTickIndex)(
    position.data.tickLowerIndex,
    whirlpool.data.tickSpacing
  );
  const upperTickArrayStartIndex = (0, import_whirlpools_core3.getTickArrayStartTickIndex)(
    position.data.tickUpperIndex,
    whirlpool.data.tickSpacing
  );
  const [positionTokenAccount, lowerTickArrayAddress, upperTickArrayAddress] = await Promise.all([
    (0, import_token6.findAssociatedTokenPda)({
      owner: authority.address,
      mint: positionMintAddress,
      tokenProgram: positionMint.programAddress
    }).then((x) => x[0]),
    (0, import_whirlpools_client4.getTickArrayAddress)(whirlpool.address, lowerTickArrayStartIndex).then(
      (x) => x[0]
    ),
    (0, import_whirlpools_client4.getTickArrayAddress)(whirlpool.address, upperTickArrayStartIndex).then(
      (x) => x[0]
    )
  ]);
  const [lowerTickArray, upperTickArray] = await (0, import_whirlpools_client4.fetchAllTickArray)(rpc, [
    lowerTickArrayAddress,
    upperTickArrayAddress
  ]);
  const lowerTick = lowerTickArray.data.ticks[(0, import_whirlpools_core3.getTickIndexInArray)(
    position.data.tickLowerIndex,
    lowerTickArrayStartIndex,
    whirlpool.data.tickSpacing
  )];
  const upperTick = upperTickArray.data.ticks[(0, import_whirlpools_core3.getTickIndexInArray)(
    position.data.tickUpperIndex,
    upperTickArrayStartIndex,
    whirlpool.data.tickSpacing
  )];
  const feesQuote = (0, import_whirlpools_core3.collectFeesQuote)(
    whirlpool.data,
    position.data,
    lowerTick,
    upperTick,
    getCurrentTransferFee(mintA, currentEpoch.epoch),
    getCurrentTransferFee(mintB, currentEpoch.epoch)
  );
  const currentUnixTimestamp = BigInt(Math.floor(Date.now() / 1e3));
  const rewardsQuote = (0, import_whirlpools_core3.collectRewardsQuote)(
    whirlpool.data,
    position.data,
    lowerTick,
    upperTick,
    currentUnixTimestamp,
    getCurrentTransferFee(rewardMints[0], currentEpoch.epoch),
    getCurrentTransferFee(rewardMints[1], currentEpoch.epoch),
    getCurrentTransferFee(rewardMints[2], currentEpoch.epoch)
  );
  const requiredMints = /* @__PURE__ */ new Set();
  if (feesQuote.feeOwedA > 0n || feesQuote.feeOwedB > 0n) {
    requiredMints.add(whirlpool.data.tokenMintA);
    requiredMints.add(whirlpool.data.tokenMintB);
  }
  for (let i = 0; i < rewardsQuote.rewards.length; i++) {
    if (rewardsQuote.rewards[i].rewardsOwed > 0n) {
      requiredMints.add(whirlpool.data.rewardInfos[i].mint);
    }
  }
  const { createInstructions, cleanupInstructions, tokenAccountAddresses } = await prepareTokenAccountsInstructions(
    rpc,
    authority,
    Array.from(requiredMints)
  );
  const instructions = [];
  instructions.push(...createInstructions);
  if (position.data.liquidity > 0n) {
    instructions.push(
      (0, import_whirlpools_client4.getUpdateFeesAndRewardsInstruction)({
        whirlpool: whirlpool.address,
        position: positionAddress[0],
        tickArrayLower: lowerTickArrayAddress,
        tickArrayUpper: upperTickArrayAddress
      })
    );
  }
  if (feesQuote.feeOwedA > 0n || feesQuote.feeOwedB > 0n) {
    instructions.push(
      (0, import_whirlpools_client4.getCollectFeesV2Instruction)({
        whirlpool: whirlpool.address,
        positionAuthority: authority,
        position: positionAddress[0],
        positionTokenAccount,
        tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],
        tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],
        tokenVaultA: whirlpool.data.tokenVaultA,
        tokenVaultB: whirlpool.data.tokenVaultB,
        tokenMintA: whirlpool.data.tokenMintA,
        tokenMintB: whirlpool.data.tokenMintB,
        tokenProgramA: mintA.programAddress,
        tokenProgramB: mintB.programAddress,
        memoProgram: import_memo2.MEMO_PROGRAM_ADDRESS,
        remainingAccountsInfo: null
      })
    );
  }
  for (let i = 0; i < rewardsQuote.rewards.length; i++) {
    if (rewardsQuote.rewards[i].rewardsOwed === 0n) {
      continue;
    }
    const rewardMint = rewardMints[i];
    (0, import_assert4.default)(rewardMint.exists, `Reward mint ${i} not found`);
    instructions.push(
      (0, import_whirlpools_client4.getCollectRewardV2Instruction)({
        whirlpool: whirlpool.address,
        positionAuthority: authority,
        position: positionAddress[0],
        positionTokenAccount,
        rewardOwnerAccount: tokenAccountAddresses[rewardMint.address],
        rewardVault: whirlpool.data.rewardInfos[i].vault,
        rewardIndex: i,
        rewardMint: rewardMint.address,
        rewardTokenProgram: rewardMint.programAddress,
        memoProgram: import_memo2.MEMO_PROGRAM_ADDRESS,
        remainingAccountsInfo: null
      })
    );
  }
  instructions.push(...cleanupInstructions);
  return {
    feesQuote,
    rewardsQuote,
    instructions
  };
}

// src/increaseLiquidity.ts
var import_whirlpools_client5 = require("@orca-so/whirlpools-client");
var import_whirlpools_core4 = require("@orca-so/whirlpools-core");
var import_web34 = require("@solana/web3.js");
var import_token8 = require("@solana-program/token");
var import_token_20225 = require("@solana-program/token-2022");
var import_memo3 = require("@solana-program/memo");
var import_assert5 = __toESM(require("assert"), 1);
function getIncreaseLiquidityQuote(param, pool, tickLowerIndex, tickUpperIndex, slippageToleranceBps, transferFeeA, transferFeeB) {
  if ("liquidity" in param) {
    return (0, import_whirlpools_core4.increaseLiquidityQuote)(
      param.liquidity,
      slippageToleranceBps,
      pool.sqrtPrice,
      tickLowerIndex,
      tickUpperIndex,
      transferFeeA,
      transferFeeB
    );
  } else if ("tokenA" in param) {
    return (0, import_whirlpools_core4.increaseLiquidityQuoteA)(
      param.tokenA,
      slippageToleranceBps,
      pool.sqrtPrice,
      tickLowerIndex,
      tickUpperIndex,
      transferFeeA,
      transferFeeB
    );
  } else {
    return (0, import_whirlpools_core4.increaseLiquidityQuoteB)(
      param.tokenB,
      slippageToleranceBps,
      pool.sqrtPrice,
      tickLowerIndex,
      tickUpperIndex,
      transferFeeA,
      transferFeeB
    );
  }
}
async function increaseLiquidityInstructions(rpc, positionMintAddress, param, slippageToleranceBps = SLIPPAGE_TOLERANCE_BPS, authority = FUNDER) {
  (0, import_assert5.default)(
    authority.address !== DEFAULT_ADDRESS,
    "Either supply the authority or set the default funder"
  );
  const positionAddress = await (0, import_whirlpools_client5.getPositionAddress)(positionMintAddress);
  const position = await (0, import_whirlpools_client5.fetchPosition)(rpc, positionAddress[0]);
  const whirlpool = await (0, import_whirlpools_client5.fetchWhirlpool)(rpc, position.data.whirlpool);
  const currentEpoch = await rpc.getEpochInfo().send();
  const [mintA, mintB, positionMint] = await (0, import_token_20225.fetchAllMint)(rpc, [
    whirlpool.data.tokenMintA,
    whirlpool.data.tokenMintB,
    positionMintAddress
  ]);
  const transferFeeA = getCurrentTransferFee(mintA, currentEpoch.epoch);
  const transferFeeB = getCurrentTransferFee(mintB, currentEpoch.epoch);
  const quote = getIncreaseLiquidityQuote(
    param,
    whirlpool.data,
    position.data.tickLowerIndex,
    position.data.tickUpperIndex,
    slippageToleranceBps,
    transferFeeA,
    transferFeeB
  );
  const instructions = [];
  const lowerTickArrayStartIndex = (0, import_whirlpools_core4.getTickArrayStartTickIndex)(
    position.data.tickLowerIndex,
    whirlpool.data.tickSpacing
  );
  const upperTickArrayStartIndex = (0, import_whirlpools_core4.getTickArrayStartTickIndex)(
    position.data.tickUpperIndex,
    whirlpool.data.tickSpacing
  );
  const [positionTokenAccount, tickArrayLower, tickArrayUpper] = await Promise.all([
    (0, import_token8.findAssociatedTokenPda)({
      owner: authority.address,
      mint: positionMintAddress,
      tokenProgram: positionMint.programAddress
    }).then((x) => x[0]),
    (0, import_whirlpools_client5.getTickArrayAddress)(whirlpool.address, lowerTickArrayStartIndex).then(
      (x) => x[0]
    ),
    (0, import_whirlpools_client5.getTickArrayAddress)(whirlpool.address, upperTickArrayStartIndex).then(
      (x) => x[0]
    )
  ]);
  const { createInstructions, cleanupInstructions, tokenAccountAddresses } = await prepareTokenAccountsInstructions(rpc, authority, {
    [whirlpool.data.tokenMintA]: quote.tokenMaxA,
    [whirlpool.data.tokenMintB]: quote.tokenMaxB
  });
  instructions.push(...createInstructions);
  instructions.push(
    (0, import_whirlpools_client5.getIncreaseLiquidityV2Instruction)({
      whirlpool: whirlpool.address,
      positionAuthority: authority,
      position: position.address,
      positionTokenAccount,
      tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],
      tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],
      tokenVaultA: whirlpool.data.tokenVaultA,
      tokenVaultB: whirlpool.data.tokenVaultB,
      tokenMintA: whirlpool.data.tokenMintA,
      tokenMintB: whirlpool.data.tokenMintB,
      tokenProgramA: mintA.programAddress,
      tokenProgramB: mintB.programAddress,
      tickArrayLower,
      tickArrayUpper,
      liquidityAmount: quote.liquidityDelta,
      tokenMaxA: quote.tokenMaxA,
      tokenMaxB: quote.tokenMaxB,
      memoProgram: import_memo3.MEMO_PROGRAM_ADDRESS,
      remainingAccountsInfo: null
    })
  );
  instructions.push(...cleanupInstructions);
  return {
    quote,
    instructions
  };
}
async function internalOpenPositionInstructions(rpc, whirlpool, param, lowerTickIndex, upperTickIndex, mintA, mintB, slippageToleranceBps = SLIPPAGE_TOLERANCE_BPS, funder = FUNDER) {
  (0, import_assert5.default)(
    funder.address !== DEFAULT_ADDRESS,
    "Either supply a funder or set the default funder"
  );
  const instructions = [];
  const rent = await fetchSysvarRent(rpc);
  let nonRefundableRent = 0n;
  const tickRange = (0, import_whirlpools_core4.orderTickIndexes)(lowerTickIndex, upperTickIndex);
  const initializableLowerTickIndex = (0, import_whirlpools_core4.getInitializableTickIndex)(
    tickRange.tickLowerIndex,
    whirlpool.data.tickSpacing,
    false
  );
  const initializableUpperTickIndex = (0, import_whirlpools_core4.getInitializableTickIndex)(
    tickRange.tickUpperIndex,
    whirlpool.data.tickSpacing,
    true
  );
  const currentEpoch = await rpc.getEpochInfo().send();
  const transferFeeA = getCurrentTransferFee(mintA, currentEpoch.epoch);
  const transferFeeB = getCurrentTransferFee(mintB, currentEpoch.epoch);
  const quote = getIncreaseLiquidityQuote(
    param,
    whirlpool.data,
    initializableLowerTickIndex,
    initializableUpperTickIndex,
    slippageToleranceBps,
    transferFeeA,
    transferFeeB
  );
  const positionMint = await (0, import_web34.generateKeyPairSigner)();
  const lowerTickArrayIndex = (0, import_whirlpools_core4.getTickArrayStartTickIndex)(
    initializableLowerTickIndex,
    whirlpool.data.tickSpacing
  );
  const upperTickArrayIndex = (0, import_whirlpools_core4.getTickArrayStartTickIndex)(
    initializableUpperTickIndex,
    whirlpool.data.tickSpacing
  );
  const [
    positionAddress,
    positionTokenAccount,
    lowerTickArrayAddress,
    upperTickArrayAddress
  ] = await Promise.all([
    (0, import_whirlpools_client5.getPositionAddress)(positionMint.address),
    (0, import_token8.findAssociatedTokenPda)({
      owner: funder.address,
      mint: positionMint.address,
      tokenProgram: import_token_20225.TOKEN_2022_PROGRAM_ADDRESS
    }).then((x) => x[0]),
    (0, import_whirlpools_client5.getTickArrayAddress)(whirlpool.address, lowerTickArrayIndex).then(
      (x) => x[0]
    ),
    (0, import_whirlpools_client5.getTickArrayAddress)(whirlpool.address, upperTickArrayIndex).then(
      (x) => x[0]
    )
  ]);
  const { createInstructions, cleanupInstructions, tokenAccountAddresses } = await prepareTokenAccountsInstructions(rpc, funder, {
    [whirlpool.data.tokenMintA]: quote.tokenMaxA,
    [whirlpool.data.tokenMintB]: quote.tokenMaxB
  });
  instructions.push(...createInstructions);
  const [lowerTickArray, upperTickArray] = await (0, import_whirlpools_client5.fetchAllMaybeTickArray)(rpc, [
    lowerTickArrayAddress,
    upperTickArrayAddress
  ]);
  if (!lowerTickArray.exists) {
    instructions.push(
      (0, import_whirlpools_client5.getInitializeTickArrayInstruction)({
        whirlpool: whirlpool.address,
        funder,
        tickArray: lowerTickArrayAddress,
        startTickIndex: lowerTickArrayIndex
      })
    );
    nonRefundableRent += calculateMinimumBalanceForRentExemption(
      rent,
      (0, import_whirlpools_client5.getTickArraySize)()
    );
  }
  if (!upperTickArray.exists && lowerTickArrayIndex !== upperTickArrayIndex) {
    instructions.push(
      (0, import_whirlpools_client5.getInitializeTickArrayInstruction)({
        whirlpool: whirlpool.address,
        funder,
        tickArray: upperTickArrayAddress,
        startTickIndex: upperTickArrayIndex
      })
    );
    nonRefundableRent += calculateMinimumBalanceForRentExemption(
      rent,
      (0, import_whirlpools_client5.getTickArraySize)()
    );
  }
  instructions.push(
    (0, import_whirlpools_client5.getOpenPositionWithTokenExtensionsInstruction)({
      funder,
      owner: funder.address,
      position: positionAddress[0],
      positionMint,
      positionTokenAccount,
      whirlpool: whirlpool.address,
      associatedTokenProgram: import_token8.ASSOCIATED_TOKEN_PROGRAM_ADDRESS,
      tickLowerIndex: initializableLowerTickIndex,
      tickUpperIndex: initializableUpperTickIndex,
      token2022Program: import_token_20225.TOKEN_2022_PROGRAM_ADDRESS,
      metadataUpdateAuth: (0, import_web34.address)(
        "3axbTs2z5GBy6usVbNVoqEgZMng3vZvMnAoX29BFfwhr"
      ),
      withTokenMetadataExtension: true
    })
  );
  instructions.push(
    (0, import_whirlpools_client5.getIncreaseLiquidityV2Instruction)({
      whirlpool: whirlpool.address,
      positionAuthority: funder,
      position: positionAddress[0],
      positionTokenAccount,
      tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],
      tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],
      tokenVaultA: whirlpool.data.tokenVaultA,
      tokenVaultB: whirlpool.data.tokenVaultB,
      tokenMintA: whirlpool.data.tokenMintA,
      tokenMintB: whirlpool.data.tokenMintB,
      tokenProgramA: mintA.programAddress,
      tokenProgramB: mintB.programAddress,
      tickArrayLower: lowerTickArrayAddress,
      tickArrayUpper: upperTickArrayAddress,
      liquidityAmount: quote.liquidityDelta,
      tokenMaxA: quote.tokenMaxA,
      tokenMaxB: quote.tokenMaxB,
      memoProgram: import_memo3.MEMO_PROGRAM_ADDRESS,
      remainingAccountsInfo: null
    })
  );
  instructions.push(...cleanupInstructions);
  return {
    instructions,
    quote,
    positionMint: positionMint.address,
    initializationCost: (0, import_web34.lamports)(nonRefundableRent)
  };
}
async function openFullRangePositionInstructions(rpc, poolAddress, param, slippageToleranceBps = SLIPPAGE_TOLERANCE_BPS, funder = FUNDER) {
  const whirlpool = await (0, import_whirlpools_client5.fetchWhirlpool)(rpc, poolAddress);
  const tickRange = (0, import_whirlpools_core4.getFullRangeTickIndexes)(whirlpool.data.tickSpacing);
  const [mintA, mintB] = await (0, import_token_20225.fetchAllMint)(rpc, [
    whirlpool.data.tokenMintA,
    whirlpool.data.tokenMintB
  ]);
  return internalOpenPositionInstructions(
    rpc,
    whirlpool,
    param,
    tickRange.tickLowerIndex,
    tickRange.tickUpperIndex,
    mintA,
    mintB,
    slippageToleranceBps,
    funder
  );
}
async function openPositionInstructions(rpc, poolAddress, param, lowerPrice, upperPrice, slippageToleranceBps = SLIPPAGE_TOLERANCE_BPS, funder = FUNDER) {
  const whirlpool = await (0, import_whirlpools_client5.fetchWhirlpool)(rpc, poolAddress);
  (0, import_assert5.default)(
    whirlpool.data.tickSpacing !== SPLASH_POOL_TICK_SPACING,
    "Splash pools only support full range positions"
  );
  const [mintA, mintB] = await (0, import_token_20225.fetchAllMint)(rpc, [
    whirlpool.data.tokenMintA,
    whirlpool.data.tokenMintB
  ]);
  const decimalsA = mintA.data.decimals;
  const decimalsB = mintB.data.decimals;
  const lowerTickIndex = (0, import_whirlpools_core4.priceToTickIndex)(lowerPrice, decimalsA, decimalsB);
  const upperTickIndex = (0, import_whirlpools_core4.priceToTickIndex)(upperPrice, decimalsA, decimalsB);
  return internalOpenPositionInstructions(
    rpc,
    whirlpool,
    param,
    lowerTickIndex,
    upperTickIndex,
    mintA,
    mintB,
    slippageToleranceBps,
    funder
  );
}

// src/pool.ts
var import_whirlpools_client6 = require("@orca-so/whirlpools-client");
var import_whirlpools_core5 = require("@orca-so/whirlpools-core");
var import_token11 = require("@solana-program/token");
async function fetchSplashPool(rpc, tokenMintOne, tokenMintTwo) {
  return fetchConcentratedLiquidityPool(
    rpc,
    tokenMintOne,
    tokenMintTwo,
    SPLASH_POOL_TICK_SPACING
  );
}
async function fetchConcentratedLiquidityPool(rpc, tokenMintOne, tokenMintTwo, tickSpacing) {
  const [tokenMintA, tokenMintB] = orderMints(tokenMintOne, tokenMintTwo);
  const feeTierAddress = await (0, import_whirlpools_client6.getFeeTierAddress)(
    WHIRLPOOLS_CONFIG_ADDRESS,
    tickSpacing
  ).then((x) => x[0]);
  const poolAddress = await (0, import_whirlpools_client6.getWhirlpoolAddress)(
    WHIRLPOOLS_CONFIG_ADDRESS,
    tokenMintA,
    tokenMintB,
    tickSpacing
  ).then((x) => x[0]);
  const [configAccount, feeTierAccount, poolAccount] = await Promise.all([
    (0, import_whirlpools_client6.fetchWhirlpoolsConfig)(rpc, WHIRLPOOLS_CONFIG_ADDRESS),
    (0, import_whirlpools_client6.fetchFeeTier)(rpc, feeTierAddress),
    (0, import_whirlpools_client6.fetchMaybeWhirlpool)(rpc, poolAddress)
  ]);
  const [mintA, mintB] = await (0, import_token11.fetchAllMint)(rpc, [tokenMintA, tokenMintB]);
  if (poolAccount.exists) {
    const poolPrice = (0, import_whirlpools_core5.sqrtPriceToPrice)(
      poolAccount.data.sqrtPrice,
      mintA.data.decimals,
      mintB.data.decimals
    );
    return {
      initialized: true,
      address: poolAddress,
      price: poolPrice,
      ...poolAccount.data
    };
  } else {
    return {
      initialized: false,
      address: poolAddress,
      whirlpoolsConfig: WHIRLPOOLS_CONFIG_ADDRESS,
      tickSpacing,
      feeRate: feeTierAccount.data.defaultFeeRate,
      protocolFeeRate: configAccount.data.defaultProtocolFeeRate,
      tokenMintA,
      tokenMintB
    };
  }
}
async function fetchWhirlpoolsByTokenPair(rpc, tokenMintOne, tokenMintTwo) {
  const [tokenMintA, tokenMintB] = orderMints(tokenMintOne, tokenMintTwo);
  const feeTierAccounts = await (0, import_whirlpools_client6.fetchAllFeeTierWithFilter)(
    rpc,
    (0, import_whirlpools_client6.feeTierWhirlpoolsConfigFilter)(WHIRLPOOLS_CONFIG_ADDRESS)
  );
  const supportedTickSpacings = feeTierAccounts.map((x) => x.data.tickSpacing);
  const poolAddresses = await Promise.all(
    supportedTickSpacings.map(
      (x) => (0, import_whirlpools_client6.getWhirlpoolAddress)(
        WHIRLPOOLS_CONFIG_ADDRESS,
        tokenMintA,
        tokenMintB,
        x
      ).then((x2) => x2[0])
    )
  );
  const [configAccount, poolAccounts] = await Promise.all([
    (0, import_whirlpools_client6.fetchWhirlpoolsConfig)(rpc, WHIRLPOOLS_CONFIG_ADDRESS),
    (0, import_whirlpools_client6.fetchAllMaybeWhirlpool)(rpc, poolAddresses)
  ]);
  const [mintA, mintB] = await (0, import_token11.fetchAllMint)(rpc, [tokenMintA, tokenMintB]);
  const pools = [];
  for (let i = 0; i < supportedTickSpacings.length; i++) {
    const tickSpacing = supportedTickSpacings[i];
    const feeTierAccount = feeTierAccounts[i];
    const poolAccount = poolAccounts[i];
    const poolAddress = poolAddresses[i];
    if (poolAccount.exists) {
      const poolPrice = (0, import_whirlpools_core5.sqrtPriceToPrice)(
        poolAccount.data.sqrtPrice,
        mintA.data.decimals,
        mintB.data.decimals
      );
      pools.push({
        initialized: true,
        address: poolAddress,
        price: poolPrice,
        ...poolAccount.data
      });
    } else {
      pools.push({
        initialized: false,
        address: poolAddress,
        whirlpoolsConfig: WHIRLPOOLS_CONFIG_ADDRESS,
        tickSpacing,
        feeRate: feeTierAccount.data.defaultFeeRate,
        protocolFeeRate: configAccount.data.defaultProtocolFeeRate,
        tokenMintA,
        tokenMintB
      });
    }
  }
  return pools;
}

// src/position.ts
var import_whirlpools_client7 = require("@orca-so/whirlpools-client");
var import_whirlpools_core6 = require("@orca-so/whirlpools-core");
var import_token12 = require("@solana-program/token");
var import_token_20226 = require("@solana-program/token-2022");
var import_web35 = require("@solana/web3.js");
function getPositionInBundleAddresses(positionBundle) {
  const buffer = Buffer.from(positionBundle.positionBitmap);
  const positions = [];
  for (let i = 0; i < (0, import_whirlpools_core6._POSITION_BUNDLE_SIZE)(); i++) {
    const byteIndex = Math.floor(i / 8);
    const bitIndex = i % 8;
    if (buffer[byteIndex] & 1 << bitIndex) {
      positions.push(
        (0, import_whirlpools_client7.getBundledPositionAddress)(positionBundle.positionBundleMint, i).then(
          (x) => x[0]
        )
      );
    }
  }
  return positions;
}
async function fetchPositionsForOwner(rpc, owner) {
  const [tokenAccounts, token2022Accounts] = await Promise.all([
    rpc.getTokenAccountsByOwner(
      owner,
      { programId: import_token12.TOKEN_PROGRAM_ADDRESS },
      { encoding: "base64" }
    ).send(),
    rpc.getTokenAccountsByOwner(
      owner,
      { programId: import_token_20226.TOKEN_2022_PROGRAM_ADDRESS },
      { encoding: "base64" }
    ).send()
  ]);
  const encoder = (0, import_web35.getBase64Encoder)();
  const decoder = (0, import_token12.getTokenDecoder)();
  const potentialTokens = [...tokenAccounts.value, ...token2022Accounts.value].map((x) => ({
    ...decoder.decode(encoder.encode(x.account.data[0])),
    tokenProgram: x.account.owner
  })).filter((x) => x.amount === 1n);
  const positionAddresses = await Promise.all(
    potentialTokens.map((x) => (0, import_whirlpools_client7.getPositionAddress)(x.mint).then((x2) => x2[0]))
  );
  const positionBundleAddresses = await Promise.all(
    potentialTokens.map(
      (x) => (0, import_whirlpools_client7.getPositionBundleAddress)(x.mint).then((x2) => x2[0])
    )
  );
  const [positions, positionBundles] = await Promise.all([
    (0, import_whirlpools_client7.fetchAllMaybePosition)(rpc, positionAddresses),
    (0, import_whirlpools_client7.fetchAllMaybePositionBundle)(rpc, positionBundleAddresses)
  ]);
  const bundledPositionAddresses = await Promise.all(
    positionBundles.filter((x) => x.exists).flatMap((x) => getPositionInBundleAddresses(x.data))
  );
  const bundledPositions = await (0, import_whirlpools_client7.fetchAllPosition)(
    rpc,
    bundledPositionAddresses
  );
  const bundledPositionMap = bundledPositions.reduce((acc, x) => {
    const current = acc.get(x.data.positionMint) ?? [];
    return acc.set(x.data.positionMint, [...current, x]);
  }, /* @__PURE__ */ new Map());
  const positionsOrBundles = [];
  for (let i = 0; i < potentialTokens.length; i++) {
    const position = positions[i];
    const positionBundle = positionBundles[i];
    const token = potentialTokens[i];
    if (position.exists) {
      positionsOrBundles.push({
        ...position,
        tokenProgram: token.tokenProgram,
        isPositionBundle: false
      });
    }
    if (positionBundle.exists) {
      const positions2 = bundledPositionMap.get(positionBundle.data.positionBundleMint) ?? [];
      positionsOrBundles.push({
        ...positionBundle,
        positions: positions2,
        tokenProgram: token.tokenProgram,
        isPositionBundle: true
      });
    }
  }
  return positionsOrBundles;
}
async function fetchPositionsInWhirlpool(rpc, whirlpool) {
  const positions = await (0, import_whirlpools_client7.fetchAllPositionWithFilter)(
    rpc,
    (0, import_whirlpools_client7.positionWhirlpoolFilter)(whirlpool)
  );
  return positions.map((x) => ({
    ...x,
    isPositionBundle: false
  }));
}

// src/swap.ts
var import_web36 = require("@solana/web3.js");
var import_whirlpools_core7 = require("@orca-so/whirlpools-core");
var import_whirlpools_client8 = require("@orca-so/whirlpools-client");
var import_memo4 = require("@solana-program/memo");
var import_token_20227 = require("@solana-program/token-2022");
function createUninitializedTickArray(address4, startTickIndex, programAddress) {
  return {
    address: address4,
    data: {
      startTickIndex,
      ticks: Array((0, import_whirlpools_core7._TICK_ARRAY_SIZE)()).fill({
        initialized: false,
        liquidityNet: 0n,
        liquidityGross: 0n,
        feeGrowthOutsideA: 0n,
        feeGrowthOutsideB: 0n,
        rewardGrowthsOutside: [0n, 0n, 0n]
      })
    },
    executable: false,
    lamports: (0, import_web36.lamports)(0n),
    programAddress
  };
}
async function fetchTickArrayOrDefault(rpc, whirlpool) {
  const tickArrayStartIndex = (0, import_whirlpools_core7.getTickArrayStartTickIndex)(
    whirlpool.data.tickCurrentIndex,
    whirlpool.data.tickSpacing
  );
  const offset = whirlpool.data.tickSpacing * (0, import_whirlpools_core7._TICK_ARRAY_SIZE)();
  const tickArrayIndexes = [
    tickArrayStartIndex,
    tickArrayStartIndex + offset,
    tickArrayStartIndex + offset * 2,
    tickArrayStartIndex - offset,
    tickArrayStartIndex - offset * 2
  ];
  const tickArrayAddresses = await Promise.all(
    tickArrayIndexes.map(
      (startIndex) => (0, import_whirlpools_client8.getTickArrayAddress)(whirlpool.address, startIndex).then((x) => x[0])
    )
  );
  const maybeTickArrays = await (0, import_whirlpools_client8.fetchAllMaybeTickArray)(rpc, tickArrayAddresses);
  const tickArrays = [];
  for (let i = 0; i < maybeTickArrays.length; i++) {
    const maybeTickArray = maybeTickArrays[i];
    if (maybeTickArray.exists) {
      tickArrays.push(maybeTickArray);
    } else {
      tickArrays.push(
        createUninitializedTickArray(
          tickArrayAddresses[i],
          tickArrayIndexes[i],
          whirlpool.programAddress
        )
      );
    }
  }
  return tickArrays;
}
function getSwapQuote(params, whirlpool, transferFeeA, transferFeeB, tickArrays, specifiedTokenA, slippageToleranceBps) {
  if ("inputAmount" in params) {
    return (0, import_whirlpools_core7.swapQuoteByInputToken)(
      params.inputAmount,
      specifiedTokenA,
      slippageToleranceBps,
      whirlpool,
      tickArrays,
      transferFeeA,
      transferFeeB
    );
  }
  return (0, import_whirlpools_core7.swapQuoteByOutputToken)(
    params.outputAmount,
    specifiedTokenA,
    slippageToleranceBps,
    whirlpool,
    tickArrays,
    transferFeeA,
    transferFeeB
  );
}
async function swapInstructions(rpc, params, poolAddress, slippageToleranceBps = SLIPPAGE_TOLERANCE_BPS, signer = FUNDER) {
  const whirlpool = await (0, import_whirlpools_client8.fetchWhirlpool)(rpc, poolAddress);
  const [tokenA, tokenB] = await (0, import_token_20227.fetchAllMint)(rpc, [
    whirlpool.data.tokenMintA,
    whirlpool.data.tokenMintB
  ]);
  const specifiedTokenA = params.mint === whirlpool.data.tokenMintA;
  const specifiedInput = "inputAmount" in params;
  const tickArrays = await fetchTickArrayOrDefault(rpc, whirlpool);
  const oracleAddress = await (0, import_whirlpools_client8.getOracleAddress)(whirlpool.address).then(
    (x) => x[0]
  );
  const currentEpoch = await rpc.getEpochInfo().send();
  const transferFeeA = getCurrentTransferFee(tokenA, currentEpoch.epoch);
  const transferFeeB = getCurrentTransferFee(tokenB, currentEpoch.epoch);
  const quote = getSwapQuote(
    params,
    whirlpool.data,
    transferFeeA,
    transferFeeB,
    tickArrays.map((x) => x.data),
    specifiedTokenA,
    slippageToleranceBps
  );
  const maxInAmount = "tokenIn" in quote ? quote.tokenIn : quote.tokenMaxIn;
  const aToB = specifiedTokenA === specifiedInput;
  const { createInstructions, cleanupInstructions, tokenAccountAddresses } = await prepareTokenAccountsInstructions(rpc, signer, {
    [whirlpool.data.tokenMintA]: aToB ? maxInAmount : 0n,
    [whirlpool.data.tokenMintB]: aToB ? 0n : maxInAmount
  });
  const instructions = [];
  instructions.push(...createInstructions);
  const specifiedAmount = "inputAmount" in params ? params.inputAmount : params.outputAmount;
  const otherAmountThreshold = "tokenMaxIn" in quote ? quote.tokenMaxIn : quote.tokenMinOut;
  const swapInstruction = (0, import_whirlpools_client8.getSwapV2Instruction)({
    tokenProgramA: tokenA.programAddress,
    tokenProgramB: tokenB.programAddress,
    memoProgram: import_memo4.MEMO_PROGRAM_ADDRESS,
    tokenAuthority: signer,
    whirlpool: whirlpool.address,
    tokenMintA: whirlpool.data.tokenMintA,
    tokenMintB: whirlpool.data.tokenMintB,
    tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],
    tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],
    tokenVaultA: whirlpool.data.tokenVaultA,
    tokenVaultB: whirlpool.data.tokenVaultB,
    tickArray0: tickArrays[0].address,
    tickArray1: tickArrays[1].address,
    tickArray2: tickArrays[2].address,
    amount: specifiedAmount,
    otherAmountThreshold,
    sqrtPriceLimit: 0,
    amountSpecifiedIsInput: specifiedInput,
    aToB,
    oracle: oracleAddress,
    remainingAccountsInfo: {
      slices: [
        { accountsType: import_whirlpools_client8.AccountsType.SupplementalTickArrays, length: 2 }
      ]
    }
  });
  swapInstruction.accounts.push(
    { address: tickArrays[3].address, role: import_web36.AccountRole.WRITABLE },
    { address: tickArrays[4].address, role: import_web36.AccountRole.WRITABLE }
  );
  instructions.push(swapInstruction);
  instructions.push(...cleanupInstructions);
  return {
    quote,
    instructions
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DEFAULT_ADDRESS,
  DEFAULT_FUNDER,
  DEFAULT_NATIVE_MINT_WRAPPING_STRATEGY,
  DEFAULT_SLIPPAGE_TOLERANCE_BPS,
  DEFAULT_WHIRLPOOLS_CONFIG_ADDRESSES,
  DEFAULT_WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS,
  FUNDER,
  NATIVE_MINT_WRAPPING_STRATEGY,
  SLIPPAGE_TOLERANCE_BPS,
  SPLASH_POOL_TICK_SPACING,
  WHIRLPOOLS_CONFIG_ADDRESS,
  WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS,
  closePositionInstructions,
  createConcentratedLiquidityPoolInstructions,
  createSplashPoolInstructions,
  decreaseLiquidityInstructions,
  fetchConcentratedLiquidityPool,
  fetchPositionsForOwner,
  fetchPositionsInWhirlpool,
  fetchSplashPool,
  fetchWhirlpoolsByTokenPair,
  harvestPositionInstructions,
  increaseLiquidityInstructions,
  openFullRangePositionInstructions,
  openPositionInstructions,
  resetConfiguration,
  setDefaultFunder,
  setDefaultSlippageToleranceBps,
  setNativeMintWrappingStrategy,
  setWhirlpoolsConfig,
  swapInstructions
});
//# sourceMappingURL=index.cjs.map