{"version":3,"sources":["../src/config.ts","../src/createPool.ts","../../../node_modules/@solana/errors/src/codes.ts","../../../node_modules/@solana/errors/src/context.ts","../../../node_modules/@solana/errors/src/messages.ts","../../../node_modules/@solana/errors/src/message-formatter.ts","../../../node_modules/@solana/errors/src/error.ts","../../../node_modules/@solana/errors/src/stack-trace.ts","../../../node_modules/@solana/errors/src/rpc-enum-errors.ts","../../../node_modules/@solana/errors/src/instruction-error.ts","../../../node_modules/@solana/errors/src/transaction-error.ts","../../../node_modules/@solana/errors/src/json-rpc-error.ts","../../../node_modules/@solana/codecs-core/src/bytes.ts","../../../node_modules/@solana/codecs-core/src/codec.ts","../../../node_modules/@solana/codecs-core/src/combine-codec.ts","../../../node_modules/@solana/codecs-core/src/add-codec-sentinel.ts","../../../node_modules/@solana/codecs-core/src/assertions.ts","../../../node_modules/@solana/codecs-core/src/add-codec-size-prefix.ts","../../../node_modules/@solana/codecs-core/src/fix-codec-size.ts","../../../node_modules/@solana/codecs-core/src/offset-codec.ts","../../../node_modules/@solana/codecs-core/src/resize-codec.ts","../../../node_modules/@solana/codecs-core/src/pad-codec.ts","../../../node_modules/@solana/codecs-core/src/reverse-codec.ts","../../../node_modules/@solana/codecs-core/src/transform-codec.ts","../../../node_modules/@solana/codecs-strings/src/assertions.ts","../../../node_modules/@solana/codecs-strings/src/baseX.ts","../../../node_modules/@solana/codecs-strings/src/base10.ts","../../../node_modules/@solana/codecs-strings/src/base16.ts","../../../node_modules/@solana/codecs-strings/src/base58.ts","../../../node_modules/@solana/codecs-strings/src/baseX-reslice.ts","../../../node_modules/@solana/codecs-strings/src/base64.ts","../../../node_modules/@solana/codecs-strings/src/null-characters.ts","../../../node_modules/@solana/text-encoding-impl/src/index.node.ts","../../../node_modules/@solana/codecs-strings/src/utf8.ts","../../../node_modules/@solana/accounts/src/account.ts","../../../node_modules/@solana/accounts/src/decode-account.ts","../../../node_modules/@solana/accounts/src/parse-account.ts","../../../node_modules/@solana/accounts/src/fetch-account.ts","../../../node_modules/@solana/accounts/src/maybe-account.ts","../../../node_modules/@solana/codecs-numbers/src/assertions.ts","../../../node_modules/@solana/codecs-numbers/src/common.ts","../../../node_modules/@solana/codecs-numbers/src/utils.ts","../../../node_modules/@solana/codecs-numbers/src/f32.ts","../../../node_modules/@solana/codecs-numbers/src/f64.ts","../../../node_modules/@solana/codecs-numbers/src/i128.ts","../../../node_modules/@solana/codecs-numbers/src/i16.ts","../../../node_modules/@solana/codecs-numbers/src/i32.ts","../../../node_modules/@solana/codecs-numbers/src/i64.ts","../../../node_modules/@solana/codecs-numbers/src/i8.ts","../../../node_modules/@solana/codecs-numbers/src/short-u16.ts","../../../node_modules/@solana/codecs-numbers/src/u128.ts","../../../node_modules/@solana/codecs-numbers/src/u16.ts","../../../node_modules/@solana/codecs-numbers/src/u32.ts","../../../node_modules/@solana/codecs-numbers/src/u64.ts","../../../node_modules/@solana/codecs-numbers/src/u8.ts","../../../node_modules/@solana/codecs-data-structures/src/assertions.ts","../../../node_modules/@solana/codecs-data-structures/src/utils.ts","../../../node_modules/@solana/codecs-data-structures/src/array.ts","../../../node_modules/@solana/codecs-data-structures/src/bit-array.ts","../../../node_modules/@solana/codecs-data-structures/src/boolean.ts","../../../node_modules/@solana/codecs-data-structures/src/bytes.ts","../../../node_modules/@solana/codecs-strings/src/base16.ts","../../../node_modules/@solana/codecs-data-structures/src/constant.ts","../../../node_modules/@solana/codecs-data-structures/src/tuple.ts","../../../node_modules/@solana/codecs-data-structures/src/union.ts","../../../node_modules/@solana/codecs-data-structures/src/discriminated-union.ts","../../../node_modules/@solana/codecs-data-structures/src/enum-helpers.ts","../../../node_modules/@solana/codecs-data-structures/src/enum.ts","../../../node_modules/@solana/codecs-data-structures/src/hidden-prefix.ts","../../../node_modules/@solana/codecs-data-structures/src/hidden-suffix.ts","../../../node_modules/@solana/codecs-data-structures/src/map.ts","../../../node_modules/@solana/codecs-data-structures/src/unit.ts","../../../node_modules/@solana/codecs-data-structures/src/nullable.ts","../../../node_modules/@solana/codecs-data-structures/src/set.ts","../../../node_modules/@solana/codecs-data-structures/src/struct.ts","../../../node_modules/@solana/rpc-types/src/blockhash.ts","../../../node_modules/@solana/rpc-types/src/cluster-url.ts","../../../node_modules/@solana/rpc-types/src/commitment.ts","../../../node_modules/@solana/rpc-types/src/lamports.ts","../../../node_modules/@solana/rpc-types/src/stringified-bigint.ts","../../../node_modules/@solana/rpc-types/src/stringified-number.ts","../../../node_modules/@solana/rpc-types/src/unix-timestamp.ts","../../../node_modules/@solana/sysvars/src/sysvar.ts","../../../node_modules/@solana/sysvars/src/clock.ts","../../../node_modules/@solana/sysvars/src/epoch-rewards.ts","../../../node_modules/@solana/sysvars/src/epoch-schedule.ts","../../../node_modules/@solana/sysvars/src/fees.ts","../../../node_modules/@solana/sysvars/src/last-restart-slot.ts","../../../node_modules/@solana/sysvars/src/recent-blockhashes.ts","../../../node_modules/@solana/sysvars/src/rent.ts","../../../node_modules/@solana/sysvars/src/slot-hashes.ts","../../../node_modules/@solana/sysvars/src/slot-history.ts","../../../node_modules/@solana/sysvars/src/stake-history.ts","../src/token.ts","../src/sysvar.ts","../src/decreaseLiquidity.ts","../src/harvest.ts","../src/increaseLiquidity.ts","../src/pool.ts","../src/position.ts","../src/swap.ts"],"sourcesContent":["import { getWhirlpoolsConfigExtensionAddress } from \"@orca-so/whirlpools-client\";\nimport type { Address, TransactionSigner } from \"@solana/web3.js\";\nimport { address, createNoopSigner, isAddress } from \"@solana/web3.js\";\n\n/**\n * The default (null) address.\n */\nexport const DEFAULT_ADDRESS = address(\"11111111111111111111111111111111\");\n\n/**\n * The WhirlpoolsConfig addresses for various networks.\n */\nexport const DEFAULT_WHIRLPOOLS_CONFIG_ADDRESSES = {\n  solanaMainnet: address(\"2LecshUwdy9xi7meFgHtFJQNSKk4KdTrcpvaB56dP2NQ\"),\n  solanaDevnet: address(\"FcrweFY1G9HJAHG5inkGB6pKg1HZ6x9UC2WioAfWrGkR\"),\n  eclipseMainnet: address(\"FVG4oDbGv16hqTUbovjyGmtYikn6UBEnazz6RVDMEFwv\"),\n  eclipseTestnet: address(\"FPydDjRdZu9sT7HVd6ANhfjh85KLq21Pefr5YWWMRPFp\"),\n};\n\n/**\n * The default WhirlpoolsConfigExtension address.\n */\nexport const DEFAULT_WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS = address(\n  \"777H5H3Tp9U11uRVRzFwM8BinfiakbaLT8vQpeuhvEiH\",\n);\n\n/**\n * The WhirlpoolsConfig address.\n */\nexport let WHIRLPOOLS_CONFIG_ADDRESS: Address =\n  DEFAULT_WHIRLPOOLS_CONFIG_ADDRESSES.solanaMainnet;\n\n/**\n * The WhirlpoolsConfigExtension address.\n */\nexport let WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS: Address =\n  DEFAULT_WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS;\n\n/**\n * Updates the WhirlpoolsConfig and WhirlpoolsConfigExtension addresses.\n *\n * @param {Address | keyof typeof NETWORK_ADDRESSES} config - A WhirlpoolsConfig address or a network name.\n * @returns {Promise<void>} - Resolves when the addresses have been updated.\n */\nexport async function setWhirlpoolsConfig(\n  config: Address | keyof typeof DEFAULT_WHIRLPOOLS_CONFIG_ADDRESSES,\n): Promise<void> {\n  if (isAddress(config)) {\n    WHIRLPOOLS_CONFIG_ADDRESS = config;\n  } else {\n    WHIRLPOOLS_CONFIG_ADDRESS =\n      DEFAULT_WHIRLPOOLS_CONFIG_ADDRESSES[\n        config as keyof typeof DEFAULT_WHIRLPOOLS_CONFIG_ADDRESSES\n      ];\n  }\n\n  WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS =\n    await getWhirlpoolsConfigExtensionAddress(WHIRLPOOLS_CONFIG_ADDRESS).then(\n      (x) => x[0],\n    );\n}\n\n/**\n * The tick spacing for the Splash pools.\n */\nexport const SPLASH_POOL_TICK_SPACING = 32896;\n\n/**\n * The default funder for transactions. No explicit funder specified.\n */\nexport const DEFAULT_FUNDER: TransactionSigner =\n  createNoopSigner(DEFAULT_ADDRESS);\n\n/**\n * The currently selected funder for transactions.\n */\nexport let FUNDER: TransactionSigner = DEFAULT_FUNDER;\n\n/**\n * Sets the default funder for transactions.\n *\n * @param {TransactionSigner | Address | null} funder - The funder to be set as default, either as an address or a transaction signer.\n */\nexport function setDefaultFunder(\n  funder: TransactionSigner | Address | null,\n): void {\n  if (typeof funder === \"string\") {\n    FUNDER = createNoopSigner(funder);\n  } else {\n    FUNDER = funder ?? createNoopSigner(DEFAULT_ADDRESS);\n  }\n}\n\n/**\n * The default slippage tolerance, expressed in basis points. Value of 100 is equivalent to 1%.\n */\nexport const DEFAULT_SLIPPAGE_TOLERANCE_BPS = 100;\n\n/**\n * The currently selected slippage tolerance, expressed in basis points. Value of 100 is equivalent to 1%.\n */\nexport let SLIPPAGE_TOLERANCE_BPS = DEFAULT_SLIPPAGE_TOLERANCE_BPS;\n\n/**\n * Sets the default slippage tolerance for transactions.\n *\n * @param {number} slippageToleranceBps - The slippage tolerance, expressed basis points. Value of 100 is equivalent to 1%.\n */\nexport function setDefaultSlippageToleranceBps(\n  slippageToleranceBps: number,\n): void {\n  SLIPPAGE_TOLERANCE_BPS = Math.floor(slippageToleranceBps);\n}\n\n/**\n * Defines the strategy for handling Native Mint wrapping in a transaction.\n *\n * - **Keypair**:\n *   Creates an auxiliary token account using a keypair.\n *   Optionally adds funds to the account.\n *   Closes it at the end of the transaction.\n *\n * - **Seed**:\n *   Functions similarly to Keypair, but uses a seed account instead.\n *\n * - **ATA**:\n *   Treats the native balance and associated token account (ATA) for `NATIVE_MINT` as one.\n *   Will create the ATA if it doesn't exist.\n *   Optionally adds funds to the account.\n *   Closes it at the end of the transaction if it did not exist before.\n *\n * - **None**:\n *   Uses or creates the ATA without performing any Native Mint wrapping or unwrapping.\n */\nexport type NativeMintWrappingStrategy = \"keypair\" | \"seed\" | \"ata\" | \"none\";\n\n/**\n * The default native mint wrapping strategy.\n */\nexport const DEFAULT_NATIVE_MINT_WRAPPING_STRATEGY: NativeMintWrappingStrategy =\n  \"keypair\";\n\n/**\n * The currently selected native mint wrapping strategy.\n */\nexport let NATIVE_MINT_WRAPPING_STRATEGY: NativeMintWrappingStrategy =\n  DEFAULT_NATIVE_MINT_WRAPPING_STRATEGY;\n\n/**\n * Sets the native mint wrapping strategy.\n *\n * @param {NativeMintWrappingStrategy} strategy - The native mint wrapping strategy.\n */\nexport function setNativeMintWrappingStrategy(\n  strategy: NativeMintWrappingStrategy,\n): void {\n  NATIVE_MINT_WRAPPING_STRATEGY = strategy;\n}\n\n/**\n * Resets the configuration to its default state.\n *\n * @returns {Promise<void>} - Resolves when the configuration has been reset.\n */\nexport function resetConfiguration() {\n  WHIRLPOOLS_CONFIG_ADDRESS = DEFAULT_WHIRLPOOLS_CONFIG_ADDRESSES.solanaMainnet;\n  WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS =\n    DEFAULT_WHIRLPOOLS_CONFIG_EXTENSION_ADDRESS;\n  FUNDER = DEFAULT_FUNDER;\n  SLIPPAGE_TOLERANCE_BPS = DEFAULT_SLIPPAGE_TOLERANCE_BPS;\n  NATIVE_MINT_WRAPPING_STRATEGY = DEFAULT_NATIVE_MINT_WRAPPING_STRATEGY;\n}\n","import {\n  getFeeTierAddress,\n  getInitializePoolV2Instruction,\n  getInitializeTickArrayInstruction,\n  getTickArrayAddress,\n  getTickArraySize,\n  getTokenBadgeAddress,\n  getWhirlpoolAddress,\n  getWhirlpoolSize,\n} from \"@orca-so/whirlpools-client\";\nimport type {\n  Address,\n  GetAccountInfoApi,\n  GetMultipleAccountsApi,\n  IInstruction,\n  Lamports,\n  Rpc,\n  TransactionSigner,\n} from \"@solana/web3.js\";\nimport { generateKeyPairSigner, lamports } from \"@solana/web3.js\";\nimport { fetchSysvarRent } from \"@solana/sysvars\";\nimport {\n  DEFAULT_ADDRESS,\n  FUNDER,\n  SPLASH_POOL_TICK_SPACING,\n  WHIRLPOOLS_CONFIG_ADDRESS,\n} from \"./config\";\nimport {\n  getFullRangeTickIndexes,\n  getTickArrayStartTickIndex,\n  priceToSqrtPrice,\n  sqrtPriceToTickIndex,\n} from \"@orca-so/whirlpools-core\";\nimport { fetchAllMint } from \"@solana-program/token-2022\";\nimport assert from \"assert\";\nimport { getTokenSizeForMint, orderMints } from \"./token\";\nimport { calculateMinimumBalanceForRentExemption } from \"./sysvar\";\n\n/**\n * Represents the instructions and metadata for creating a pool.\n */\nexport type CreatePoolInstructions = {\n  /** The list of instructions needed to create the pool. */\n  instructions: IInstruction[];\n\n  /** The estimated rent exemption cost for initializing the pool, in lamports. */\n  initializationCost: Lamports;\n\n  /** The address of the newly created pool. */\n  poolAddress: Address;\n};\n\n/**\n * Creates the necessary instructions to initialize a Splash Pool on Orca Whirlpools.\n *\n * @param {SolanaRpc} rpc - A Solana RPC client for communicating with the blockchain.\n * @param {Address} tokenMintA - The first token mint address to include in the pool.\n * @param {Address} tokenMintB - The second token mint address to include in the pool.\n * @param {number} [initialPrice=1] - The initial price of token 1 in terms of token 2.\n * @param {TransactionSigner} [funder=FUNDER] - The account that will fund the initialization process.\n *\n * @returns {Promise<CreatePoolInstructions>} A promise that resolves to an object containing the pool creation instructions, the estimated initialization cost, and the pool address.\n *\n * @example\n * import { createSplashPoolInstructions, setWhirlpoolsConfig } from '@orca-so/whirlpools';\n * import { generateKeyPairSigner, createSolanaRpc, devnet, address } from '@solana/web3.js';\n *\n * await setWhirlpoolsConfig('solanaDevnet');\n * const devnetRpc = createSolanaRpc(devnet('https://api.devnet.solana.com'));\n * const wallet = await generateKeyPairSigner(); // CAUTION: This wallet is not persistent.\n *\n * const tokenMintOne = address(\"So11111111111111111111111111111111111111112\");\n * const tokenMintTwo = address(\"BRjpCHtyQLNCo8gqRUr8jtdAj5AjPYQaoqbvcZiHok1k\"); // devUSDC\n * const initialPrice = 0.01;\n *\n * const { poolAddress, instructions, initializationCost } = await createSplashPoolInstructions(\n *     devnetRpc,\n *     tokenMintOne,\n *     tokenMintTwo,\n *     initialPrice,\n *     wallet\n * );\n *\n * console.log(`Pool Address: ${poolAddress}`);\n * console.log(`Initialization Cost: ${initializationCost} lamports`);\n */\nexport function createSplashPoolInstructions(\n  rpc: Rpc<GetAccountInfoApi & GetMultipleAccountsApi>,\n  tokenMintA: Address,\n  tokenMintB: Address,\n  initialPrice: number = 1,\n  funder: TransactionSigner = FUNDER,\n): Promise<CreatePoolInstructions> {\n  return createConcentratedLiquidityPoolInstructions(\n    rpc,\n    tokenMintA,\n    tokenMintB,\n    SPLASH_POOL_TICK_SPACING,\n    initialPrice,\n    funder,\n  );\n}\n\n/**\n * Creates the necessary instructions to initialize a Concentrated Liquidity Pool (CLMM) on Orca Whirlpools.\n *\n * @param {SolanaRpc} rpc - A Solana RPC client for communicating with the blockchain.\n * @param {Address} tokenMintA - The first token mint address to include in the pool.\n * @param {Address} tokenMintB - The second token mint address to include in the pool.\n * @param {number} tickSpacing - The spacing between price ticks for the pool.\n * @param {number} [initialPrice=1] - The initial price of token 1 in terms of token 2.\n * @param {TransactionSigner} [funder=FUNDER] - The account that will fund the initialization process.\n *\n * @returns {Promise<CreatePoolInstructions>} A promise that resolves to an object containing the pool creation instructions, the estimated initialization cost, and the pool address.\n *\n * @example\n * import { createConcentratedLiquidityPoolInstructions, setWhirlpoolsConfig } from '@orca-so/whirlpools';\n * import { generateKeyPairSigner, createSolanaRpc, devnet, address } from '@solana/web3.js';\n *\n * await setWhirlpoolsConfig('solanaDevnet');\n * const devnetRpc = createSolanaRpc(devnet('https://api.devnet.solana.com'));\n * const wallet = await generateKeyPairSigner(); // CAUTION: This wallet is not persistent.\n *\n * const tokenMintOne = address(\"So11111111111111111111111111111111111111112\");\n * const tokenMintTwo = address(\"BRjpCHtyQLNCo8gqRUr8jtdAj5AjPYQaoqbvcZiHok1k\"); // devUSDC\n * const tickSpacing = 64;\n * const initialPrice = 0.01;\n *\n * const { poolAddress, instructions, initializationCost } = await createConcentratedLiquidityPoolInstructions(\n *     devnetRpc,\n *     tokenMintOne,\n *     tokenMintTwo,\n *     tickSpacing,\n *     initialPrice,\n *     wallet\n * );\n *\n * console.log(`Pool Address: ${poolAddress}`);\n * console.log(`Initialization Cost: ${initializationCost} lamports`);\n */\nexport async function createConcentratedLiquidityPoolInstructions(\n  rpc: Rpc<GetAccountInfoApi & GetMultipleAccountsApi>,\n  tokenMintA: Address,\n  tokenMintB: Address,\n  tickSpacing: number,\n  initialPrice: number = 1,\n  funder: TransactionSigner = FUNDER,\n): Promise<CreatePoolInstructions> {\n  assert(\n    funder.address !== DEFAULT_ADDRESS,\n    \"Either supply a funder or set the default funder\",\n  );\n  assert(\n    orderMints(tokenMintA, tokenMintB)[0] === tokenMintA,\n    \"Token order needs to be flipped to match the canonical ordering (i.e. sorted on the byte repr. of the mint pubkeys)\",\n  );\n  const instructions: IInstruction[] = [];\n\n  const rent = await fetchSysvarRent(rpc);\n  let nonRefundableRent: bigint = 0n;\n\n  // Since TE mint data is an extension of T mint data, we can use the same fetch function\n  const [mintA, mintB] = await fetchAllMint(rpc, [tokenMintA, tokenMintB]);\n  const decimalsA = mintA.data.decimals;\n  const decimalsB = mintB.data.decimals;\n  const tokenProgramA = mintA.programAddress;\n  const tokenProgramB = mintB.programAddress;\n\n  const initialSqrtPrice = priceToSqrtPrice(initialPrice, decimalsA, decimalsB);\n\n  const [\n    poolAddress,\n    feeTier,\n    tokenBadgeA,\n    tokenBadgeB,\n    tokenVaultA,\n    tokenVaultB,\n  ] = await Promise.all([\n    getWhirlpoolAddress(\n      WHIRLPOOLS_CONFIG_ADDRESS,\n      tokenMintA,\n      tokenMintB,\n      tickSpacing,\n    ).then((x) => x[0]),\n    getFeeTierAddress(WHIRLPOOLS_CONFIG_ADDRESS, tickSpacing).then((x) => x[0]),\n    getTokenBadgeAddress(WHIRLPOOLS_CONFIG_ADDRESS, tokenMintA).then(\n      (x) => x[0],\n    ),\n    getTokenBadgeAddress(WHIRLPOOLS_CONFIG_ADDRESS, tokenMintB).then(\n      (x) => x[0],\n    ),\n    generateKeyPairSigner(),\n    generateKeyPairSigner(),\n  ]);\n\n  instructions.push(\n    getInitializePoolV2Instruction({\n      whirlpoolsConfig: WHIRLPOOLS_CONFIG_ADDRESS,\n      tokenMintA,\n      tokenMintB,\n      tokenBadgeA,\n      tokenBadgeB,\n      funder,\n      whirlpool: poolAddress,\n      tokenVaultA,\n      tokenVaultB,\n      tokenProgramA,\n      tokenProgramB,\n      feeTier,\n      tickSpacing,\n      initialSqrtPrice,\n    }),\n  );\n\n  nonRefundableRent += calculateMinimumBalanceForRentExemption(\n    rent,\n    getTokenSizeForMint(mintA),\n  );\n  nonRefundableRent += calculateMinimumBalanceForRentExemption(\n    rent,\n    getTokenSizeForMint(mintB),\n  );\n  nonRefundableRent += calculateMinimumBalanceForRentExemption(\n    rent,\n    getWhirlpoolSize(),\n  );\n\n  const fullRange = getFullRangeTickIndexes(tickSpacing);\n  const lowerTickIndex = getTickArrayStartTickIndex(\n    fullRange.tickLowerIndex,\n    tickSpacing,\n  );\n  const upperTickIndex = getTickArrayStartTickIndex(\n    fullRange.tickUpperIndex,\n    tickSpacing,\n  );\n  const initialTickIndex = sqrtPriceToTickIndex(initialSqrtPrice);\n  const currentTickIndex = getTickArrayStartTickIndex(\n    initialTickIndex,\n    tickSpacing,\n  );\n\n  const tickArrayIndexes = Array.from(\n    new Set([lowerTickIndex, upperTickIndex, currentTickIndex]),\n  );\n\n  const tickArrayAddresses = await Promise.all(\n    tickArrayIndexes.map((x) =>\n      getTickArrayAddress(poolAddress, x).then((x) => x[0]),\n    ),\n  );\n\n  for (let i = 0; i < tickArrayIndexes.length; i++) {\n    instructions.push(\n      getInitializeTickArrayInstruction({\n        whirlpool: poolAddress,\n        funder,\n        tickArray: tickArrayAddresses[i],\n        startTickIndex: tickArrayIndexes[i],\n      }),\n    );\n    nonRefundableRent += calculateMinimumBalanceForRentExemption(\n      rent,\n      getTickArraySize(),\n    );\n  }\n\n  return {\n    instructions,\n    poolAddress,\n    initializationCost: lamports(nonRefundableRent),\n  };\n}\n","/**\n * To add a new error, follow the instructions at\n * https://github.com/solana-labs/solana-web3.js/tree/master/packages/errors/#adding-a-new-error\n *\n * WARNING:\n *   - Don't remove error codes\n *   - Don't change or reorder error codes.\n *\n * Good naming conventions:\n *   - Prefixing common errors — e.g. under the same package — can be a good way to namespace them. E.g. All codec-related errors start with `SOLANA_ERROR__CODECS__`.\n *   - Use consistent names — e.g. choose `PDA` or `PROGRAM_DERIVED_ADDRESS` and stick with it. Ensure your names are consistent with existing error codes. The decision might have been made for you.\n *   - Recommended prefixes and suffixes:\n *     - `MALFORMED_`: Some input was not constructed properly. E.g. `MALFORMED_BASE58_ENCODED_ADDRESS`.\n *     - `INVALID_`: Some input is invalid (other than because it was MALFORMED). E.g. `INVALID_NUMBER_OF_BYTES`.\n *     - `EXPECTED_`: Some input was different than expected, no need to specify the \"GOT\" part unless necessary. E.g. `EXPECTED_DECODED_ACCOUNT`.\n *     - `_CANNOT_`: Some operation cannot be performed or some input cannot be used due to some condition. E.g. `CANNOT_DECODE_EMPTY_BYTE_ARRAY` or `PDA_CANNOT_END_WITH_PDA_MARKER`.\n *     - `_MUST_BE_`: Some condition must be true. E.g. `NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE`.\n *     - `_FAILED_TO_`: Tried to perform some operation and failed. E.g. `FAILED_TO_DECODE_ACCOUNT`.\n *     - `_NOT_FOUND`: Some operation lead to not finding something. E.g. `ACCOUNT_NOT_FOUND`.\n *     - `_OUT_OF_RANGE`: Some value is out of range. E.g. `ENUM_DISCRIMINATOR_OUT_OF_RANGE`.\n *     - `_EXCEEDED`: Some limit was exceeded. E.g. `PDA_MAX_SEED_LENGTH_EXCEEDED`.\n *     - `_MISMATCH`: Some elements do not match. E.g. `ENCODER_DECODER_FIXED_SIZE_MISMATCH`.\n *     - `_MISSING`: Some required input is missing. E.g. `TRANSACTION_FEE_PAYER_MISSING`.\n *     - `_UNIMPLEMENTED`: Some required component is not available in the environment. E.g. `SUBTLE_CRYPTO_VERIFY_FUNCTION_UNIMPLEMENTED`.\n */\nexport const SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = 1;\nexport const SOLANA_ERROR__INVALID_NONCE = 2;\nexport const SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = 3;\nexport const SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = 4;\nexport const SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = 5;\nexport const SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = 6;\nexport const SOLANA_ERROR__MALFORMED_BIGINT_STRING = 7;\nexport const SOLANA_ERROR__MALFORMED_NUMBER_STRING = 8;\nexport const SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = 9;\n\n// JSON-RPC-related errors.\n// Reserve error codes in the range [-32768, -32000]\n// Keep in sync with https://github.com/anza-xyz/agave/blob/master/rpc-client-api/src/custom_error.rs\nexport const SOLANA_ERROR__JSON_RPC__PARSE_ERROR = -32700;\nexport const SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = -32603;\nexport const SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = -32602;\nexport const SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = -32601;\nexport const SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = -32600;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = -32016;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = -32015;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = -32014;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = -32013;\nexport const SOLANA_ERROR__JSON_RPC__SCAN_ERROR = -32012;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = -32011;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = -32010;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = -32009;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = -32008;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = -32007;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = -32006;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = -32005;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = -32004;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = -32003;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = -32002;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = -32001;\n\n// Addresses-related errors.\n// Reserve error codes in the range [2800000-2800999].\nexport const SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = 2800000;\nexport const SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = 2800001;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = 2800002;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = 2800003;\nexport const SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = 2800004;\nexport const SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = 2800005;\nexport const SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = 2800006;\nexport const SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = 2800007;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = 2800008;\nexport const SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = 2800009;\nexport const SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = 2800010;\n\n// Account-related errors.\n// Reserve error codes in the range [3230000-3230999].\nexport const SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = 3230000;\nexport const SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = 32300001;\nexport const SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = 3230002;\nexport const SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = 3230003;\nexport const SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = 3230004;\n\n// Subtle-Crypto-related errors.\n// Reserve error codes in the range [3610000-3610999].\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = 3610000;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = 3610001;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = 3610002;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = 3610003;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = 3610004;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = 3610005;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = 3610006;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = 3610007;\n\n// Crypto-related errors.\n// Reserve error codes in the range [3611000-3611050].\nexport const SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = 3611000;\n\n// Key-related errors.\n// Reserve error codes in the range [3704000-3704999].\nexport const SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = 3704000;\nexport const SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = 3704001;\nexport const SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = 3704002;\nexport const SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = 3704003;\nexport const SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = 3704004;\n\n// Instruction-related errors.\n// Reserve error codes in the range [4128000-4128999].\nexport const SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = 4128000;\nexport const SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = 4128001;\nexport const SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = 4128002;\n\n// Instruction errors.\n// Reserve error codes starting with [4615000-4615999] for the Rust enum `InstructionError`.\n// Error names here are dictated by the RPC (see ./instruction-error.ts).\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = 4615000;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = 4615001;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = 4615002;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = 4615003;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = 4615004;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = 4615005;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = 4615006;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = 4615007;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = 4615008;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = 4615009;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = 4615010;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = 4615011;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = 4615012;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = 4615013;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = 4615014;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = 4615015;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = 4615016;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = 4615017;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = 4615018;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = 4615019;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = 4615020;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = 4615021;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = 4615022;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = 4615023;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 4615024;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = 4615025;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = 4615026;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = 4615027;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = 4615028;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = 4615029;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = 4615030;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = 4615031;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = 4615032;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = 4615033;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = 4615034;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4615035;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = 4615036;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = 4615037;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = 4615038;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = 4615039;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = 4615040;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = 4615041;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = 4615042;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = 4615043;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = 4615044;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = 4615045;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = 4615046;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = 4615047;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = 4615048;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = 4615049;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = 4615050;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = 4615051;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = 4615052;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = 4615053;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = 4615054;\n\n// Signer-related errors.\n// Reserve error codes in the range [5508000-5508999].\nexport const SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = 5508000;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = 5508001;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = 5508002;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = 5508003;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = 5508004;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = 5508005;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = 5508006;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = 5508007;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = 5508008;\nexport const SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = 5508009;\nexport const SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = 5508010;\nexport const SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = 5508011;\n\n// Transaction-related errors.\n// Reserve error codes in the range [5663000-5663999].\nexport const SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = 5663000;\nexport const SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = 5663001;\nexport const SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = 5663002;\nexport const SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = 5663003;\nexport const SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = 5663004;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = 5663005;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = 5663006;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = 5663007;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = 5663008;\nexport const SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = 5663009;\nexport const SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = 5663010;\nexport const SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = 5663011;\nexport const SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = 5663012;\nexport const SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = 5663013;\nexport const SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE = 5663014;\nexport const SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = 5663015;\nexport const SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = 5663016;\nexport const SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = 5663017;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = 5663018;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT = 5663019;\n\n// Transaction errors.\n// Reserve error codes starting with [7050000-7050999] for the Rust enum `TransactionError`.\n// Error names here are dictated by the RPC (see ./transaction-error.ts).\nexport const SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = 7050000;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = 7050001;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = 7050002;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = 7050003;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = 7050004;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = 7050005;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = 7050006;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = 7050007;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = 7050008;\n// `InstructionError` intentionally omitted.\nexport const SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = 7050009;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = 7050010;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = 7050011;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = 7050012;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = 7050013;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = 7050014;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = 7050015;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 7050016;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = 7050017;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = 7050018;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = 7050019;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = 7050020;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = 7050021;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = 7050022;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = 7050023;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = 7050024;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = 7050025;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = 7050026;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = 7050027;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = 7050028;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = 7050029;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = 7050030;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = 7050031;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = 7050032;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = 7050033;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = 7050034;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = 7050035;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = 7050036;\n\n// Codec-related errors.\n// Reserve error codes in the range [8078000-8078999].\nexport const SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = 8078000;\nexport const SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = 8078001;\nexport const SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = 8078002;\nexport const SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = 8078003;\nexport const SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = 8078004;\nexport const SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = 8078005;\nexport const SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = 8078006;\nexport const SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = 8078007;\nexport const SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = 8078008;\nexport const SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = 8078009;\nexport const SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = 8078010;\nexport const SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = 8078011;\nexport const SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = 8078012;\nexport const SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = 8078013;\nexport const SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = 8078014;\nexport const SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = 8078015;\nexport const SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = 8078016;\nexport const SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = 8078017;\nexport const SOLANA_ERROR__CODECS__INVALID_CONSTANT = 8078018;\nexport const SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = 8078019;\nexport const SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = 8078020;\nexport const SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = 8078021;\nexport const SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = 8078022;\n\n// RPC-related errors.\n// Reserve error codes in the range [8100000-8100999].\nexport const SOLANA_ERROR__RPC__INTEGER_OVERFLOW = 8100000;\nexport const SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = 8100001;\nexport const SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = 8100002;\nexport const SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD = 8100003;\n\n// RPC-Subscriptions-related errors.\n// Reserve error codes in the range [8190000-8190999].\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN = 8190000;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = 8190001;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED = 8190002;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED = 8190003;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT = 8190004;\n\n// Invariant violation errors.\n// Reserve error codes in the range [9900000-9900999].\n// These errors should only be thrown when there is a bug with the\n// library itself and should, in theory, never reach the end user.\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING = 9900000;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE = 9900001;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = 9900002;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = 9900003;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED = 9900004;\n\n/**\n * A union of every Solana error code\n *\n * You might be wondering why this is not a TypeScript enum or const enum.\n *\n * One of the goals of this library is to enable people to use some or none of it without having to\n * bundle all of it.\n *\n * If we made the set of error codes an enum then anyone who imported it (even if to only use a\n * single error code) would be forced to bundle every code and its label.\n *\n * Const enums appear to solve this problem by letting the compiler inline only the codes that are\n * actually used. Unfortunately exporting ambient (const) enums from a library like `@solana/errors`\n * is not safe, for a variety of reasons covered here: https://stackoverflow.com/a/28818850\n */\nexport type SolanaErrorCode =\n    | typeof SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED\n    | typeof SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT\n    | typeof SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT\n    | typeof SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND\n    | typeof SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE\n    | typeof SOLANA_ERROR__ADDRESSES__MALFORMED_PDA\n    | typeof SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED\n    | typeof SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED\n    | typeof SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER\n    | typeof SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED\n    | typeof SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY\n    | typeof SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS\n    | typeof SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL\n    | typeof SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH\n    | typeof SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH\n    | typeof SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH\n    | typeof SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE\n    | typeof SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH\n    | typeof SOLANA_ERROR__CODECS__INVALID_CONSTANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS\n    | typeof SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE\n    | typeof SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES\n    | typeof SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS\n    | typeof SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA\n    | typeof SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR\n    | typeof SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH\n    | typeof SOLANA_ERROR__INVALID_NONCE\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE\n    | typeof SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR\n    | typeof SOLANA_ERROR__JSON_RPC__INVALID_PARAMS\n    | typeof SOLANA_ERROR__JSON_RPC__INVALID_REQUEST\n    | typeof SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND\n    | typeof SOLANA_ERROR__JSON_RPC__PARSE_ERROR\n    | typeof SOLANA_ERROR__JSON_RPC__SCAN_ERROR\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION\n    | typeof SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH\n    | typeof SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH\n    | typeof SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH\n    | typeof SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY\n    | typeof SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__MALFORMED_BIGINT_STRING\n    | typeof SOLANA_ERROR__MALFORMED_NUMBER_STRING\n    | typeof SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD\n    | typeof SOLANA_ERROR__RPC__INTEGER_OVERFLOW\n    | typeof SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR\n    | typeof SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID\n    | typeof SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS\n    | typeof SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING\n    | typeof SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION\n    | typeof SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES\n    | typeof SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME\n    | typeof SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE\n    | typeof SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES\n    | typeof SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE\n    | typeof SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH\n    | typeof SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT;\n\n/**\n * Errors of this type are understood to have an optional `SolanaError` nested inside as `cause`.\n */\nexport type SolanaErrorCodeWithCause = typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE;\n","import {\n    SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND,\n    SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS,\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED,\n    SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS,\n    SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__INVALID_CONSTANT,\n    SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS,\n    SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE,\n    SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES,\n    SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA,\n    SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND,\n    SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR,\n    SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH,\n    SOLANA_ERROR__INVALID_NONCE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING,\n    SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE,\n    SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR,\n    SOLANA_ERROR__JSON_RPC__INVALID_PARAMS,\n    SOLANA_ERROR__JSON_RPC__INVALID_REQUEST,\n    SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND,\n    SOLANA_ERROR__JSON_RPC__PARSE_ERROR,\n    SOLANA_ERROR__JSON_RPC__SCAN_ERROR,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION,\n    SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__MALFORMED_BIGINT_STRING,\n    SOLANA_ERROR__MALFORMED_NUMBER_STRING,\n    SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD,\n    SOLANA_ERROR__RPC__INTEGER_OVERFLOW,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT,\n    SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS,\n    SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER,\n    SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY,\n    SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING,\n    SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n    SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH,\n    SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING,\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN,\n    SolanaErrorCode,\n} from './codes';\nimport { RpcSimulateTransactionResult } from './json-rpc-error';\n\ntype BasicInstructionErrorContext<T extends SolanaErrorCode> = Readonly<{ [P in T]: { index: number } }>;\n\ntype DefaultUnspecifiedErrorContextToUndefined<T> = {\n    [P in SolanaErrorCode]: P extends keyof T ? T[P] : undefined;\n};\n\ntype TypedArrayMutableProperties = 'copyWithin' | 'fill' | 'reverse' | 'set' | 'sort';\ninterface ReadonlyUint8Array extends Omit<Uint8Array, TypedArrayMutableProperties> {\n    readonly [n: number]: number;\n}\n\n/**\n * To add a new error, follow the instructions at\n * https://github.com/solana-labs/solana-web3.js/tree/master/packages/errors/#adding-a-new-error\n *\n * WARNING:\n *   - Don't change or remove members of an error's context.\n */\nexport type SolanaErrorContext = DefaultUnspecifiedErrorContextToUndefined<\n    BasicInstructionErrorContext<\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR\n    > & {\n        [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: {\n            address: string;\n        };\n        [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]: {\n            addresses: string[];\n        };\n        [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: {\n            address: string;\n        };\n        [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: {\n            address: string;\n        };\n        [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: {\n            addresses: string[];\n        };\n        [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: {\n            putativeAddress: string;\n        };\n        [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]: {\n            actual: number;\n            maxSeeds: number;\n        };\n        [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]: {\n            actual: number;\n            index: number;\n            maxSeedLength: number;\n        };\n        [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]: {\n            bump: number;\n        };\n        [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]: {\n            currentBlockHeight: bigint;\n            lastValidBlockHeight: bigint;\n        };\n        [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]: {\n            codecDescription: string;\n        };\n        [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]: {\n            stringValues: string[];\n        };\n        [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]: {\n            encodedBytes: ReadonlyUint8Array;\n            hexEncodedBytes: string;\n            hexSentinel: string;\n            sentinel: ReadonlyUint8Array;\n        };\n        [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]: {\n            decoderFixedSize: number;\n            encoderFixedSize: number;\n        };\n        [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]: {\n            decoderMaxSize: number | undefined;\n            encoderMaxSize: number | undefined;\n        };\n        [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]: {\n            discriminator: bigint | number;\n            formattedValidDiscriminators: string;\n            validDiscriminators: number[];\n        };\n        [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]: {\n            bytesLength: number;\n            codecDescription: string;\n        };\n        [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]: {\n            codecDescription: string;\n            expectedSize: number;\n            hexZeroValue: string;\n            zeroValue: ReadonlyUint8Array;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]: {\n            bytesLength: number;\n            codecDescription: string;\n            expected: number;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_CONSTANT]: {\n            constant: ReadonlyUint8Array;\n            data: ReadonlyUint8Array;\n            hexConstant: string;\n            hexData: string;\n            offset: number;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]: {\n            value: bigint | boolean | number | string | null | undefined;\n            variants: readonly (bigint | boolean | number | string | null | undefined)[];\n        };\n        [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]: {\n            formattedNumericalValues: string;\n            numericalValues: number[];\n            stringValues: string[];\n            variant: number | string | symbol;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]: {\n            value: bigint | boolean | number | string | null | undefined;\n            variants: readonly (bigint | boolean | number | string | null | undefined)[];\n        };\n        [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]: {\n            actual: bigint | number;\n            codecDescription: string;\n            expected: bigint | number;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: {\n            alphabet: string;\n            base: number;\n            value: string;\n        };\n        [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]: {\n            discriminator: bigint | number;\n            maxRange: number;\n            minRange: number;\n        };\n        [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]: {\n            codecDescription: string;\n            max: bigint | number;\n            min: bigint | number;\n            value: bigint | number;\n        };\n        [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]: {\n            bytesLength: number;\n            codecDescription: string;\n            offset: number;\n        };\n        [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]: {\n            decodedBytes: ReadonlyUint8Array;\n            hexDecodedBytes: string;\n            hexSentinel: string;\n            sentinel: ReadonlyUint8Array;\n        };\n        [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]: {\n            maxRange: number;\n            minRange: number;\n            variant: number;\n        };\n        [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: {\n            encodedData: string;\n            index: number;\n        };\n        [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: {\n            code: number;\n            index: number;\n        };\n        [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: {\n            errorName: string;\n            index: number;\n            instructionErrorContext?: unknown;\n        };\n        [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: {\n            data?: Uint8Array;\n            programAddress: string;\n        };\n        [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: {\n            accountAddresses?: string[];\n            programAddress: string;\n        };\n        [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]: {\n            actualProgramAddress: string;\n            expectedProgramAddress: string;\n        };\n        [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__INVALID_NONCE]: {\n            actualNonceValue: string;\n            expectedNonceValue: string;\n        };\n        [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]: {\n            cacheKey: string;\n        };\n        [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED]: {\n            channelName: string;\n            supportedChannelNames: string[];\n        };\n        [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]: {\n            unexpectedValue: unknown;\n        };\n        [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: {\n            contextSlot: bigint;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: {\n            numSlotsBehind?: number;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: Omit<\n            RpcSimulateTransactionResult,\n            'err'\n        >;\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: {\n            byteLength: number;\n        };\n        [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: {\n            value: string;\n        };\n        [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: {\n            value: string;\n        };\n        [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: {\n            nonceAccountAddress: string;\n        };\n        [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN]: {\n            notificationName: string;\n        };\n        [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT]: {\n            errorEvent: Event;\n        };\n        [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD]: {\n            method: string;\n            params: unknown[];\n        };\n        [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]: {\n            argumentLabel: string;\n            keyPath: readonly (number | string | symbol)[];\n            methodName: string;\n            optionalPathLabel: string;\n            path?: string;\n            value: bigint;\n        };\n        [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: {\n            message: string;\n            statusCode: number;\n        };\n        [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]: {\n            headers: string[];\n        };\n        [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: {\n            key: CryptoKey;\n        };\n        [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]: {\n            value: bigint;\n        };\n        [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]: {\n            index: number;\n        };\n        [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]: {\n            accountIndex: number;\n        };\n        [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]: {\n            accountIndex: number;\n        };\n        [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: {\n            errorName: string;\n            transactionErrorContext?: unknown;\n        };\n        [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]: {\n            expectedAddresses: string[];\n            unexpectedAddresses: string[];\n        };\n        [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: {\n            index: number;\n        };\n        [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]: {\n            lookupTableAddresses: string[];\n        };\n        [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]: {\n            highestKnownIndex: number;\n            highestRequestedIndex: number;\n            lookupTableAddress: string;\n        };\n        [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]: {\n            index: number;\n        };\n        [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT]: {\n            unitsConsumed: number;\n        };\n        [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]: {\n            programAddress: string;\n        };\n        [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]: {\n            programAddress: string;\n        };\n        [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]: {\n            numRequiredSignatures: number;\n            signaturesLength: number;\n            signerAddresses: string[];\n        };\n        [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: {\n            addresses: string[];\n        };\n        [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]: {\n            actualVersion: number;\n        };\n    }\n>;\n\nexport function decodeEncodedContext(encodedContext: string): object {\n    const decodedUrlString = __NODEJS__ ? Buffer.from(encodedContext, 'base64').toString('utf8') : atob(encodedContext);\n    return Object.fromEntries(new URLSearchParams(decodedUrlString).entries());\n}\n\nfunction encodeValue(value: unknown): string {\n    if (Array.isArray(value)) {\n        const commaSeparatedValues = value.map(encodeValue).join('%2C%20' /* \", \" */);\n        return '%5B' /* \"[\" */ + commaSeparatedValues + /* \"]\" */ '%5D';\n    } else if (typeof value === 'bigint') {\n        return `${value}n`;\n    } else {\n        return encodeURIComponent(\n            String(\n                value != null && Object.getPrototypeOf(value) === null\n                    ? // Plain objects with no prototype don't have a `toString` method.\n                      // Convert them before stringifying them.\n                      { ...(value as object) }\n                    : value,\n            ),\n        );\n    }\n}\n\nfunction encodeObjectContextEntry([key, value]: [string, unknown]): `${typeof key}=${string}` {\n    return `${key}=${encodeValue(value)}`;\n}\n\nexport function encodeContextObject(context: object): string {\n    const searchParamsString = Object.entries(context).map(encodeObjectContextEntry).join('&');\n    return __NODEJS__ ? Buffer.from(searchParamsString, 'utf8').toString('base64') : btoa(searchParamsString);\n}\n","import {\n    SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND,\n    SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED,\n    SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS,\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY,\n    SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE,\n    SOLANA_ERROR__ADDRESSES__MALFORMED_PDA,\n    SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE,\n    SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED,\n    SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS,\n    SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH,\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__INVALID_CONSTANT,\n    SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS,\n    SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE,\n    SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES,\n    SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE,\n    SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA,\n    SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND,\n    SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR,\n    SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH,\n    SOLANA_ERROR__INVALID_NONCE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING,\n    SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE,\n    SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR,\n    SOLANA_ERROR__JSON_RPC__INVALID_PARAMS,\n    SOLANA_ERROR__JSON_RPC__INVALID_REQUEST,\n    SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND,\n    SOLANA_ERROR__JSON_RPC__PARSE_ERROR,\n    SOLANA_ERROR__JSON_RPC__SCAN_ERROR,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION,\n    SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY,\n    SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE,\n    SOLANA_ERROR__MALFORMED_BIGINT_STRING,\n    SOLANA_ERROR__MALFORMED_NUMBER_STRING,\n    SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD,\n    SOLANA_ERROR__RPC__INTEGER_OVERFLOW,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID,\n    SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS,\n    SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER,\n    SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS,\n    SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING,\n    SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY,\n    SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT,\n    SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING,\n    SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES,\n    SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME,\n    SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING,\n    SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING,\n    SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE,\n    SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n    SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH,\n    SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING,\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED,\n    SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP,\n    SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE,\n    SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT,\n    SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED,\n    SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED,\n    SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED,\n    SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE,\n    SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE,\n    SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT,\n    SolanaErrorCode,\n} from './codes';\n\n/**\n * To add a new error, follow the instructions at\n * https://github.com/solana-labs/solana-web3.js/tree/master/packages/errors#adding-a-new-error\n *\n * WARNING:\n *   - Don't change the meaning of an error message.\n */\nexport const SolanaErrorMessages: Readonly<{\n    // This type makes this data structure exhaustive with respect to `SolanaErrorCode`.\n    // TypeScript will fail to build this project if add an error code without a message.\n    [P in SolanaErrorCode]: string;\n}> = {\n    [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: 'Account not found at address: $address',\n    [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]:\n        'Not all accounts were decoded. Encoded accounts found at addresses: $addresses.',\n    [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: 'Expected decoded account at address: $address',\n    [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: 'Failed to decode account data at address: $address',\n    [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: 'Accounts not found at addresses: $addresses',\n    [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED]:\n        'Unable to find a viable program address bump seed.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: '$putativeAddress is not a base58-encoded address.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]:\n        'Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY]: 'The `CryptoKey` must be an `Ed25519` public key.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE]: 'Invalid seeds; point must fall off the Ed25519 curve.',\n    [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA]:\n        'Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].',\n    [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]:\n        'A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.',\n    [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]:\n        'The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.',\n    [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]:\n        'Expected program derived address bump to be in the range [0, 255], got: $bump.',\n    [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER]: 'Program address cannot end with PDA marker.',\n    [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]:\n        'Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.',\n    [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]:\n        'Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.',\n    [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]:\n        'The network has progressed past the last block for which this transaction could have been committed.',\n    [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]:\n        'Codec [$codecDescription] cannot decode empty byte arrays.',\n    [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]:\n        'Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.',\n    [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]:\n        'Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].',\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]:\n        'Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].',\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]:\n        'Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].',\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH]:\n        'Encoder and decoder must either both be fixed-size or variable-size.',\n    [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]:\n        'Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.',\n    [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH]: 'Expected a fixed-size codec, got a variable-size one.',\n    [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]:\n        'Codec [$codecDescription] expected a positive byte length, got $bytesLength.',\n    [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH]: 'Expected a variable-size codec, got a fixed-size one.',\n    [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]:\n        'Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].',\n    [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]:\n        'Codec [$codecDescription] expected $expected bytes, got $bytesLength.',\n    [SOLANA_ERROR__CODECS__INVALID_CONSTANT]:\n        'Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].',\n    [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]:\n        'Invalid discriminated union variant. Expected one of [$variants], got $value.',\n    [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]:\n        'Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.',\n    [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]:\n        'Invalid literal union variant. Expected one of [$variants], got $value.',\n    [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]:\n        'Expected [$codecDescription] to have $expected items, got $actual.',\n    [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: 'Invalid value $value for base $base with alphabet $alphabet.',\n    [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]:\n        'Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.',\n    [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]:\n        'Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.',\n    [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]:\n        'Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.',\n    [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]:\n        'Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].',\n    [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]:\n        'Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.',\n    [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED]: 'No random values implementation could be found.',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED]: 'instruction requires an uninitialized account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED]:\n        'instruction tries to borrow reference for an account which is already borrowed',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]:\n        'instruction left account with an outstanding borrowed reference',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED]:\n        \"program other than the account's owner changed the size of the account data\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL]: 'account data too small for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE]: 'instruction expected an executable account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT]:\n        'An account does not have enough lamports to be rent-exempt',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW]: 'Program arithmetic overflowed',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: 'Failed to serialize or deserialize account data: $encodedData',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS]:\n        'Builtin programs must consume compute units',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH]: 'Cross-program invocation call depth too deep',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED]: 'Computational budget exceeded',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: 'custom program error: #$code',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX]: 'instruction contains duplicate accounts',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC]:\n        'instruction modifications of multiply-passed account differ',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT]: 'executable accounts must be rent exempt',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED]: 'instruction changed executable accounts data',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE]:\n        'instruction changed the balance of an executable account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED]: 'instruction changed executable bit of an account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED]:\n        'instruction modified data of an account it does not own',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND]:\n        'instruction spent from the balance of an account it does not own',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR]: 'generic instruction error',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER]: 'Provided owner is not allowed',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE]: 'Account is immutable',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY]: 'Incorrect authority provided',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID]: 'incorrect program id for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS]: 'insufficient funds for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA]: 'invalid account data for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER]: 'Invalid account owner',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT]: 'invalid program argument',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR]: 'program returned invalid error code',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA]: 'invalid instruction data',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC]: 'Failed to reallocate account data',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS]: 'Provided seeds do not result in a valid address',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED]:\n        'Accounts data allocations exceeded the maximum allowed per transaction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED]: 'Max accounts exceeded',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED]: 'Max instruction trace length exceeded',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED]:\n        'Length of the seed is too long for address generation',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT]: 'An account required by the instruction is missing',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE]: 'missing required signature for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID]:\n        'instruction illegally modified the program id of an account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS]: 'insufficient account keys for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION]:\n        'Cross-program invocation with unauthorized signer or writable account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE]:\n        'Failed to create program execution environment',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE]: 'Program failed to compile',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE]: 'Program failed to complete',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED]: 'instruction modified data of a read-only account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE]:\n        'instruction changed the balance of a read-only account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED]:\n        'Cross-program invocation reentrancy not allowed for this instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED]: 'instruction modified rent epoch of an account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION]:\n        'sum of account balances before and after instruction do not match',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT]: 'instruction requires an initialized account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: '',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID]: 'Unsupported program id',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR]: 'Unsupported sysvar',\n    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: 'The instruction does not have any accounts.',\n    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: 'The instruction does not have any data.',\n    [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]:\n        'Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.',\n    [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]:\n        'Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.',\n    [SOLANA_ERROR__INVALID_NONCE]:\n        'The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]:\n        'Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It ' +\n        'should be impossible to hit this error; please file an issue at ' +\n        'https://sola.na/web3invariant',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED]:\n        'Invariant violation: This data publisher does not publish to the channel named ' +\n        '`$channelName`. Supported channels include $supportedChannelNames.',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE]:\n        'Invariant violation: WebSocket message iterator state is corrupt; iterated without first ' +\n        'resolving existing message promise. It should be impossible to hit this error; please ' +\n        'file an issue at https://sola.na/web3invariant',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING]:\n        'Invariant violation: WebSocket message iterator is missing state storage. It should be ' +\n        'impossible to hit this error; please file an issue at https://sola.na/web3invariant',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]:\n        'Invariant violation: Switch statement non-exhaustive. Received unexpected value ' +\n        '`$unexpectedValue`. It should be impossible to hit this error; please file an issue at ' +\n        'https://sola.na/web3invariant',\n    [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: 'JSON-RPC error: Internal JSON-RPC error ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: 'JSON-RPC error: Invalid method parameter(s) ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]:\n        'JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]:\n        'JSON-RPC error: The method does not exist / is not available ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]:\n        'JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: 'Minimum context slot has not been reached',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: 'Node is unhealthy; behind by $numSlotsBehind slots',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT]: 'No snapshot',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: 'Transaction simulation failed',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE]:\n        'Transaction history is not available from this node',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH]: 'Transaction signature length mismatch',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE]:\n        'Transaction signature verification failure',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: '$__serverMessage',\n    [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: 'Key pair bytes must be of length 64, got $byteLength.',\n    [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]:\n        'Expected private key bytes with length 32. Actual length: $actualLength.',\n    [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]:\n        'Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.',\n    [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY]:\n        'The provided private key does not match the provided public key.',\n    [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]:\n        'Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.',\n    [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE]: 'Lamports value must be in the range [0, 2e64-1]',\n    [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: '`$value` cannot be parsed as a `BigInt`',\n    [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: '`$value` cannot be parsed as a `Number`',\n    [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: 'No nonce account could be found at address `$nonceAccountAddress`',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN]:\n        \"The notification name must end in 'Notifications' and the API must supply a \" +\n        \"subscription plan creator function for the notification '$notificationName'.\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED]:\n        'WebSocket was closed before payload could be added to the send buffer',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED]: 'WebSocket connection closed',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT]: 'WebSocket failed to connect',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID]:\n        'Failed to obtain a subscription id from the server',\n    [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD]: 'Could not find an API plan for RPC method: `$method`',\n    [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]:\n        'The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was ' +\n        '`$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds ' +\n        '`Number.MAX_SAFE_INTEGER`.',\n    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: 'HTTP error ($statusCode): $message',\n    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]:\n        'HTTP header(s) forbidden: $headers. Learn more at ' +\n        'https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.',\n    [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]:\n        'Multiple distinct signers were identified for address `$address`. Please ensure that ' +\n        'you are using the same signer instance for each address.',\n    [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]:\n        'The provided value does not implement the `KeyPairSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]:\n        'The provided value does not implement the `MessageModifyingSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]:\n        'The provided value does not implement the `MessagePartialSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]:\n        'The provided value does not implement any of the `MessageSigner` interfaces',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]:\n        'The provided value does not implement the `TransactionModifyingSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]:\n        'The provided value does not implement the `TransactionPartialSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]:\n        'The provided value does not implement the `TransactionSendingSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]:\n        'The provided value does not implement any of the `TransactionSigner` interfaces',\n    [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS]:\n        'More than one `TransactionSendingSigner` was identified.',\n    [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING]:\n        'No `TransactionSendingSigner` was identified. Please provide a valid ' +\n        '`ITransactionWithSingleSendingSigner` transaction.',\n    [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED]:\n        'Wallet account signers do not support signing multiple messages/transactions in a single operation',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: 'Cannot export a non-extractable key.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED]: 'No digest implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT]:\n        'Cryptographic operations are only allowed in secure browser contexts. Read more ' +\n        'here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED]:\n        'This runtime does not support the generation of Ed25519 key pairs.\\n\\nInstall ' +\n        '@solana/webcrypto-ed25519-polyfill and call its `install` function before generating keys in ' +\n        'environments that do not support Ed25519.\\n\\nFor a list of runtimes that ' +\n        'currently support Ed25519 operations, visit ' +\n        'https://github.com/WICG/webcrypto-secure-curves/issues/20.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED]:\n        'No signature verification implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED]: 'No key generation implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED]: 'No signing implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED]: 'No key export implementation could be found.',\n    [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]:\n        'Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]:\n        'Transaction processing left an account with an outstanding borrowed reference',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE]: 'Account in use',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE]: 'Account loaded twice',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND]:\n        'Attempt to debit an account but found no record of a prior credit.',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND]:\n        \"Transaction loads an address table account that doesn't exist\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED]: 'This transaction has already been processed',\n    [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND]: 'Blockhash not found',\n    [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP]: 'Loader call chain is too deep',\n    [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE]:\n        'Transactions are currently disabled due to cluster maintenance',\n    [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]:\n        'Transaction contains a duplicate instruction ($index) that is not allowed',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE]: 'Insufficient funds for fee',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]:\n        'Transaction results in an account ($accountIndex) with insufficient funds for rent',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE]: 'This account may not be used to pay transaction fees',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX]: 'Transaction contains an invalid account reference',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA]:\n        'Transaction loads an address table account with invalid data',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX]:\n        'Transaction address table lookup uses an invalid index',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER]:\n        'Transaction loads an address table account with an invalid owner',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT]:\n        'LoadedAccountsDataSizeLimit set for transaction must be greater than 0.',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION]:\n        'This program may not be used for executing instructions',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT]:\n        'Transaction leaves an account with a lower balance than rent-exempt minimum',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT]:\n        'Transaction loads a writable account that cannot be written',\n    [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED]:\n        'Transaction exceeded max loaded accounts data size cap',\n    [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE]:\n        'Transaction requires a fee but has no signature present',\n    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND]: 'Attempt to load a program that does not exist',\n    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]:\n        'Execution of the program referenced by account at index $accountIndex is temporarily restricted.',\n    [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED]: 'ResanitizationNeeded',\n    [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE]: 'Transaction failed to sanitize accounts offsets correctly',\n    [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE]: 'Transaction did not pass signature verification',\n    [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS]: 'Transaction locked too many accounts',\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION]:\n        'Sum of account balances before and after transaction do not match',\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: 'The transaction failed with the error `$errorName`',\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION]: 'Transaction version is unsupported',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT]:\n        'Transaction would exceed account data limit within the block',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT]:\n        'Transaction would exceed total account data limit',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT]:\n        'Transaction would exceed max account limit within the block',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT]:\n        'Transaction would exceed max Block Cost Limit',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT]: 'Transaction would exceed max Vote Cost Limit',\n    [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]:\n        'Attempted to sign a transaction with an address that is not a signer for it',\n    [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: 'Transaction is missing an address at index: $index.',\n    [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES]:\n        'Transaction has no expected signers therefore it cannot be encoded',\n    [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME]: 'Transaction does not have a blockhash lifetime',\n    [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME]: 'Transaction is not a durable nonce transaction',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]:\n        'Contents of these address lookup tables unknown: $lookupTableAddresses',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]:\n        'Lookup of address at index $highestRequestedIndex failed for lookup table ' +\n        '`$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table ' +\n        'may have been extended since its contents were retrieved',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING]: 'No fee payer set in CompiledTransaction',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]:\n        'Could not find program address at index $index',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT]:\n        'Failed to estimate the compute unit consumption for this transaction message. This is ' +\n        'likely because simulating the transaction failed. Inspect the `cause` property of this ' +\n        'error to learn more',\n    [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT]:\n        'Transaction failed when it was simulated in order to estimate the compute unit consumption. ' +\n        'The compute unit estimate provided is for a transaction that failed when simulated and may not ' +\n        'be representative of the compute units this transaction would consume if successful. Inspect the ' +\n        '`cause` property of this error to learn more',\n    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING]: 'Transaction is missing a fee payer.',\n    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING]:\n        \"Could not determine this transaction's signature. Make sure that the transaction has \" +\n        'been signed by its fee payer.',\n    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE]:\n        'Transaction first instruction is not advance nonce account instruction.',\n    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING]:\n        'Transaction with no instructions cannot be durable nonce transaction.',\n    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]:\n        'This transaction includes an address (`$programAddress`) which is both ' +\n        'invoked and set as the fee payer. Program addresses may not pay fees',\n    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]:\n        'This transaction includes an address (`$programAddress`) which is both invoked and ' +\n        'marked writable. Program addresses may not be writable',\n    [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]:\n        'The transaction message expected the transaction to have $signerAddressesLength signatures, got $signaturesLength.',\n    [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: 'Transaction is missing signatures for addresses: $addresses.',\n    [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]:\n        'Transaction version must be in the range [0, 127]. `$actualVersion` given',\n};\n","import { SolanaErrorCode } from './codes';\nimport { encodeContextObject } from './context';\nimport { SolanaErrorMessages } from './messages';\n\nconst enum StateType {\n    EscapeSequence,\n    Text,\n    Variable,\n}\ntype State = Readonly<{\n    [START_INDEX]: number;\n    [TYPE]: StateType;\n}>;\nconst START_INDEX = 'i';\nconst TYPE = 't';\n\nexport function getHumanReadableErrorMessage<TErrorCode extends SolanaErrorCode>(\n    code: TErrorCode,\n    context: object = {},\n): string {\n    const messageFormatString = SolanaErrorMessages[code];\n    if (messageFormatString.length === 0) {\n        return '';\n    }\n    let state: State;\n    function commitStateUpTo(endIndex?: number) {\n        if (state[TYPE] === StateType.Variable) {\n            const variableName = messageFormatString.slice(state[START_INDEX] + 1, endIndex);\n\n            fragments.push(\n                variableName in context ? `${context[variableName as keyof typeof context]}` : `$${variableName}`,\n            );\n        } else if (state[TYPE] === StateType.Text) {\n            fragments.push(messageFormatString.slice(state[START_INDEX], endIndex));\n        }\n    }\n    const fragments: string[] = [];\n    messageFormatString.split('').forEach((char, ii) => {\n        if (ii === 0) {\n            state = {\n                [START_INDEX]: 0,\n                [TYPE]:\n                    messageFormatString[0] === '\\\\'\n                        ? StateType.EscapeSequence\n                        : messageFormatString[0] === '$'\n                          ? StateType.Variable\n                          : StateType.Text,\n            };\n            return;\n        }\n        let nextState;\n        switch (state[TYPE]) {\n            case StateType.EscapeSequence:\n                nextState = { [START_INDEX]: ii, [TYPE]: StateType.Text };\n                break;\n            case StateType.Text:\n                if (char === '\\\\') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.EscapeSequence };\n                } else if (char === '$') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Variable };\n                }\n                break;\n            case StateType.Variable:\n                if (char === '\\\\') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.EscapeSequence };\n                } else if (char === '$') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Variable };\n                } else if (!char.match(/\\w/)) {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Text };\n                }\n                break;\n        }\n        if (nextState) {\n            if (state !== nextState) {\n                commitStateUpTo(ii);\n            }\n            state = nextState;\n        }\n    });\n    commitStateUpTo();\n    return fragments.join('');\n}\n\nexport function getErrorMessage<TErrorCode extends SolanaErrorCode>(\n    code: TErrorCode,\n    context: Record<string, unknown> = {},\n): string {\n    if (process.env.NODE_ENV !== \"production\") {\n        return getHumanReadableErrorMessage(code, context);\n    } else {\n        let decodingAdviceMessage = `Solana error #${code}; Decode this error by running \\`npx @solana/errors decode -- ${code}`;\n        if (Object.keys(context).length) {\n            /**\n             * DANGER: Be sure that the shell command is escaped in such a way that makes it\n             *         impossible for someone to craft malicious context values that would result in\n             *         an exploit against anyone who bindly copy/pastes it into their terminal.\n             */\n            decodingAdviceMessage += ` '${encodeContextObject(context)}'`;\n        }\n        return `${decodingAdviceMessage}\\``;\n    }\n}\n","import { SolanaErrorCode, SolanaErrorCodeWithCause } from './codes';\nimport { SolanaErrorContext } from './context';\nimport { getErrorMessage } from './message-formatter';\n\nexport function isSolanaError<TErrorCode extends SolanaErrorCode>(\n    e: unknown,\n    code?: TErrorCode,\n): e is SolanaError<TErrorCode> {\n    const isSolanaError = e instanceof Error && e.name === 'SolanaError';\n    if (isSolanaError) {\n        if (code !== undefined) {\n            return (e as SolanaError<TErrorCode>).context.__code === code;\n        }\n        return true;\n    }\n    return false;\n}\n\ntype SolanaErrorCodedContext = Readonly<{\n    [P in SolanaErrorCode]: (SolanaErrorContext[P] extends undefined ? object : SolanaErrorContext[P]) & {\n        __code: P;\n    };\n}>;\n\nexport class SolanaError<TErrorCode extends SolanaErrorCode = SolanaErrorCode> extends Error {\n    readonly cause?: TErrorCode extends SolanaErrorCodeWithCause ? SolanaError : unknown = this.cause;\n    readonly context: SolanaErrorCodedContext[TErrorCode];\n    constructor(\n        ...[code, contextAndErrorOptions]: SolanaErrorContext[TErrorCode] extends undefined\n            ? [code: TErrorCode, errorOptions?: ErrorOptions | undefined]\n            : [code: TErrorCode, contextAndErrorOptions: SolanaErrorContext[TErrorCode] & (ErrorOptions | undefined)]\n    ) {\n        let context: SolanaErrorContext[TErrorCode] | undefined;\n        let errorOptions: ErrorOptions | undefined;\n        if (contextAndErrorOptions) {\n            // If the `ErrorOptions` type ever changes, update this code.\n            const { cause, ...contextRest } = contextAndErrorOptions;\n            if (cause) {\n                errorOptions = { cause };\n            }\n            if (Object.keys(contextRest).length > 0) {\n                context = contextRest as SolanaErrorContext[TErrorCode];\n            }\n        }\n        const message = getErrorMessage(code, context);\n        super(message, errorOptions);\n        this.context = {\n            __code: code,\n            ...context,\n        } as SolanaErrorCodedContext[TErrorCode];\n        // This is necessary so that `isSolanaError()` can identify a `SolanaError` without having\n        // to import the class for use in an `instanceof` check.\n        this.name = 'SolanaError';\n    }\n}\n","export function safeCaptureStackTrace(...args: Parameters<typeof Error.captureStackTrace>): void {\n    if ('captureStackTrace' in Error && typeof Error.captureStackTrace === 'function') {\n        Error.captureStackTrace(...args);\n    }\n}\n","import { SolanaErrorCode } from './codes';\nimport { SolanaErrorContext } from './context';\nimport { SolanaError } from './error';\nimport { safeCaptureStackTrace } from './stack-trace';\n\ntype Config = Readonly<{\n    /**\n     * Oh, hello. You might wonder what in tarnation is going on here. Allow us to explain.\n     *\n     * One of the goals of `@solana/errors` is to allow errors that are not interesting to your\n     * application to shake out of your app bundle in production. This means that we must never\n     * export large hardcoded maps of error codes/messages.\n     *\n     * Unfortunately, where instruction and transaction errors from the RPC are concerned, we have\n     * no choice but to keep a map between the RPC `rpcEnumError` enum name and its corresponding\n     * `SolanaError` code. In the interest of implementing that map in as few bytes of source code\n     * as possible, we do the following:\n     *\n     *   1. Reserve a block of sequential error codes for the enum in question\n     *   2. Hardcode the list of enum names in that same order\n     *   3. Match the enum error name from the RPC with its index in that list, and reconstruct the\n     *      `SolanaError` code by adding the `errorCodeBaseOffset` to that index\n     */\n    errorCodeBaseOffset: number;\n    getErrorContext: (\n        errorCode: SolanaErrorCode,\n        rpcErrorName: string,\n        rpcErrorContext?: unknown,\n    ) => SolanaErrorContext[SolanaErrorCode];\n    orderedErrorNames: string[];\n    rpcEnumError: string | { [key: string]: unknown };\n}>;\n\nexport function getSolanaErrorFromRpcError(\n    { errorCodeBaseOffset, getErrorContext, orderedErrorNames, rpcEnumError }: Config,\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n    constructorOpt: Function,\n): SolanaError {\n    let rpcErrorName;\n    let rpcErrorContext;\n    if (typeof rpcEnumError === 'string') {\n        rpcErrorName = rpcEnumError;\n    } else {\n        rpcErrorName = Object.keys(rpcEnumError)[0];\n        rpcErrorContext = rpcEnumError[rpcErrorName];\n    }\n    const codeOffset = orderedErrorNames.indexOf(rpcErrorName);\n    const errorCode = (errorCodeBaseOffset + codeOffset) as SolanaErrorCode;\n    const errorContext = getErrorContext(errorCode, rpcErrorName, rpcErrorContext);\n    const err = new SolanaError(errorCode, errorContext);\n    safeCaptureStackTrace(err, constructorOpt);\n    return err;\n}\n","import {\n    SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN,\n} from './codes';\nimport { SolanaError } from './error';\nimport { getSolanaErrorFromRpcError } from './rpc-enum-errors';\n\nconst ORDERED_ERROR_NAMES = [\n    // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/program/src/instruction.rs\n    // If this list ever gets too large, consider implementing a compression strategy like this:\n    // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n    'GenericError',\n    'InvalidArgument',\n    'InvalidInstructionData',\n    'InvalidAccountData',\n    'AccountDataTooSmall',\n    'InsufficientFunds',\n    'IncorrectProgramId',\n    'MissingRequiredSignature',\n    'AccountAlreadyInitialized',\n    'UninitializedAccount',\n    'UnbalancedInstruction',\n    'ModifiedProgramId',\n    'ExternalAccountLamportSpend',\n    'ExternalAccountDataModified',\n    'ReadonlyLamportChange',\n    'ReadonlyDataModified',\n    'DuplicateAccountIndex',\n    'ExecutableModified',\n    'RentEpochModified',\n    'NotEnoughAccountKeys',\n    'AccountDataSizeChanged',\n    'AccountNotExecutable',\n    'AccountBorrowFailed',\n    'AccountBorrowOutstanding',\n    'DuplicateAccountOutOfSync',\n    'Custom',\n    'InvalidError',\n    'ExecutableDataModified',\n    'ExecutableLamportChange',\n    'ExecutableAccountNotRentExempt',\n    'UnsupportedProgramId',\n    'CallDepth',\n    'MissingAccount',\n    'ReentrancyNotAllowed',\n    'MaxSeedLengthExceeded',\n    'InvalidSeeds',\n    'InvalidRealloc',\n    'ComputationalBudgetExceeded',\n    'PrivilegeEscalation',\n    'ProgramEnvironmentSetupFailure',\n    'ProgramFailedToComplete',\n    'ProgramFailedToCompile',\n    'Immutable',\n    'IncorrectAuthority',\n    'BorshIoError',\n    'AccountNotRentExempt',\n    'InvalidAccountOwner',\n    'ArithmeticOverflow',\n    'UnsupportedSysvar',\n    'IllegalOwner',\n    'MaxAccountsDataAllocationsExceeded',\n    'MaxAccountsExceeded',\n    'MaxInstructionTraceLengthExceeded',\n    'BuiltinProgramsMustConsumeComputeUnits',\n];\n\nexport function getSolanaErrorFromInstructionError(\n    index: bigint | number,\n    instructionError: string | { [key: string]: unknown },\n): SolanaError {\n    const numberIndex = Number(index);\n    return getSolanaErrorFromRpcError(\n        {\n            errorCodeBaseOffset: 4615001,\n            getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {\n                if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN) {\n                    return {\n                        errorName: rpcErrorName,\n                        index: numberIndex,\n                        ...(rpcErrorContext !== undefined ? { instructionErrorContext: rpcErrorContext } : null),\n                    };\n                } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM) {\n                    return {\n                        code: Number(rpcErrorContext as bigint | number),\n                        index: numberIndex,\n                    };\n                } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR) {\n                    return {\n                        encodedData: rpcErrorContext as string,\n                        index: numberIndex,\n                    };\n                }\n                return { index: numberIndex };\n            },\n            orderedErrorNames: ORDERED_ERROR_NAMES,\n            rpcEnumError: instructionError,\n        },\n        getSolanaErrorFromInstructionError,\n    );\n}\n","import {\n    SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN,\n} from './codes';\nimport { SolanaError } from './error';\nimport { getSolanaErrorFromInstructionError } from './instruction-error';\nimport { getSolanaErrorFromRpcError } from './rpc-enum-errors';\n\n/**\n * How to add an error when an entry is added to the RPC `TransactionError` enum:\n *\n *   1. Follow the instructions in `./codes.ts` to add a corresponding Solana error code\n *   2. Add the `TransactionError` enum name in the same order as it appears in `./codes.ts`\n *   3. Add the new error name/code mapping to `./__tests__/transaction-error-test.ts`\n */\nconst ORDERED_ERROR_NAMES = [\n    // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/src/transaction/error.rs\n    // If this list ever gets too large, consider implementing a compression strategy like this:\n    // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n    'AccountInUse',\n    'AccountLoadedTwice',\n    'AccountNotFound',\n    'ProgramAccountNotFound',\n    'InsufficientFundsForFee',\n    'InvalidAccountForFee',\n    'AlreadyProcessed',\n    'BlockhashNotFound',\n    // `InstructionError` intentionally omitted; delegated to `getSolanaErrorFromInstructionError`\n    'CallChainTooDeep',\n    'MissingSignatureForFee',\n    'InvalidAccountIndex',\n    'SignatureFailure',\n    'InvalidProgramForExecution',\n    'SanitizeFailure',\n    'ClusterMaintenance',\n    'AccountBorrowOutstanding',\n    'WouldExceedMaxBlockCostLimit',\n    'UnsupportedVersion',\n    'InvalidWritableAccount',\n    'WouldExceedMaxAccountCostLimit',\n    'WouldExceedAccountDataBlockLimit',\n    'TooManyAccountLocks',\n    'AddressLookupTableNotFound',\n    'InvalidAddressLookupTableOwner',\n    'InvalidAddressLookupTableData',\n    'InvalidAddressLookupTableIndex',\n    'InvalidRentPayingAccount',\n    'WouldExceedMaxVoteCostLimit',\n    'WouldExceedAccountDataTotalLimit',\n    'DuplicateInstruction',\n    'InsufficientFundsForRent',\n    'MaxLoadedAccountsDataSizeExceeded',\n    'InvalidLoadedAccountsDataSizeLimit',\n    'ResanitizationNeeded',\n    'ProgramExecutionTemporarilyRestricted',\n    'UnbalancedTransaction',\n];\n\nexport function getSolanaErrorFromTransactionError(transactionError: string | { [key: string]: unknown }): SolanaError {\n    if (typeof transactionError === 'object' && 'InstructionError' in transactionError) {\n        return getSolanaErrorFromInstructionError(\n            ...(transactionError.InstructionError as Parameters<typeof getSolanaErrorFromInstructionError>),\n        );\n    }\n    return getSolanaErrorFromRpcError(\n        {\n            errorCodeBaseOffset: 7050001,\n            getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {\n                if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN) {\n                    return {\n                        errorName: rpcErrorName,\n                        ...(rpcErrorContext !== undefined ? { transactionErrorContext: rpcErrorContext } : null),\n                    };\n                } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION) {\n                    return {\n                        index: Number(rpcErrorContext as bigint | number),\n                    };\n                } else if (\n                    errorCode === SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT ||\n                    errorCode === SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED\n                ) {\n                    return {\n                        accountIndex: Number((rpcErrorContext as { account_index: bigint | number }).account_index),\n                    };\n                }\n            },\n            orderedErrorNames: ORDERED_ERROR_NAMES,\n            rpcEnumError: transactionError,\n        },\n        getSolanaErrorFromTransactionError,\n    );\n}\n","import {\n    SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR,\n    SOLANA_ERROR__JSON_RPC__INVALID_PARAMS,\n    SOLANA_ERROR__JSON_RPC__INVALID_REQUEST,\n    SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND,\n    SOLANA_ERROR__JSON_RPC__PARSE_ERROR,\n    SOLANA_ERROR__JSON_RPC__SCAN_ERROR,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION,\n    SolanaErrorCode,\n} from './codes';\nimport { SolanaErrorContext } from './context';\nimport { SolanaError } from './error';\nimport { safeCaptureStackTrace } from './stack-trace';\nimport { getSolanaErrorFromTransactionError } from './transaction-error';\n\ninterface RpcErrorResponse {\n    code: bigint | number;\n    data?: unknown;\n    message: string;\n}\n\ntype TransactionError = string | { [key: string]: unknown };\n\n// Keep in sync with https://github.com/anza-xyz/agave/blob/master/rpc-client-api/src/response.rs\nexport interface RpcSimulateTransactionResult {\n    accounts:\n        | ({\n              data:\n                  | string // LegacyBinary\n                  | {\n                        // Json\n                        parsed: unknown;\n                        program: string;\n                        space: number;\n                    }\n                  // Binary\n                  | [encodedBytes: string, encoding: 'base58' | 'base64' | 'base64+zstd' | 'binary' | 'jsonParsed'];\n              executable: boolean;\n              lamports: number;\n              owner: string;\n              rentEpoch: number;\n              space?: number;\n          } | null)[]\n        | null;\n    err: TransactionError | null;\n    // Enabled by `enable_cpi_recording`\n    innerInstructions?:\n        | {\n              index: number;\n              instructions: (\n                  | {\n                        // Compiled\n                        accounts: number[];\n                        data: string;\n                        programIdIndex: number;\n                        stackHeight?: number;\n                    }\n                  | {\n                        // Parsed\n                        parsed: unknown;\n                        program: string;\n                        programId: string;\n                        stackHeight?: number;\n                    }\n                  | {\n                        // PartiallyDecoded\n                        accounts: string[];\n                        data: string;\n                        programId: string;\n                        stackHeight?: number;\n                    }\n              )[];\n          }[]\n        | null;\n    logs: string[] | null;\n    returnData: {\n        data: [string, 'base64'];\n        programId: string;\n    } | null;\n    unitsConsumed: number | null;\n}\n\nexport function getSolanaErrorFromJsonRpcError({ code: rawCode, data, message }: RpcErrorResponse): SolanaError {\n    let out: SolanaError;\n    const code = Number(rawCode);\n    if (code === SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE) {\n        const { err, ...preflightErrorContext } = data as RpcSimulateTransactionResult;\n        const causeObject = err ? { cause: getSolanaErrorFromTransactionError(err) } : null;\n        out = new SolanaError(SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE, {\n            ...preflightErrorContext,\n            ...causeObject,\n        });\n    } else {\n        let errorContext;\n        switch (code) {\n            case SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR:\n            case SOLANA_ERROR__JSON_RPC__INVALID_PARAMS:\n            case SOLANA_ERROR__JSON_RPC__INVALID_REQUEST:\n            case SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND:\n            case SOLANA_ERROR__JSON_RPC__PARSE_ERROR:\n            case SOLANA_ERROR__JSON_RPC__SCAN_ERROR:\n            case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP:\n            case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE:\n            case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:\n            case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:\n            case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:\n            case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED:\n            case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:\n            case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:\n                // The server supplies no structured data, but rather a pre-formatted message. Put\n                // the server message in `context` so as not to completely lose the data. The long\n                // term fix for this is to add data to the server responses and modify the\n                // messages in `@solana/errors` to be actual format strings.\n                errorContext = { __serverMessage: message };\n                break;\n            default:\n                if (typeof data === 'object' && !Array.isArray(data)) {\n                    errorContext = data;\n                }\n        }\n        out = new SolanaError(code as SolanaErrorCode, errorContext as SolanaErrorContext[SolanaErrorCode]);\n    }\n    safeCaptureStackTrace(out, getSolanaErrorFromJsonRpcError);\n    return out;\n}\n","import { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Concatenates an array of `Uint8Array`s into a single `Uint8Array`.\n * Reuses the original byte array when applicable.\n */\nexport const mergeBytes = (byteArrays: Uint8Array[]): Uint8Array => {\n    const nonEmptyByteArrays = byteArrays.filter(arr => arr.length);\n    if (nonEmptyByteArrays.length === 0) {\n        return byteArrays.length ? byteArrays[0] : new Uint8Array();\n    }\n\n    if (nonEmptyByteArrays.length === 1) {\n        return nonEmptyByteArrays[0];\n    }\n\n    const totalLength = nonEmptyByteArrays.reduce((total, arr) => total + arr.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    nonEmptyByteArrays.forEach(arr => {\n        result.set(arr, offset);\n        offset += arr.length;\n    });\n    return result;\n};\n\n/**\n * Pads a `Uint8Array` with zeroes to the specified length.\n * If the array is longer than the specified length, it is returned as-is.\n */\nexport const padBytes = (bytes: ReadonlyUint8Array | Uint8Array, length: number): ReadonlyUint8Array | Uint8Array => {\n    if (bytes.length >= length) return bytes;\n    const paddedBytes = new Uint8Array(length).fill(0);\n    paddedBytes.set(bytes);\n    return paddedBytes;\n};\n\n/**\n * Fixes a `Uint8Array` to the specified length.\n * If the array is longer than the specified length, it is truncated.\n * If the array is shorter than the specified length, it is padded with zeroes.\n */\nexport const fixBytes = (bytes: ReadonlyUint8Array | Uint8Array, length: number): ReadonlyUint8Array | Uint8Array =>\n    padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\n\n/**\n * Returns true if and only if the provided `data` byte array contains\n * the provided `bytes` byte array at the specified `offset`.\n */\nexport function containsBytes(\n    data: ReadonlyUint8Array | Uint8Array,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset: number,\n): boolean {\n    const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);\n    if (slice.length !== bytes.length) return false;\n    return bytes.every((b, i) => b === slice[i]);\n}\n","import {\n    SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Defines an offset in bytes.\n */\nexport type Offset = number;\n\ntype BaseEncoder<TFrom> = {\n    /** Encode the provided value and return the encoded bytes directly. */\n    readonly encode: (value: TFrom) => ReadonlyUint8Array;\n    /**\n     * Writes the encoded value into the provided byte array at the given offset.\n     * Returns the offset of the next byte after the encoded value.\n     */\n    readonly write: (value: TFrom, bytes: Uint8Array, offset: Offset) => Offset;\n};\n\nexport type FixedSizeEncoder<TFrom, TSize extends number = number> = BaseEncoder<TFrom> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\nexport type VariableSizeEncoder<TFrom> = BaseEncoder<TFrom> & {\n    /** The total size of the encoded value in bytes. */\n    readonly getSizeFromValue: (value: TFrom) => number;\n    /** The maximum size an encoded value can be in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can encode a value to a `Uint8Array`.\n */\nexport type Encoder<TFrom> = FixedSizeEncoder<TFrom> | VariableSizeEncoder<TFrom>;\n\ntype BaseDecoder<TTo> = {\n    /** Decodes the provided byte array at the given offset (or zero) and returns the value directly. */\n    readonly decode: (bytes: ReadonlyUint8Array | Uint8Array, offset?: Offset) => TTo;\n    /**\n     * Reads the encoded value from the provided byte array at the given offset.\n     * Returns the decoded value and the offset of the next byte after the encoded value.\n     */\n    readonly read: (bytes: ReadonlyUint8Array | Uint8Array, offset: Offset) => [TTo, Offset];\n};\n\nexport type FixedSizeDecoder<TTo, TSize extends number = number> = BaseDecoder<TTo> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\nexport type VariableSizeDecoder<TTo> = BaseDecoder<TTo> & {\n    /** The maximum size an encoded value can be in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can decode a value from a `Uint8Array`.\n */\nexport type Decoder<TTo> = FixedSizeDecoder<TTo> | VariableSizeDecoder<TTo>;\n\nexport type FixedSizeCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number> = FixedSizeDecoder<\n    TTo,\n    TSize\n> &\n    FixedSizeEncoder<TFrom, TSize>;\n\nexport type VariableSizeCodec<TFrom, TTo extends TFrom = TFrom> = VariableSizeDecoder<TTo> & VariableSizeEncoder<TFrom>;\n\n/**\n * An object that can encode and decode a value to and from a `Uint8Array`.\n * It supports encoding looser types than it decodes for convenience.\n * For example, a `bigint` encoder will always decode to a `bigint`\n * but can be used to encode a `number`.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value. Defaults to `TFrom`.\n */\nexport type Codec<TFrom, TTo extends TFrom = TFrom> = FixedSizeCodec<TFrom, TTo> | VariableSizeCodec<TFrom, TTo>;\n\n/**\n * Get the encoded size of a given value in bytes.\n */\nexport function getEncodedSize<TFrom>(\n    value: TFrom,\n    encoder: { fixedSize: number } | { getSizeFromValue: (value: TFrom) => number },\n): number {\n    return 'fixedSize' in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\n\n/** Fills the missing `encode` function using the existing `write` function. */\nexport function createEncoder<TFrom, TSize extends number>(\n    encoder: Omit<FixedSizeEncoder<TFrom, TSize>, 'encode'>,\n): FixedSizeEncoder<TFrom, TSize>;\nexport function createEncoder<TFrom>(encoder: Omit<VariableSizeEncoder<TFrom>, 'encode'>): VariableSizeEncoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom> {\n    return Object.freeze({\n        ...encoder,\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, encoder));\n            encoder.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\n/** Fills the missing `decode` function using the existing `read` function. */\nexport function createDecoder<TTo, TSize extends number>(\n    decoder: Omit<FixedSizeDecoder<TTo, TSize>, 'decode'>,\n): FixedSizeDecoder<TTo, TSize>;\nexport function createDecoder<TTo>(decoder: Omit<VariableSizeDecoder<TTo>, 'decode'>): VariableSizeDecoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo> {\n    return Object.freeze({\n        ...decoder,\n        decode: (bytes, offset = 0) => decoder.read(bytes, offset)[0],\n    });\n}\n\n/** Fills the missing `encode` and `decode` function using the existing `write` and `read` functions. */\nexport function createCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number>(\n    codec: Omit<FixedSizeCodec<TFrom, TTo, TSize>, 'decode' | 'encode'>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec: Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo> {\n    return Object.freeze({\n        ...codec,\n        decode: (bytes, offset = 0) => codec.read(bytes, offset)[0],\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, codec));\n            codec.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\nexport function isFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function isFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): decoder is FixedSizeDecoder<TTo, TSize>;\nexport function isFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function isFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): codec is { fixedSize: TSize };\nexport function isFixedSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { fixedSize: number } {\n    return 'fixedSize' in codec && typeof codec.fixedSize === 'number';\n}\n\nexport function assertIsFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): asserts encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function assertIsFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): asserts decoder is FixedSizeDecoder<TTo, TSize>;\nexport function assertIsFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): asserts codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function assertIsFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): asserts codec is { fixedSize: TSize };\nexport function assertIsFixedSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { fixedSize: number } {\n    if (!isFixedSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n    }\n}\n\nexport function isVariableSize<TFrom>(encoder: Encoder<TFrom>): encoder is VariableSizeEncoder<TFrom>;\nexport function isVariableSize<TTo>(decoder: Decoder<TTo>): decoder is VariableSizeDecoder<TTo>;\nexport function isVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): codec is VariableSizeCodec<TFrom, TTo>;\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number };\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number } {\n    return !isFixedSize(codec);\n}\n\nexport function assertIsVariableSize<T>(encoder: Encoder<T>): asserts encoder is VariableSizeEncoder<T>;\nexport function assertIsVariableSize<T>(decoder: Decoder<T>): asserts decoder is VariableSizeDecoder<T>;\nexport function assertIsVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): asserts codec is VariableSizeCodec<TFrom, TTo>;\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number };\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number } {\n    if (!isVariableSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n    }\n}\n","import {\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH,\n    SolanaError,\n} from '@solana/errors';\n\nimport {\n    Codec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\n\n/**\n * Combines an encoder and a decoder into a codec.\n * The encoder and decoder must have the same fixed size, max size and description.\n * If a description is provided, it will override the encoder and decoder descriptions.\n */\nexport function combineCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n    decoder: FixedSizeDecoder<TTo, TSize>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: VariableSizeEncoder<TFrom>,\n    decoder: VariableSizeDecoder<TTo>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo> {\n    if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n    }\n\n    if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n            decoderFixedSize: decoder.fixedSize,\n            encoderFixedSize: encoder.fixedSize,\n        });\n    }\n\n    if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n            decoderMaxSize: decoder.maxSize,\n            encoderMaxSize: encoder.maxSize,\n        });\n    }\n\n    return {\n        ...decoder,\n        ...encoder,\n        decode: decoder.decode,\n        encode: encoder.encode,\n        read: decoder.read,\n        write: encoder.write,\n    };\n}\n","import {\n    SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL,\n    SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES,\n    SolanaError,\n} from '@solana/errors';\n\nimport { containsBytes } from './bytes';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Creates an encoder that writes a `Uint8Array` sentinel after the encoded value.\n * This is useful to delimit the encoded value when being read by a decoder.\n *\n * Note that, if the sentinel is found in the encoded value, an error is thrown.\n */\nexport function addEncoderSentinel<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeEncoder<TFrom>;\nexport function addEncoderSentinel<TFrom>(\n    encoder: Encoder<TFrom>,\n    sentinel: ReadonlyUint8Array,\n): VariableSizeEncoder<TFrom>;\nexport function addEncoderSentinel<TFrom>(encoder: Encoder<TFrom>, sentinel: ReadonlyUint8Array): Encoder<TFrom> {\n    const write = ((value, bytes, offset) => {\n        // Here we exceptionally use the `encode` function instead of the `write`\n        // function to contain the content of the encoder within its own bounds\n        // and to avoid writing the sentinel as part of the encoded value.\n        const encoderBytes = encoder.encode(value);\n        if (findSentinelIndex(encoderBytes, sentinel) >= 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {\n                encodedBytes: encoderBytes,\n                hexEncodedBytes: hexBytes(encoderBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel,\n            });\n        }\n        bytes.set(encoderBytes, offset);\n        offset += encoderBytes.length;\n        bytes.set(sentinel, offset);\n        offset += sentinel.length;\n        return offset;\n    }) as Encoder<TFrom>['write'];\n\n    if (isFixedSize(encoder)) {\n        return createEncoder({ ...encoder, fixedSize: encoder.fixedSize + sentinel.length, write });\n    }\n\n    return createEncoder({\n        ...encoder,\n        ...(encoder.maxSize != null ? { maxSize: encoder.maxSize + sentinel.length } : {}),\n        getSizeFromValue: value => encoder.getSizeFromValue(value) + sentinel.length,\n        write,\n    });\n}\n\n/**\n * Creates a decoder that continues reading until a `Uint8Array` sentinel is found.\n *\n * If the sentinel is not found in the byte array to decode, an error is thrown.\n */\nexport function addDecoderSentinel<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeDecoder<TTo>;\nexport function addDecoderSentinel<TTo>(decoder: Decoder<TTo>, sentinel: ReadonlyUint8Array): VariableSizeDecoder<TTo>;\nexport function addDecoderSentinel<TTo>(decoder: Decoder<TTo>, sentinel: ReadonlyUint8Array): Decoder<TTo> {\n    const read = ((bytes, offset) => {\n        const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);\n        const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);\n        if (sentinelIndex === -1) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {\n                decodedBytes: candidateBytes,\n                hexDecodedBytes: hexBytes(candidateBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel,\n            });\n        }\n        const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);\n        // Here we exceptionally use the `decode` function instead of the `read`\n        // function to contain the content of the decoder within its own bounds\n        // and ensure that the sentinel is not part of the decoded value.\n        return [decoder.decode(preSentinelBytes), offset + preSentinelBytes.length + sentinel.length];\n    }) as Decoder<TTo>['read'];\n\n    if (isFixedSize(decoder)) {\n        return createDecoder({ ...decoder, fixedSize: decoder.fixedSize + sentinel.length, read });\n    }\n\n    return createDecoder({\n        ...decoder,\n        ...(decoder.maxSize != null ? { maxSize: decoder.maxSize + sentinel.length } : {}),\n        read,\n    });\n}\n\n/**\n * Creates a Codec that writes a `Uint8Array` sentinel after the encoded\n * value and, when decoding, continues reading until the sentinel is found.\n *\n * Note that, if the sentinel is found in the encoded value\n * or not found in the byte array to decode, an error is thrown.\n */\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeCodec<TFrom, TTo>;\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): VariableSizeCodec<TFrom, TTo>;\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): Codec<TFrom, TTo> {\n    return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));\n}\n\nfunction findSentinelIndex(bytes: ReadonlyUint8Array, sentinel: ReadonlyUint8Array) {\n    return bytes.findIndex((byte, index, arr) => {\n        if (sentinel.length === 1) return byte === sentinel[0];\n        return containsBytes(arr, sentinel, index);\n    });\n}\n\nfunction hexBytes(bytes: ReadonlyUint8Array): string {\n    return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n","import {\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Asserts that a given byte array is not empty.\n */\nexport function assertByteArrayIsNotEmptyForCodec(\n    codecDescription: string,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset = 0,\n) {\n    if (bytes.length - offset <= 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n            codecDescription,\n        });\n    }\n}\n\n/**\n * Asserts that a given byte array has enough bytes to decode.\n */\nexport function assertByteArrayHasEnoughBytesForCodec(\n    codecDescription: string,\n    expected: number,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset = 0,\n) {\n    const bytesLength = bytes.length - offset;\n    if (bytesLength < expected) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n            bytesLength,\n            codecDescription,\n            expected,\n        });\n    }\n}\n\n/**\n * Asserts that a given offset is within the byte array bounds.\n * This range is between 0 and the byte array length and is inclusive.\n * An offset equals to the byte array length is considered a valid offset\n * as it allows the post-offset of codecs to signal the end of the byte array.\n */\nexport function assertByteArrayOffsetIsNotOutOfRange(codecDescription: string, offset: number, bytesLength: number) {\n    if (offset < 0 || offset > bytesLength) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n            bytesLength,\n            codecDescription,\n            offset,\n        });\n    }\n}\n","import { assertByteArrayHasEnoughBytesForCodec } from './assertions';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\ntype NumberEncoder = Encoder<bigint | number> | Encoder<number>;\ntype FixedSizeNumberEncoder<TSize extends number = number> =\n    | FixedSizeEncoder<bigint | number, TSize>\n    | FixedSizeEncoder<number, TSize>;\ntype NumberDecoder = Decoder<bigint> | Decoder<number>;\ntype FixedSizeNumberDecoder<TSize extends number = number> =\n    | FixedSizeDecoder<bigint, TSize>\n    | FixedSizeDecoder<number, TSize>;\ntype NumberCodec = Codec<bigint | number, bigint> | Codec<number>;\ntype FixedSizeNumberCodec<TSize extends number = number> =\n    | FixedSizeCodec<bigint | number, bigint, TSize>\n    | FixedSizeCodec<number, number, TSize>;\n\n/**\n * Stores the size of the `encoder` in bytes as a prefix using the `prefix` encoder.\n */\nexport function addEncoderSizePrefix<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    prefix: FixedSizeNumberEncoder,\n): FixedSizeEncoder<TFrom>;\nexport function addEncoderSizePrefix<TFrom>(encoder: Encoder<TFrom>, prefix: NumberEncoder): VariableSizeEncoder<TFrom>;\nexport function addEncoderSizePrefix<TFrom>(encoder: Encoder<TFrom>, prefix: NumberEncoder): Encoder<TFrom> {\n    const write = ((value, bytes, offset) => {\n        // Here we exceptionally use the `encode` function instead of the `write`\n        // function to contain the content of the encoder within its own bounds.\n        const encoderBytes = encoder.encode(value);\n        offset = prefix.write(encoderBytes.length, bytes, offset);\n        bytes.set(encoderBytes, offset);\n        return offset + encoderBytes.length;\n    }) as Encoder<TFrom>['write'];\n\n    if (isFixedSize(prefix) && isFixedSize(encoder)) {\n        return createEncoder({ ...encoder, fixedSize: prefix.fixedSize + encoder.fixedSize, write });\n    }\n\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : (prefix.maxSize ?? null);\n    const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : (encoder.maxSize ?? null);\n    const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;\n\n    return createEncoder({\n        ...encoder,\n        ...(maxSize !== null ? { maxSize } : {}),\n        getSizeFromValue: value => {\n            const encoderSize = getEncodedSize(value, encoder);\n            return getEncodedSize(encoderSize, prefix) + encoderSize;\n        },\n        write,\n    });\n}\n\n/**\n * Bounds the size of the `decoder` by reading the `prefix` encoder prefix.\n */\nexport function addDecoderSizePrefix<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    prefix: FixedSizeNumberDecoder,\n): FixedSizeDecoder<TTo>;\nexport function addDecoderSizePrefix<TTo>(decoder: Decoder<TTo>, prefix: NumberDecoder): VariableSizeDecoder<TTo>;\nexport function addDecoderSizePrefix<TTo>(decoder: Decoder<TTo>, prefix: NumberDecoder): Decoder<TTo> {\n    const read = ((bytes, offset) => {\n        const [bigintSize, decoderOffset] = prefix.read(bytes, offset);\n        const size = Number(bigintSize);\n        offset = decoderOffset;\n        // Slice the byte array to the contained size if necessary.\n        if (offset > 0 || bytes.length > size) {\n            bytes = bytes.slice(offset, offset + size);\n        }\n        assertByteArrayHasEnoughBytesForCodec('addDecoderSizePrefix', size, bytes);\n        // Here we exceptionally use the `decode` function instead of the `read`\n        // function to contain the content of the decoder within its own bounds.\n        return [decoder.decode(bytes), offset + size];\n    }) as Decoder<TTo>['read'];\n\n    if (isFixedSize(prefix) && isFixedSize(decoder)) {\n        return createDecoder({ ...decoder, fixedSize: prefix.fixedSize + decoder.fixedSize, read });\n    }\n\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : (prefix.maxSize ?? null);\n    const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : (decoder.maxSize ?? null);\n    const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;\n    return createDecoder({ ...decoder, ...(maxSize !== null ? { maxSize } : {}), read });\n}\n\n/**\n * Bounds the size of the `codec` using the provided `prefix` codec prefix.\n */\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    prefix: FixedSizeNumberCodec,\n): FixedSizeCodec<TFrom, TTo>;\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefix: NumberCodec,\n): VariableSizeCodec<TFrom, TTo>;\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefix: NumberCodec,\n): Codec<TFrom, TTo> {\n    return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));\n}\n","import { assertByteArrayHasEnoughBytesForCodec } from './assertions';\nimport { fixBytes } from './bytes';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    Offset,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n/**\n * Creates a fixed-size encoder from a given encoder.\n *\n * @param encoder - The encoder to wrap into a fixed-size encoder.\n * @param fixedBytes - The fixed number of bytes to write.\n */\nexport function fixEncoderSize<TFrom, TSize extends number>(\n    encoder: Encoder<TFrom>,\n    fixedBytes: TSize,\n): FixedSizeEncoder<TFrom, TSize> {\n    return createEncoder({\n        fixedSize: fixedBytes,\n        write: (value: TFrom, bytes: Uint8Array, offset: Offset) => {\n            // Here we exceptionally use the `encode` function instead of the `write`\n            // function as using the nested `write` function on a fixed-sized byte\n            // array may result in a out-of-bounds error on the nested encoder.\n            const variableByteArray = encoder.encode(value);\n            const fixedByteArray =\n                variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n            bytes.set(fixedByteArray, offset);\n            return offset + fixedBytes;\n        },\n    });\n}\n\n/**\n * Creates a fixed-size decoder from a given decoder.\n *\n * @param decoder - The decoder to wrap into a fixed-size decoder.\n * @param fixedBytes - The fixed number of bytes to read.\n */\nexport function fixDecoderSize<TTo, TSize extends number>(\n    decoder: Decoder<TTo>,\n    fixedBytes: TSize,\n): FixedSizeDecoder<TTo, TSize> {\n    return createDecoder({\n        fixedSize: fixedBytes,\n        read: (bytes, offset) => {\n            assertByteArrayHasEnoughBytesForCodec('fixCodecSize', fixedBytes, bytes, offset);\n            // Slice the byte array to the fixed size if necessary.\n            if (offset > 0 || bytes.length > fixedBytes) {\n                bytes = bytes.slice(offset, offset + fixedBytes);\n            }\n            // If the nested decoder is fixed-size, pad and truncate the byte array accordingly.\n            if (isFixedSize(decoder)) {\n                bytes = fixBytes(bytes, decoder.fixedSize);\n            }\n            // Decode the value using the nested decoder.\n            const [value] = decoder.read(bytes, 0);\n            return [value, offset + fixedBytes];\n        },\n    });\n}\n\n/**\n * Creates a fixed-size codec from a given codec.\n *\n * @param codec - The codec to wrap into a fixed-size codec.\n * @param fixedBytes - The fixed number of bytes to read/write.\n */\nexport function fixCodecSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: Codec<TFrom, TTo>,\n    fixedBytes: TSize,\n): FixedSizeCodec<TFrom, TTo, TSize> {\n    return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));\n}\n","import { assertByteArrayOffsetIsNotOutOfRange } from './assertions';\nimport { Codec, createDecoder, createEncoder, Decoder, Encoder, Offset } from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\ntype OffsetConfig = {\n    postOffset?: PostOffsetFunction;\n    preOffset?: PreOffsetFunction;\n};\n\ntype PreOffsetFunctionScope = {\n    /** The entire byte array. */\n    bytes: ReadonlyUint8Array | Uint8Array;\n    /** The original offset prior to encode or decode. */\n    preOffset: Offset;\n    /** Wraps the offset to the byte array length. */\n    wrapBytes: (offset: Offset) => Offset;\n};\n\ntype PreOffsetFunction = (scope: PreOffsetFunctionScope) => Offset;\ntype PostOffsetFunction = (\n    scope: PreOffsetFunctionScope & {\n        /** The modified offset used to encode or decode. */\n        newPreOffset: Offset;\n        /** The original offset returned by the encoder or decoder. */\n        postOffset: Offset;\n    },\n) => Offset;\n\n/**\n * Moves the offset of a given encoder.\n */\nexport function offsetEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, config: OffsetConfig): TEncoder {\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, preOffset) => {\n            const wrapBytes = (offset: Offset) => modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetEncoder', newPreOffset, bytes.length);\n            const postOffset = encoder.write(value, bytes, newPreOffset);\n            const newPostOffset = config.postOffset\n                ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes })\n                : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetEncoder', newPostOffset, bytes.length);\n            return newPostOffset;\n        },\n    }) as TEncoder;\n}\n\n/**\n * Moves the offset of a given decoder.\n */\nexport function offsetDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, config: OffsetConfig): TDecoder {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, preOffset) => {\n            const wrapBytes = (offset: Offset) => modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetDecoder', newPreOffset, bytes.length);\n            const [value, postOffset] = decoder.read(bytes, newPreOffset);\n            const newPostOffset = config.postOffset\n                ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes })\n                : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetDecoder', newPostOffset, bytes.length);\n            return [value, newPostOffset];\n        },\n    }) as TDecoder;\n}\n\n/**\n * Moves the offset of a given codec.\n */\nexport function offsetCodec<TCodec extends AnyCodec>(codec: TCodec, config: OffsetConfig): TCodec {\n    return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config)) as TCodec;\n}\n\n/** A modulo function that handles negative dividends and zero divisors. */\nfunction modulo(dividend: number, divisor: number) {\n    if (divisor === 0) return 0;\n    return ((dividend % divisor) + divisor) % divisor;\n}\n","import { SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, SolanaError } from '@solana/errors';\n\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Updates the size of a given encoder.\n */\nexport function resizeEncoder<TFrom, TSize extends number, TNewSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeEncoder<TFrom, TNewSize>;\nexport function resizeEncoder<TEncoder extends AnyEncoder>(\n    encoder: TEncoder,\n    resize: (size: number) => number,\n): TEncoder;\nexport function resizeEncoder<TEncoder extends AnyEncoder>(\n    encoder: TEncoder,\n    resize: (size: number) => number,\n): TEncoder {\n    if (isFixedSize(encoder)) {\n        const fixedSize = resize(encoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: 'resizeEncoder',\n            });\n        }\n        return createEncoder({ ...encoder, fixedSize }) as TEncoder;\n    }\n    return createEncoder({\n        ...encoder,\n        getSizeFromValue: value => {\n            const newSize = resize(encoder.getSizeFromValue(value));\n            if (newSize < 0) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                    bytesLength: newSize,\n                    codecDescription: 'resizeEncoder',\n                });\n            }\n            return newSize;\n        },\n    }) as TEncoder;\n}\n\n/**\n * Updates the size of a given decoder.\n */\n\nexport function resizeDecoder<TFrom, TSize extends number, TNewSize extends number>(\n    decoder: FixedSizeDecoder<TFrom, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeDecoder<TFrom, TNewSize>;\nexport function resizeDecoder<TDecoder extends AnyDecoder>(\n    decoder: TDecoder,\n    resize: (size: number) => number,\n): TDecoder;\nexport function resizeDecoder<TDecoder extends AnyDecoder>(\n    decoder: TDecoder,\n    resize: (size: number) => number,\n): TDecoder {\n    if (isFixedSize(decoder)) {\n        const fixedSize = resize(decoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: 'resizeDecoder',\n            });\n        }\n        return createDecoder({ ...decoder, fixedSize }) as TDecoder;\n    }\n    return decoder;\n}\n\n/**\n * Updates the size of a given codec.\n */\nexport function resizeCodec<TFrom, TTo extends TFrom, TSize extends number, TNewSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeCodec<TFrom, TTo, TNewSize>;\nexport function resizeCodec<TCodec extends AnyCodec>(codec: TCodec, resize: (size: number) => number): TCodec;\nexport function resizeCodec<TCodec extends AnyCodec>(codec: TCodec, resize: (size: number) => number): TCodec {\n    return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize)) as TCodec;\n}\n","import { Codec, Decoder, Encoder, Offset } from './codec';\nimport { combineCodec } from './combine-codec';\nimport { offsetDecoder, offsetEncoder } from './offset-codec';\nimport { resizeDecoder, resizeEncoder } from './resize-codec';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Adds left padding to the given encoder.\n */\nexport function padLeftEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, offset: Offset): TEncoder {\n    return offsetEncoder(\n        resizeEncoder(encoder, size => size + offset),\n        { preOffset: ({ preOffset }) => preOffset + offset },\n    );\n}\n\n/**\n * Adds right padding to the given encoder.\n */\nexport function padRightEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, offset: Offset): TEncoder {\n    return offsetEncoder(\n        resizeEncoder(encoder, size => size + offset),\n        { postOffset: ({ postOffset }) => postOffset + offset },\n    );\n}\n\n/**\n * Adds left padding to the given decoder.\n */\nexport function padLeftDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, offset: Offset): TDecoder {\n    return offsetDecoder(\n        resizeDecoder(decoder, size => size + offset),\n        { preOffset: ({ preOffset }) => preOffset + offset },\n    );\n}\n\n/**\n * Adds right padding to the given decoder.\n */\nexport function padRightDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, offset: Offset): TDecoder {\n    return offsetDecoder(\n        resizeDecoder(decoder, size => size + offset),\n        { postOffset: ({ postOffset }) => postOffset + offset },\n    );\n}\n\n/**\n * Adds left padding to the given codec.\n */\nexport function padLeftCodec<TCodec extends AnyCodec>(codec: TCodec, offset: Offset): TCodec {\n    return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset)) as TCodec;\n}\n\n/**\n * Adds right padding to the given codec.\n */\nexport function padRightCodec<TCodec extends AnyCodec>(codec: TCodec, offset: Offset): TCodec {\n    return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset)) as TCodec;\n}\n","import {\n    assertIsFixedSize,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\nfunction copySourceToTargetInReverse(\n    source: ReadonlyUint8Array,\n    target_WILL_MUTATE: Uint8Array,\n    sourceOffset: number,\n    sourceLength: number,\n    targetOffset: number = 0,\n) {\n    while (sourceOffset < --sourceLength) {\n        const leftValue = source[sourceOffset];\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];\n        target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;\n        sourceOffset++;\n    }\n    if (sourceOffset === sourceLength) {\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];\n    }\n}\n\n/**\n * Reverses the bytes of a fixed-size encoder.\n */\nexport function reverseEncoder<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n): FixedSizeEncoder<TFrom, TSize> {\n    assertIsFixedSize(encoder);\n    return createEncoder({\n        ...encoder,\n        write: (value: TFrom, bytes, offset) => {\n            const newOffset = encoder.write(value, bytes, offset);\n            copySourceToTargetInReverse(\n                bytes /* source */,\n                bytes /* target_WILL_MUTATE */,\n                offset /* sourceOffset */,\n                offset + encoder.fixedSize /* sourceLength */,\n            );\n            return newOffset;\n        },\n    });\n}\n\n/**\n * Reverses the bytes of a fixed-size decoder.\n */\nexport function reverseDecoder<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize>,\n): FixedSizeDecoder<TTo, TSize> {\n    assertIsFixedSize(decoder);\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset) => {\n            const reversedBytes = bytes.slice();\n            copySourceToTargetInReverse(\n                bytes /* source */,\n                reversedBytes /* target_WILL_MUTATE */,\n                offset /* sourceOffset */,\n                offset + decoder.fixedSize /* sourceLength */,\n            );\n            return decoder.read(reversedBytes, offset);\n        },\n    });\n}\n\n/**\n * Reverses the bytes of a fixed-size codec.\n */\nexport function reverseCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize>,\n): FixedSizeCodec<TFrom, TTo, TSize> {\n    return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\n","import {\n    Codec,\n    createCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isVariableSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Converts an encoder A to a encoder B by mapping their values.\n */\nexport function transformEncoder<TOldFrom, TNewFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TOldFrom, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): FixedSizeEncoder<TNewFrom, TSize>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: VariableSizeEncoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): VariableSizeEncoder<TNewFrom>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: Encoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Encoder<TNewFrom>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: Encoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Encoder<TNewFrom> {\n    return createEncoder({\n        ...(isVariableSize(encoder)\n            ? { ...encoder, getSizeFromValue: (value: TNewFrom) => encoder.getSizeFromValue(unmap(value)) }\n            : encoder),\n        write: (value: TNewFrom, bytes, offset) => encoder.write(unmap(value), bytes, offset),\n    });\n}\n\n/**\n * Converts an decoder A to a decoder B by mapping their values.\n */\nexport function transformDecoder<TOldTo, TNewTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TOldTo, TSize>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): FixedSizeDecoder<TNewTo, TSize>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: VariableSizeDecoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): VariableSizeDecoder<TNewTo>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: Decoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Decoder<TNewTo>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: Decoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Decoder<TNewTo> {\n    return createDecoder({\n        ...decoder,\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const [value, newOffset] = decoder.read(bytes, offset);\n            return [map(value, bytes, offset), newOffset];\n        },\n    });\n}\n\n/**\n * Converts a codec A to a codec B by mapping their values.\n */\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom, TSize extends number>(\n    codec: FixedSizeCodec<TOldFrom, TTo, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): FixedSizeCodec<TNewFrom, TTo, TSize>;\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom>(\n    codec: VariableSizeCodec<TOldFrom, TTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): VariableSizeCodec<TNewFrom, TTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom>(\n    codec: Codec<TOldFrom, TTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Codec<TNewFrom, TTo>;\nexport function transformCodec<\n    TOldFrom,\n    TNewFrom,\n    TOldTo extends TOldFrom,\n    TNewTo extends TNewFrom,\n    TSize extends number,\n>(\n    codec: FixedSizeCodec<TOldFrom, TOldTo, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): FixedSizeCodec<TNewFrom, TNewTo, TSize>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: VariableSizeCodec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): VariableSizeCodec<TNewFrom, TNewTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: Codec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Codec<TNewFrom, TNewTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: Codec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map?: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Codec<TNewFrom, TNewTo> {\n    return createCodec({\n        ...transformEncoder(codec, unmap),\n        read: map ? transformDecoder(codec, map).read : (codec.read as unknown as Decoder<TNewTo>['read']),\n    });\n}\n","import { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given string matches a given alphabet.\n */\nexport function assertValidBaseString(alphabet: string, testValue: string, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet}]*$`))) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet,\n            base: alphabet.length,\n            value: givenValue,\n        });\n    }\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Encodes a string using a custom alphabet by dividing\n * by the base and handling leading zeroes.\n * @see {@link getBaseXCodec} for a more detailed description.\n */\nexport const getBaseXEncoder = (alphabet: string): VariableSizeEncoder<string> => {\n    return createEncoder({\n        getSizeFromValue: (value: string): number => {\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) return value.length;\n\n            const base10Number = getBigIntFromBaseX(tailChars, alphabet);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write(value: string, bytes, offset) {\n            // Check if the value is valid.\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n\n            // Handle leading zeroes.\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n\n            // From baseX to base10.\n            let base10Number = getBigIntFromBaseX(tailChars, alphabet);\n\n            // From base10 to bytes.\n            const tailBytes: number[] = [];\n            while (base10Number > 0n) {\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n\n            const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Decodes a string using a custom alphabet by dividing\n * by the base and handling leading zeroes.\n * @see {@link getBaseXCodec} for a more detailed description.\n */\nexport const getBaseXDecoder = (alphabet: string): VariableSizeDecoder<string> => {\n    return createDecoder({\n        read(rawBytes, offset): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', 0];\n\n            // Handle leading zeroes.\n            let trailIndex = bytes.findIndex(n => n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n\n            // From bytes to base10.\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n\n            // From base10 to baseX.\n            const tailChars = getBaseXFromBigInt(base10Number, alphabet);\n\n            return [leadingZeroes + tailChars, rawBytes.length];\n        },\n    });\n};\n\n/**\n * A string codec that requires a custom alphabet and uses\n * the length of that alphabet as the base. It then divides\n * the input by the base as many times as necessary to get\n * the output. It also supports leading zeroes by using the\n * first character of the alphabet as the zero character.\n *\n * This can be used to create codecs such as base10 or base58.\n */\nexport const getBaseXCodec = (alphabet: string): VariableSizeCodec<string> =>\n    combineCodec(getBaseXEncoder(alphabet), getBaseXDecoder(alphabet));\n\nfunction partitionLeadingZeroes(\n    value: string,\n    zeroCharacter: string,\n): [leadingZeros: string, tailChars: string | undefined] {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [leadingZeros, tailChars];\n}\n\nfunction getBigIntFromBaseX(value: string, alphabet: string): bigint {\n    const base = BigInt(alphabet.length);\n    let sum = 0n;\n    for (const char of value) {\n        sum *= base;\n        sum += BigInt(alphabet.indexOf(char));\n    }\n    return sum;\n}\n\nfunction getBaseXFromBigInt(value: bigint, alphabet: string): string {\n    const base = BigInt(alphabet.length);\n    const tailChars = [];\n    while (value > 0n) {\n        tailChars.unshift(alphabet[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join('');\n}\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '0123456789';\n\n/** Encodes strings in base10. */\nexport const getBase10Encoder = () => getBaseXEncoder(alphabet);\n\n/** Decodes strings in base10. */\nexport const getBase10Decoder = () => getBaseXDecoder(alphabet);\n\n/** Encodes and decodes strings in base10. */\nexport const getBase10Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nconst enum HexC {\n    ZERO = 48, // 0\n    NINE = 57, // 9\n    A_UP = 65, // A\n    F_UP = 70, // F\n    A_LO = 97, // a\n    F_LO = 102, // f\n}\n\nconst INVALID_STRING_ERROR_BASE_CONFIG = {\n    alphabet: '0123456789abcdef',\n    base: 16,\n} as const;\n\nfunction charCodeToBase16(char: number) {\n    if (char >= HexC.ZERO && char <= HexC.NINE) return char - HexC.ZERO;\n    if (char >= HexC.A_UP && char <= HexC.F_UP) return char - (HexC.A_UP - 10);\n    if (char >= HexC.A_LO && char <= HexC.F_LO) return char - (HexC.A_LO - 10);\n}\n\n/** Encodes strings in base16. */\nexport const getBase16Encoder = (): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.ceil(value.length / 2),\n        write(value: string, bytes, offset) {\n            const len = value.length;\n            const al = len / 2;\n            if (len === 1) {\n                const c = value.charCodeAt(0);\n                const n = charCodeToBase16(c);\n                if (n === undefined) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                bytes.set([n], offset);\n                return 1 + offset;\n            }\n            const hexBytes = new Uint8Array(al);\n            for (let i = 0, j = 0; i < al; i++) {\n                const c1 = value.charCodeAt(j++);\n                const c2 = value.charCodeAt(j++);\n\n                const n1 = charCodeToBase16(c1);\n                const n2 = charCodeToBase16(c2);\n                if (n1 === undefined || (n2 === undefined && !Number.isNaN(c2))) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                hexBytes[i] = !Number.isNaN(c2) ? (n1 << 4) | (n2 ?? 0) : n1;\n            }\n\n            bytes.set(hexBytes, offset);\n            return hexBytes.length + offset;\n        },\n    });\n\n/** Decodes strings in base16. */\nexport const getBase16Decoder = (): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n            return [value, bytes.length];\n        },\n    });\n\n/** Encodes and decodes strings in base16. */\nexport const getBase16Codec = (): VariableSizeCodec<string> => combineCodec(getBase16Encoder(), getBase16Decoder());\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/** Encodes strings in base58. */\nexport const getBase58Encoder = () => getBaseXEncoder(alphabet);\n\n/** Decodes strings in base58. */\nexport const getBase58Decoder = () => getBaseXDecoder(alphabet);\n\n/** Encodes and decodes strings in base58. */\nexport const getBase58Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Encodes a string using a custom alphabet by reslicing the bits of the byte array.\n * @see {@link getBaseXResliceCodec} for a more detailed description.\n */\nexport const getBaseXResliceEncoder = (alphabet: string, bits: number): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.floor((value.length * bits) / 8),\n        write(value: string, bytes, offset) {\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n            const charIndices = [...value].map(c => alphabet.indexOf(c));\n            const reslicedBytes = reslice(charIndices, bits, 8, false);\n            bytes.set(reslicedBytes, offset);\n            return reslicedBytes.length + offset;\n        },\n    });\n\n/**\n * Decodes a string using a custom alphabet by reslicing the bits of the byte array.\n * @see {@link getBaseXResliceCodec} for a more detailed description.\n */\nexport const getBaseXResliceDecoder = (alphabet: string, bits: number): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(rawBytes, offset = 0): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', rawBytes.length];\n            const charIndices = reslice([...bytes], 8, bits, true);\n            return [charIndices.map(i => alphabet[i]).join(''), rawBytes.length];\n        },\n    });\n\n/**\n * A string serializer that reslices bytes into custom chunks\n * of bits that are then mapped to a custom alphabet.\n *\n * This can be used to create serializers whose alphabet\n * is a power of 2 such as base16 or base64.\n */\nexport const getBaseXResliceCodec = (alphabet: string, bits: number): VariableSizeCodec<string> =>\n    combineCodec(getBaseXResliceEncoder(alphabet, bits), getBaseXResliceDecoder(alphabet, bits));\n\n/** Helper function to reslice the bits inside bytes. */\nfunction reslice(input: number[], inputBits: number, outputBits: number, useRemainder: boolean): number[] {\n    const output = [];\n    let accumulator = 0;\n    let bitsInAccumulator = 0;\n    const mask = (1 << outputBits) - 1;\n    for (const value of input) {\n        accumulator = (accumulator << inputBits) | value;\n        bitsInAccumulator += inputBits;\n        while (bitsInAccumulator >= outputBits) {\n            bitsInAccumulator -= outputBits;\n            output.push((accumulator >> bitsInAccumulator) & mask);\n        }\n    }\n    if (useRemainder && bitsInAccumulator > 0) {\n        output.push((accumulator << (outputBits - bitsInAccumulator)) & mask);\n    }\n    return output;\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nimport { assertValidBaseString } from './assertions';\nimport { getBaseXResliceDecoder, getBaseXResliceEncoder } from './baseX-reslice';\n\nconst alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n/** Encodes strings in base64. */\nexport const getBase64Encoder = (): VariableSizeEncoder<string> => {\n    if (__BROWSER__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => {\n                try {\n                    return (atob as Window['atob'])(value).length;\n                } catch {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n            write(value: string, bytes, offset) {\n                try {\n                    const bytesToAdd = (atob as Window['atob'])(value)\n                        .split('')\n                        .map(c => c.charCodeAt(0));\n                    bytes.set(bytesToAdd, offset);\n                    return bytesToAdd.length + offset;\n                } catch {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => Buffer.from(value, 'base64').length,\n            write(value: string, bytes, offset) {\n                assertValidBaseString(alphabet, value.replace(/=/g, ''));\n                const buffer = Buffer.from(value, 'base64');\n                bytes.set(buffer, offset);\n                return buffer.length + offset;\n            },\n        });\n    }\n\n    return transformEncoder(getBaseXResliceEncoder(alphabet, 6), (value: string): string => value.replace(/=/g, ''));\n};\n\n/** Decodes strings in base64. */\nexport const getBase64Decoder = (): VariableSizeDecoder<string> => {\n    if (__BROWSER__) {\n        return createDecoder({\n            read(bytes, offset = 0) {\n                const slice = bytes.slice(offset);\n                const value = (btoa as Window['btoa'])(String.fromCharCode(...slice));\n                return [value, bytes.length];\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createDecoder({\n            read: (bytes, offset = 0) => [Buffer.from(bytes, offset).toString('base64'), bytes.length],\n        });\n    }\n\n    return transformDecoder(getBaseXResliceDecoder(alphabet, 6), (value: string): string =>\n        value.padEnd(Math.ceil(value.length / 4) * 4, '='),\n    );\n};\n\n/** Encodes and decodes strings in base64. */\nexport const getBase64Codec = (): VariableSizeCodec<string> => combineCodec(getBase64Encoder(), getBase64Decoder());\n","/**Removes null characters from a string. */\nexport const removeNullCharacters = (value: string) =>\n    // eslint-disable-next-line no-control-regex\n    value.replace(/\\u0000/g, '');\n\n/** Pads a string with null characters at the end. */\nexport const padNullCharacters = (value: string, chars: number) => value.padEnd(chars, '\\u0000');\n","export const TextDecoder = globalThis.TextDecoder;\nexport const TextEncoder = globalThis.TextEncoder;\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { TextDecoder, TextEncoder } from '@solana/text-encoding-impl';\n\nimport { removeNullCharacters } from './null-characters';\n\n/** Encodes UTF-8 strings using the native `TextEncoder` API. */\nexport const getUtf8Encoder = (): VariableSizeEncoder<string> => {\n    let textEncoder: TextEncoder;\n    return createEncoder({\n        getSizeFromValue: value => (textEncoder ||= new TextEncoder()).encode(value).length,\n        write: (value: string, bytes, offset) => {\n            const bytesToAdd = (textEncoder ||= new TextEncoder()).encode(value);\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/** Decodes UTF-8 strings using the native `TextDecoder` API. */\nexport const getUtf8Decoder = (): VariableSizeDecoder<string> => {\n    let textDecoder: TextDecoder;\n    return createDecoder({\n        read(bytes, offset) {\n            const value = (textDecoder ||= new TextDecoder()).decode(bytes.slice(offset));\n            return [removeNullCharacters(value), bytes.length];\n        },\n    });\n};\n\n/** Encodes and decodes UTF-8 strings using the native `TextEncoder` and `TextDecoder` API. */\nexport const getUtf8Codec = (): VariableSizeCodec<string> => combineCodec(getUtf8Encoder(), getUtf8Decoder());\n","import type { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport type { Lamports } from '@solana/rpc-types';\n\n/** The amount of bytes required to store the base account information without its data. */\nexport const BASE_ACCOUNT_SIZE = 128;\n\n/** Describe the generic account details applicable to every account. */\nexport type BaseAccount = {\n    readonly executable: boolean;\n    readonly lamports: Lamports;\n    readonly programAddress: Address;\n};\n\n/** Defines a Solana account with its generic details and parsed or encoded data. */\nexport type Account<TData extends Uint8Array | object, TAddress extends string = string> = BaseAccount & {\n    readonly address: Address<TAddress>;\n    readonly data: TData;\n};\n\n/** Defines a Solana account with its generic details and encoded data. */\nexport type EncodedAccount<TAddress extends string = string> = Account<ReadonlyUint8Array, TAddress>;\n","import type { Decoder, ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT,\n    SolanaError,\n} from '@solana/errors';\n\nimport type { Account, EncodedAccount } from './account';\nimport type { MaybeAccount, MaybeEncodedAccount } from './maybe-account';\n\n/** Decodes the data of a given account using the provided decoder. */\nexport function decodeAccount<TData extends object, TAddress extends string = string>(\n    encodedAccount: EncodedAccount<TAddress>,\n    decoder: Decoder<TData>,\n): Account<TData, TAddress>;\nexport function decodeAccount<TData extends object, TAddress extends string = string>(\n    encodedAccount: MaybeEncodedAccount<TAddress>,\n    decoder: Decoder<TData>,\n): MaybeAccount<TData, TAddress>;\nexport function decodeAccount<TData extends object, TAddress extends string = string>(\n    encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>,\n    decoder: Decoder<TData>,\n): Account<TData, TAddress> | MaybeAccount<TData, TAddress> {\n    try {\n        if ('exists' in encodedAccount && !encodedAccount.exists) {\n            return encodedAccount;\n        }\n        return Object.freeze({ ...encodedAccount, data: decoder.decode(encodedAccount.data) });\n    } catch {\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT, {\n            address: encodedAccount.address,\n        });\n    }\n}\n\nfunction accountExists<TData extends object>(account: Account<TData> | MaybeAccount<TData>): account is Account<TData> {\n    return !('exists' in account) || ('exists' in account && account.exists);\n}\n\n/** Asserts that an account has been decoded. */\nexport function assertAccountDecoded<TData extends object, TAddress extends string = string>(\n    account: Account<TData | Uint8Array, TAddress>,\n): asserts account is Account<TData, TAddress>;\nexport function assertAccountDecoded<TData extends object, TAddress extends string = string>(\n    account: MaybeAccount<TData | Uint8Array, TAddress>,\n): asserts account is MaybeAccount<TData, TAddress>;\nexport function assertAccountDecoded<TData extends object, TAddress extends string = string>(\n    account: Account<TData | Uint8Array, TAddress> | MaybeAccount<TData | Uint8Array, TAddress>,\n): asserts account is Account<TData, TAddress> | MaybeAccount<TData, TAddress> {\n    if (accountExists(account) && account.data instanceof Uint8Array) {\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT, {\n            address: account.address,\n        });\n    }\n}\n\n/** Asserts that all accounts have been decoded. */\nexport function assertAccountsDecoded<TData extends object, TAddress extends string = string>(\n    accounts: Account<ReadonlyUint8Array | TData, TAddress>[],\n): asserts accounts is Account<TData, TAddress>[];\nexport function assertAccountsDecoded<TData extends object, TAddress extends string = string>(\n    accounts: MaybeAccount<ReadonlyUint8Array | TData, TAddress>[],\n): asserts accounts is MaybeAccount<TData, TAddress>[];\nexport function assertAccountsDecoded<TData extends object, TAddress extends string = string>(\n    accounts: (Account<ReadonlyUint8Array | TData, TAddress> | MaybeAccount<ReadonlyUint8Array | TData, TAddress>)[],\n): asserts accounts is (Account<TData, TAddress> | MaybeAccount<TData, TAddress>)[] {\n    const encoded = accounts.filter(a => accountExists(a) && a.data instanceof Uint8Array);\n    if (encoded.length > 0) {\n        const encodedAddresses = encoded.map(a => a.address);\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED, {\n            addresses: encodedAddresses,\n        });\n    }\n}\n","import type { Address } from '@solana/addresses';\nimport { getBase58Encoder, getBase64Encoder } from '@solana/codecs-strings';\nimport type {\n    AccountInfoBase,\n    AccountInfoWithBase58Bytes,\n    AccountInfoWithBase58EncodedData,\n    AccountInfoWithBase64EncodedData,\n} from '@solana/rpc-types';\n\nimport type { Account, BaseAccount, EncodedAccount } from './account';\nimport type { MaybeAccount, MaybeEncodedAccount } from './maybe-account';\nimport type { JsonParsedDataResponse } from './rpc-api';\n\ntype Base64EncodedRpcAccount = AccountInfoBase & AccountInfoWithBase64EncodedData;\n\n/** Parse an account object received from a base64-encoded RPC call into an EncodedAccount or MaybeEncodedAccount type. */\nexport function parseBase64RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base64EncodedRpcAccount,\n): EncodedAccount<TAddress>;\nexport function parseBase64RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base64EncodedRpcAccount | null,\n): MaybeEncodedAccount<TAddress>;\nexport function parseBase64RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base64EncodedRpcAccount | null,\n): EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress> {\n    if (!rpcAccount) return Object.freeze({ address, exists: false });\n    const data = getBase64Encoder().encode(rpcAccount.data[0]);\n    return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\n\ntype Base58EncodedRpcAccount = AccountInfoBase & (AccountInfoWithBase58Bytes | AccountInfoWithBase58EncodedData);\n\n/** Parse an account object received from a base58-encoded RPC call into an EncodedAccount or MaybeEncodedAccount type. */\nexport function parseBase58RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base58EncodedRpcAccount,\n): EncodedAccount<TAddress>;\nexport function parseBase58RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base58EncodedRpcAccount | null,\n): MaybeEncodedAccount<TAddress>;\nexport function parseBase58RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base58EncodedRpcAccount | null,\n): EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress> {\n    if (!rpcAccount) return Object.freeze({ address, exists: false });\n    const data = getBase58Encoder().encode(typeof rpcAccount.data === 'string' ? rpcAccount.data : rpcAccount.data[0]);\n    return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\n\ntype JsonParsedRpcAccount = AccountInfoBase & { readonly data: JsonParsedDataResponse<unknown> };\n\n/** Parse an account object received from a json-parsed RPC call into an Account or MaybeAccount type. */\nexport function parseJsonRpcAccount<TData extends object, TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: JsonParsedRpcAccount,\n): Account<TData, TAddress>;\nexport function parseJsonRpcAccount<TData extends object, TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: JsonParsedRpcAccount | null,\n): MaybeAccount<TData, TAddress>;\nexport function parseJsonRpcAccount<TData extends object, TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: JsonParsedRpcAccount | null,\n): Account<TData, TAddress> | MaybeAccount<TData, TAddress> {\n    if (!rpcAccount) return Object.freeze({ address, exists: false });\n    const data = rpcAccount.data.parsed.info as TData;\n    return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\n\nfunction parseBaseAccount(rpcAccount: AccountInfoBase): BaseAccount {\n    return Object.freeze({\n        executable: rpcAccount.executable,\n        lamports: rpcAccount.lamports,\n        programAddress: rpcAccount.owner,\n    });\n}\n","import type { Address } from '@solana/addresses';\nimport type { Rpc } from '@solana/rpc-spec';\nimport type { Commitment, Slot } from '@solana/rpc-types';\n\nimport type { MaybeAccount, MaybeEncodedAccount } from './maybe-account';\nimport { parseBase64RpcAccount, parseJsonRpcAccount } from './parse-account';\nimport type { GetAccountInfoApi, GetMultipleAccountsApi } from './rpc-api';\n\n/** Optional configuration for fetching a singular account. */\nexport type FetchAccountConfig = {\n    abortSignal?: AbortSignal;\n    commitment?: Commitment;\n    minContextSlot?: Slot;\n};\n\n/** Fetch a base64-encoded account that may or may not exist using an RPC client. */\nexport async function fetchEncodedAccount<TAddress extends string = string>(\n    rpc: Rpc<GetAccountInfoApi>,\n    address: Address<TAddress>,\n    config: FetchAccountConfig = {},\n): Promise<MaybeEncodedAccount<TAddress>> {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc.getAccountInfo(address, { ...rpcConfig, encoding: 'base64' }).send({ abortSignal });\n    return parseBase64RpcAccount(address, response.value);\n}\n\n/** Fetch a json-parsed account that may or may not exist using an RPC client. */\nexport async function fetchJsonParsedAccount<TData extends object, TAddress extends string = string>(\n    rpc: Rpc<GetAccountInfoApi>,\n    address: Address<TAddress>,\n    config: FetchAccountConfig = {},\n): Promise<MaybeAccount<TData, TAddress> | MaybeEncodedAccount<TAddress>> {\n    const { abortSignal, ...rpcConfig } = config;\n    const { value: account } = await rpc\n        .getAccountInfo(address, { ...rpcConfig, encoding: 'jsonParsed' })\n        .send({ abortSignal });\n    return !!account && typeof account === 'object' && 'parsed' in account.data\n        ? parseJsonRpcAccount<TData, TAddress>(address, account as Parameters<typeof parseJsonRpcAccount>[1])\n        : parseBase64RpcAccount<TAddress>(address, account as Parameters<typeof parseBase64RpcAccount>[1]);\n}\n\n/** Optional configuration for fetching multiple accounts. */\nexport type FetchAccountsConfig = {\n    abortSignal?: AbortSignal;\n    commitment?: Commitment;\n    minContextSlot?: Slot;\n};\n\n/** Fetch multiple base64-encoded accounts that may or may not exist using an RPC client. */\nexport async function fetchEncodedAccounts<\n    TAddresses extends string[] = string[],\n    TWrappedAddresses extends { [P in keyof TAddresses]: Address<TAddresses[P]> } = {\n        [P in keyof TAddresses]: Address<TAddresses[P]>;\n    },\n>(rpc: Rpc<GetMultipleAccountsApi>, addresses: TWrappedAddresses, config: FetchAccountsConfig = {}) {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc\n        .getMultipleAccounts(addresses, { ...rpcConfig, encoding: 'base64' })\n        .send({ abortSignal });\n    return response.value.map((account, index) => parseBase64RpcAccount(addresses[index], account)) as {\n        [P in keyof TAddresses]: MaybeEncodedAccount<TAddresses[P]>;\n    };\n}\n\n/** Fetch multiple json-parsed accounts that may or may not exist using an RPC client. */\nexport async function fetchJsonParsedAccounts<\n    TData extends object[],\n    TAddresses extends string[] = string[],\n    TWrappedAddresses extends { [P in keyof TAddresses]: Address<TAddresses[P]> } = {\n        [P in keyof TAddresses]: Address<TAddresses[P]>;\n    },\n>(rpc: Rpc<GetMultipleAccountsApi>, addresses: TWrappedAddresses, config: FetchAccountsConfig = {}) {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc\n        .getMultipleAccounts(addresses, { ...rpcConfig, encoding: 'jsonParsed' })\n        .send({ abortSignal });\n    return response.value.map((account, index) => {\n        return !!account && typeof account === 'object' && 'parsed' in account.data\n            ? parseJsonRpcAccount(addresses[index], account as Parameters<typeof parseJsonRpcAccount>[1])\n            : parseBase64RpcAccount(addresses[index], account as Parameters<typeof parseBase64RpcAccount>[1]);\n    }) as {\n        [P in keyof TAddresses]:\n            | MaybeAccount<TData[P & keyof TData], TAddresses[P]>\n            | MaybeEncodedAccount<TAddresses[P]>;\n    } & {\n        [P in keyof TData]:\n            | MaybeAccount<TData[P], TAddresses[P & keyof TAddresses]>\n            | MaybeEncodedAccount<TAddresses[P & keyof TAddresses]>;\n    };\n}\n","import { Address } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND,\n    SolanaError,\n} from '@solana/errors';\n\nimport { Account } from './account';\n\n/** Defines a Solana account that may or may not exist after having tried to fetch it. */\nexport type MaybeAccount<TData extends Uint8Array | object, TAddress extends string = string> =\n    | { readonly address: Address<TAddress>; readonly exists: false }\n    | (Account<TData, TAddress> & { readonly exists: true });\n\n/** Defines a Solana account with encoded data that may or may not exist after having tried to fetch it. */\nexport type MaybeEncodedAccount<TAddress extends string = string> = MaybeAccount<Uint8Array, TAddress>;\n\n/** Asserts that an account that may or may not exists, actually exists. */\nexport function assertAccountExists<TData extends Uint8Array | object, TAddress extends string = string>(\n    account: MaybeAccount<TData, TAddress>,\n): asserts account is Account<TData, TAddress> & { exists: true } {\n    if (!account.exists) {\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND, { address: account.address });\n    }\n}\n\n/** Asserts that all accounts that may or may not exist, actually all exist. */\nexport function assertAccountsExist<TData extends Uint8Array | object, TAddress extends string = string>(\n    accounts: MaybeAccount<TData, TAddress>[],\n): asserts accounts is (Account<TData, TAddress> & { exists: true })[] {\n    const missingAccounts = accounts.filter(a => !a.exists);\n    if (missingAccounts.length > 0) {\n        const missingAddresses = missingAccounts.map(a => a.address);\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND, { addresses: missingAddresses });\n    }\n}\n","import { SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given number is between a given range.\n */\nexport function assertNumberIsBetweenForCodec(\n    codecDescription: string,\n    min: bigint | number,\n    max: bigint | number,\n    value: bigint | number,\n) {\n    if (value < min || value > max) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {\n            codecDescription,\n            max,\n            min,\n            value,\n        });\n    }\n}\n","import { Codec, Decoder, Encoder, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\n/** Defines a encoder for numbers and bigints. */\nexport type NumberEncoder = Encoder<bigint | number>;\n\n/** Defines a fixed-size encoder for numbers and bigints. */\nexport type FixedSizeNumberEncoder<TSize extends number = number> = FixedSizeEncoder<bigint | number, TSize>;\n\n/** Defines a decoder for numbers and bigints. */\nexport type NumberDecoder = Decoder<bigint> | Decoder<number>;\n\n/** Defines a fixed-size decoder for numbers and bigints. */\nexport type FixedSizeNumberDecoder<TSize extends number = number> =\n    | FixedSizeDecoder<bigint, TSize>\n    | FixedSizeDecoder<number, TSize>;\n\n/** Defines a codec for numbers and bigints. */\nexport type NumberCodec = Codec<bigint | number, bigint> | Codec<bigint | number, number>;\n\n/** Defines a fixed-size codec for numbers and bigints. */\nexport type FixedSizeNumberCodec<TSize extends number = number> =\n    | FixedSizeCodec<bigint | number, bigint, TSize>\n    | FixedSizeCodec<bigint | number, number, TSize>;\n\n/** Defines the config for number codecs that use more than one byte. */\nexport type NumberCodecConfig = {\n    /**\n     * Whether the serializer should use little-endian or big-endian encoding.\n     * @defaultValue `Endian.Little`\n     */\n    endian?: Endian;\n};\n\n/** Defines the endianness of a number serializer. */\nexport enum Endian {\n    Little,\n    Big,\n}\n","import {\n    assertByteArrayHasEnoughBytesForCodec,\n    assertByteArrayIsNotEmptyForCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    Offset,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\n\nimport { assertNumberIsBetweenForCodec } from './assertions';\nimport { Endian, NumberCodecConfig } from './common';\n\ntype NumberFactorySharedInput<TSize extends number> = {\n    config?: NumberCodecConfig;\n    name: string;\n    size: TSize;\n};\n\ntype NumberFactoryEncoderInput<TFrom, TSize extends number> = NumberFactorySharedInput<TSize> & {\n    range?: [bigint | number, bigint | number];\n    set: (view: DataView, value: TFrom, littleEndian?: boolean) => void;\n};\n\ntype NumberFactoryDecoderInput<TTo, TSize extends number> = NumberFactorySharedInput<TSize> & {\n    get: (view: DataView, littleEndian?: boolean) => TTo;\n};\n\nfunction isLittleEndian(config?: NumberCodecConfig): boolean {\n    return config?.endian === Endian.Big ? false : true;\n}\n\nexport function numberEncoderFactory<TFrom extends bigint | number, TSize extends number>(\n    input: NumberFactoryEncoderInput<TFrom, TSize>,\n): FixedSizeEncoder<TFrom, TSize> {\n    return createEncoder({\n        fixedSize: input.size,\n        write(value: TFrom, bytes: Uint8Array, offset: Offset): Offset {\n            if (input.range) {\n                assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);\n            }\n            const arrayBuffer = new ArrayBuffer(input.size);\n            input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));\n            bytes.set(new Uint8Array(arrayBuffer), offset);\n            return offset + input.size;\n        },\n    });\n}\n\nexport function numberDecoderFactory<TTo extends bigint | number, TSize extends number>(\n    input: NumberFactoryDecoderInput<TTo, TSize>,\n): FixedSizeDecoder<TTo, TSize> {\n    return createDecoder({\n        fixedSize: input.size,\n        read(bytes, offset = 0): [TTo, number] {\n            assertByteArrayIsNotEmptyForCodec(input.name, bytes, offset);\n            assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes, offset);\n            const view = new DataView(toArrayBuffer(bytes, offset, input.size));\n            return [input.get(view, isLittleEndian(input.config)), offset + input.size];\n        },\n    });\n}\n\n/**\n * Helper function to ensure that the ArrayBuffer is converted properly from a Uint8Array\n * Source: https://stackoverflow.com/questions/37228285/uint8array-to-arraybuffer\n */\nfunction toArrayBuffer(bytes: ReadonlyUint8Array | Uint8Array, offset?: number, length?: number): ArrayBuffer {\n    const bytesOffset = bytes.byteOffset + (offset ?? 0);\n    const bytesLength = length ?? bytes.byteLength;\n    return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getF32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'f32',\n        set: (view, value, le) => view.setFloat32(0, Number(value), le),\n        size: 4,\n    });\n\nexport const getF32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getFloat32(0, le),\n        name: 'f32',\n        size: 4,\n    });\n\nexport const getF32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getF32Encoder(config), getF32Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getF64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'f64',\n        set: (view, value, le) => view.setFloat64(0, Number(value), le),\n        size: 8,\n    });\n\nexport const getF64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getFloat64(0, le),\n        name: 'f64',\n        size: 8,\n    });\n\nexport const getF64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 8> =>\n    combineCodec(getF64Encoder(config), getF64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI128Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 16> =>\n    numberEncoderFactory({\n        config,\n        name: 'i128',\n        range: [-BigInt('0x7fffffffffffffffffffffffffffffff') - 1n, BigInt('0x7fffffffffffffffffffffffffffffff')],\n        set: (view, value, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigInt64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16,\n    });\n\nexport const getI128Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 16> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigInt64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: 'i128',\n        size: 16,\n    });\n\nexport const getI128Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 16> =>\n    combineCodec(getI128Encoder(config), getI128Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI16Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 2> =>\n    numberEncoderFactory({\n        config,\n        name: 'i16',\n        range: [-Number('0x7fff') - 1, Number('0x7fff')],\n        set: (view, value, le) => view.setInt16(0, Number(value), le),\n        size: 2,\n    });\n\nexport const getI16Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 2> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getInt16(0, le),\n        name: 'i16',\n        size: 2,\n    });\n\nexport const getI16Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 2> =>\n    combineCodec(getI16Encoder(config), getI16Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'i32',\n        range: [-Number('0x7fffffff') - 1, Number('0x7fffffff')],\n        set: (view, value, le) => view.setInt32(0, Number(value), le),\n        size: 4,\n    });\n\nexport const getI32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getInt32(0, le),\n        name: 'i32',\n        size: 4,\n    });\n\nexport const getI32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getI32Encoder(config), getI32Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'i64',\n        range: [-BigInt('0x7fffffffffffffff') - 1n, BigInt('0x7fffffffffffffff')],\n        set: (view, value, le) => view.setBigInt64(0, BigInt(value), le),\n        size: 8,\n    });\n\nexport const getI64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getBigInt64(0, le),\n        name: 'i64',\n        size: 8,\n    });\n\nexport const getI64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 8> =>\n    combineCodec(getI64Encoder(config), getI64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getI8Encoder = (): FixedSizeEncoder<bigint | number, 1> =>\n    numberEncoderFactory({\n        name: 'i8',\n        range: [-Number('0x7f') - 1, Number('0x7f')],\n        set: (view, value) => view.setInt8(0, Number(value)),\n        size: 1,\n    });\n\nexport const getI8Decoder = (): FixedSizeDecoder<number, 1> =>\n    numberDecoderFactory({\n        get: view => view.getInt8(0),\n        name: 'i8',\n        size: 1,\n    });\n\nexport const getI8Codec = (): FixedSizeCodec<bigint | number, number, 1> =>\n    combineCodec(getI8Encoder(), getI8Decoder());\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Offset,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertNumberIsBetweenForCodec } from './assertions';\n\n/**\n * Encodes short u16 numbers.\n * @see {@link getShortU16Codec} for a more detailed description.\n */\nexport const getShortU16Encoder = (): VariableSizeEncoder<bigint | number> =>\n    createEncoder({\n        getSizeFromValue: (value: bigint | number): number => {\n            if (value <= 0b01111111) return 1;\n            if (value <= 0b0011111111111111) return 2;\n            return 3;\n        },\n        maxSize: 3,\n        write: (value: bigint | number, bytes: Uint8Array, offset: Offset): Offset => {\n            assertNumberIsBetweenForCodec('shortU16', 0, 65535, value);\n            const shortU16Bytes = [0];\n            for (let ii = 0; ; ii += 1) {\n                // Shift the bits of the value over such that the next 7 bits are at the right edge.\n                const alignedValue = Number(value) >> (ii * 7);\n                if (alignedValue === 0) {\n                    // No more bits to consume.\n                    break;\n                }\n                // Extract those 7 bits using a mask.\n                const nextSevenBits = 0b1111111 & alignedValue;\n                shortU16Bytes[ii] = nextSevenBits;\n                if (ii > 0) {\n                    // Set the continuation bit of the previous slice.\n                    shortU16Bytes[ii - 1] |= 0b10000000;\n                }\n            }\n            bytes.set(shortU16Bytes, offset);\n            return offset + shortU16Bytes.length;\n        },\n    });\n\n/**\n * Decodes short u16 numbers.\n * @see {@link getShortU16Codec} for a more detailed description.\n */\nexport const getShortU16Decoder = (): VariableSizeDecoder<number> =>\n    createDecoder({\n        maxSize: 3,\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset): [number, Offset] => {\n            let value = 0;\n            let byteCount = 0;\n            while (++byteCount) {\n                const byteIndex = byteCount - 1;\n                const currentByte = bytes[offset + byteIndex];\n                const nextSevenBits = 0b1111111 & currentByte;\n                // Insert the next group of seven bits into the correct slot of the output value.\n                value |= nextSevenBits << (byteIndex * 7);\n                if ((currentByte & 0b10000000) === 0) {\n                    // This byte does not have its continuation bit set. We're done.\n                    break;\n                }\n            }\n            return [value, offset + byteCount];\n        },\n    });\n\n/**\n * Encodes and decodes short u16 numbers.\n *\n * Short u16 numbers are the same as u16, but serialized with 1 to 3 bytes.\n * If the value is above 0x7f, the top bit is set and the remaining\n * value is stored in the next bytes. Each byte follows the same\n * pattern until the 3rd byte. The 3rd byte, if needed, uses\n * all 8 bits to store the last byte of the original value.\n */\nexport const getShortU16Codec = (): VariableSizeCodec<bigint | number, number> =>\n    combineCodec(getShortU16Encoder(), getShortU16Decoder());\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getU128Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 16> =>\n    numberEncoderFactory({\n        config,\n        name: 'u128',\n        range: [0n, BigInt('0xffffffffffffffffffffffffffffffff')],\n        set: (view, value, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigUint64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16,\n    });\n\nexport const getU128Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 16> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigUint64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: 'u128',\n        size: 16,\n    });\n\nexport const getU128Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 16> =>\n    combineCodec(getU128Encoder(config), getU128Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getU16Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 2> =>\n    numberEncoderFactory({\n        config,\n        name: 'u16',\n        range: [0, Number('0xffff')],\n        set: (view, value, le) => view.setUint16(0, Number(value), le),\n        size: 2,\n    });\n\nexport const getU16Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 2> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getUint16(0, le),\n        name: 'u16',\n        size: 2,\n    });\n\nexport const getU16Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 2> =>\n    combineCodec(getU16Encoder(config), getU16Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getU32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'u32',\n        range: [0, Number('0xffffffff')],\n        set: (view, value, le) => view.setUint32(0, Number(value), le),\n        size: 4,\n    });\n\nexport const getU32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getUint32(0, le),\n        name: 'u32',\n        size: 4,\n    });\n\nexport const getU32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getU32Encoder(config), getU32Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getU64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'u64',\n        range: [0n, BigInt('0xffffffffffffffff')],\n        set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),\n        size: 8,\n    });\n\nexport const getU64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getBigUint64(0, le),\n        name: 'u64',\n        size: 8,\n    });\n\nexport const getU64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 8> =>\n    combineCodec(getU64Encoder(config), getU64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\nexport const getU8Encoder = (): FixedSizeEncoder<bigint | number, 1> =>\n    numberEncoderFactory({\n        name: 'u8',\n        range: [0, Number('0xff')],\n        set: (view, value) => view.setUint8(0, Number(value)),\n        size: 1,\n    });\n\nexport const getU8Decoder = (): FixedSizeDecoder<number, 1> =>\n    numberDecoderFactory({\n        get: view => view.getUint8(0),\n        name: 'u8',\n        size: 1,\n    });\n\nexport const getU8Codec = (): FixedSizeCodec<bigint | number, number, 1> =>\n    combineCodec(getU8Encoder(), getU8Decoder());\n","import { SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, SolanaError } from '@solana/errors';\n\n/** Checks the number of items in an array-like structure is expected. */\nexport function assertValidNumberOfItemsForCodec(\n    codecDescription: string,\n    expected: bigint | number,\n    actual: bigint | number,\n) {\n    if (expected !== actual) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, {\n            actual,\n            codecDescription,\n            expected,\n        });\n    }\n}\n","import { isFixedSize } from '@solana/codecs-core';\n\n/**\n * Functionally, this type helper is equivalent to the identity type — i.e. `type Identity<T> = T`.\n * However, wrapping generic object mappings in this type significantly reduces the number\n * of instantiation expressions processed, which increases TypeScript performance and\n * prevents \"Type instantiation is excessively deep and possibly infinite\" errors.\n *\n * This works because TypeScript doesn't create a new level of nesting when encountering conditional generic types.\n * @see https://github.com/microsoft/TypeScript/issues/34933\n * @see https://github.com/kysely-org/kysely/pull/483\n */\nexport type DrainOuterGeneric<T> = [T] extends [unknown] ? T : never;\n\nexport function maxCodecSizes(sizes: (number | null)[]): number | null {\n    return sizes.reduce(\n        (all, size) => (all === null || size === null ? null : Math.max(all, size)),\n        0 as number | null,\n    );\n}\n\nexport function sumCodecSizes(sizes: (number | null)[]): number | null {\n    return sizes.reduce((all, size) => (all === null || size === null ? null : all + size), 0 as number | null);\n}\n\nexport function getFixedSize(codec: { fixedSize: number } | { maxSize?: number }): number | null {\n    return isFixedSize(codec) ? codec.fixedSize : null;\n}\n\nexport function getMaxSize(codec: { fixedSize: number } | { maxSize?: number }): number | null {\n    return isFixedSize(codec) ? codec.fixedSize : (codec.maxSize ?? null);\n}\n","import {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getU32Decoder, getU32Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { assertValidNumberOfItemsForCodec } from './assertions';\nimport { getFixedSize, getMaxSize } from './utils';\n\n/**\n * Represents all the size options for array-like codecs\n * — i.e. `array`, `map` and `set`.\n *\n * It can be one of the following:\n * - a {@link NumberCodec} that prefixes its content with its size.\n * - a fixed number of items.\n * - or `'remainder'` to infer the number of items by dividing\n *   the rest of the byte array by the fixed size of its item.\n *   Note that this option is only available for fixed-size items.\n */\nexport type ArrayLikeCodecSize<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> =\n    | TPrefix\n    | number\n    | 'remainder';\n\n/** Defines the configs for array codecs. */\nexport type ArrayCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size of the array.\n     * @defaultValue u32 prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Encodes an array of items.\n *\n * @param item - The encoder to use for the array's items.\n * @param config - A set of config for the encoder.\n */\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<TFrom[], 0>;\nexport function getArrayEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<TFrom[]>;\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: ArrayCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<TFrom[]>;\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> = {},\n): Encoder<TFrom[]> {\n    const size = config.size ?? getU32Encoder();\n    const fixedSize = computeArrayLikeCodecSize(size, getFixedSize(item));\n    const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize !== null\n            ? { fixedSize }\n            : {\n                  getSizeFromValue: (array: TFrom[]) => {\n                      const prefixSize = typeof size === 'object' ? getEncodedSize(array.length, size) : 0;\n                      return prefixSize + [...array].reduce((all, value) => all + getEncodedSize(value, item), 0);\n                  },\n                  maxSize,\n              }),\n        write: (array: TFrom[], bytes, offset) => {\n            if (typeof size === 'number') {\n                assertValidNumberOfItemsForCodec('array', size, array.length);\n            }\n            if (typeof size === 'object') {\n                offset = size.write(array.length, bytes, offset);\n            }\n            array.forEach(value => {\n                offset = item.write(value, bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Decodes an array of items.\n *\n * @param item - The encoder to use for the array's items.\n * @param config - A set of config for the encoder.\n */\nexport function getArrayDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: ArrayCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<TTo[], 0>;\nexport function getArrayDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: ArrayCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<TTo[]>;\nexport function getArrayDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: ArrayCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<TTo[]>;\nexport function getArrayDecoder<TTo>(item: Decoder<TTo>, config: ArrayCodecConfig<NumberDecoder> = {}): Decoder<TTo[]> {\n    const size = config.size ?? getU32Decoder();\n    const itemSize = getFixedSize(item);\n    const fixedSize = computeArrayLikeCodecSize(size, itemSize);\n    const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize !== null ? { fixedSize } : { maxSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const array: TTo[] = [];\n            if (typeof size === 'object' && bytes.slice(offset).length === 0) {\n                return [array, offset];\n            }\n\n            if (size === 'remainder') {\n                while (offset < bytes.length) {\n                    const [value, newOffset] = item.read(bytes, offset);\n                    offset = newOffset;\n                    array.push(value);\n                }\n                return [array, offset];\n            }\n\n            const [resolvedSize, newOffset] = typeof size === 'number' ? [size, offset] : size.read(bytes, offset);\n            offset = newOffset;\n            for (let i = 0; i < resolvedSize; i += 1) {\n                const [value, newOffset] = item.read(bytes, offset);\n                offset = newOffset;\n                array.push(value);\n            }\n            return [array, offset];\n        },\n    });\n}\n\n/**\n * Creates a codec for an array of items.\n *\n * @param item - The codec to use for the array's items.\n * @param config - A set of config for the codec.\n */\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<TFrom[], TTo[], 0>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<TFrom[], TTo[]>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: ArrayCodecConfig<NumberCodec>,\n): VariableSizeCodec<TFrom[], TTo[]>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> = {},\n): Codec<TFrom[], TTo[]> {\n    return combineCodec(getArrayEncoder(item, config as object), getArrayDecoder(item, config as object));\n}\n\nfunction computeArrayLikeCodecSize(size: number | object | 'remainder', itemSize: number | null): number | null {\n    if (typeof size !== 'number') return null;\n    if (size === 0) return 0;\n    return itemSize === null ? null : itemSize * size;\n}\n","import {\n    assertByteArrayHasEnoughBytesForCodec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n} from '@solana/codecs-core';\n\n/** Defines the config for bitArray codecs. */\nexport type BitArrayCodecConfig = {\n    /**\n     * Whether to read the bits in reverse order.\n     * @defaultValue `false`\n     */\n    backward?: boolean;\n};\n\n/**\n * Encodes an array of booleans into bits.\n *\n * @param size - The amount of bytes to use for the bit array.\n * @param config - A set of config for the encoder.\n */\nexport function getBitArrayEncoder<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeEncoder<boolean[], TSize> {\n    const parsedConfig: BitArrayCodecConfig = typeof config === 'boolean' ? { backward: config } : config;\n    const backward = parsedConfig.backward ?? false;\n    return createEncoder({\n        fixedSize: size,\n        write(value: boolean[], bytes, offset) {\n            const bytesToAdd: number[] = [];\n\n            for (let i = 0; i < size; i += 1) {\n                let byte = 0;\n                for (let j = 0; j < 8; j += 1) {\n                    const feature = Number(value[i * 8 + j] ?? 0);\n                    byte |= feature << (backward ? j : 7 - j);\n                }\n                if (backward) {\n                    bytesToAdd.unshift(byte);\n                } else {\n                    bytesToAdd.push(byte);\n                }\n            }\n\n            bytes.set(bytesToAdd, offset);\n            return size;\n        },\n    });\n}\n\n/**\n * Decodes bits into an array of booleans.\n *\n * @param size - The amount of bytes to use for the bit array.\n * @param config - A set of config for the decoder.\n */\nexport function getBitArrayDecoder<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeDecoder<boolean[], TSize> {\n    const parsedConfig: BitArrayCodecConfig = typeof config === 'boolean' ? { backward: config } : config;\n    const backward = parsedConfig.backward ?? false;\n    return createDecoder({\n        fixedSize: size,\n        read(bytes, offset) {\n            assertByteArrayHasEnoughBytesForCodec('bitArray', size, bytes, offset);\n            const booleans: boolean[] = [];\n            let slice = bytes.slice(offset, offset + size);\n            slice = backward ? slice.reverse() : slice;\n\n            slice.forEach(byte => {\n                for (let i = 0; i < 8; i += 1) {\n                    if (backward) {\n                        booleans.push(Boolean(byte & 1));\n                        byte >>= 1;\n                    } else {\n                        booleans.push(Boolean(byte & 0b1000_0000));\n                        byte <<= 1;\n                    }\n                }\n            });\n\n            return [booleans, offset + size];\n        },\n    });\n}\n\n/**\n * An array of boolean codec that converts booleans to bits and vice versa.\n *\n * @param size - The amount of bytes to use for the bit array.\n * @param config - A set of config for the codec.\n */\nexport function getBitArrayCodec<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeCodec<boolean[], boolean[], TSize> {\n    return combineCodec(getBitArrayEncoder(size, config), getBitArrayDecoder(size, config));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\n/** Defines the config for boolean codecs. */\nexport type BooleanCodecConfig<TSize extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The number codec to delegate to.\n     * @defaultValue u8 size.\n     */\n    size?: TSize;\n};\n\n/**\n * Encodes booleans.\n *\n * @param config - A set of config for the encoder.\n */\nexport function getBooleanEncoder(): FixedSizeEncoder<boolean, 1>;\nexport function getBooleanEncoder<TSize extends number>(\n    config: BooleanCodecConfig<NumberEncoder> & { size: FixedSizeNumberEncoder<TSize> },\n): FixedSizeEncoder<boolean, TSize>;\nexport function getBooleanEncoder(config: BooleanCodecConfig<NumberEncoder>): VariableSizeEncoder<boolean>;\nexport function getBooleanEncoder(config: BooleanCodecConfig<NumberEncoder> = {}): Encoder<boolean> {\n    return transformEncoder(config.size ?? getU8Encoder(), (value: boolean) => (value ? 1 : 0));\n}\n\n/**\n * Decodes booleans.\n *\n * @param config - A set of config for the decoder.\n */\nexport function getBooleanDecoder(): FixedSizeDecoder<boolean, 1>;\nexport function getBooleanDecoder<TSize extends number>(\n    config: BooleanCodecConfig<NumberDecoder> & { size: FixedSizeNumberDecoder<TSize> },\n): FixedSizeDecoder<boolean, TSize>;\nexport function getBooleanDecoder(config: BooleanCodecConfig<NumberDecoder>): VariableSizeDecoder<boolean>;\nexport function getBooleanDecoder(config: BooleanCodecConfig<NumberDecoder> = {}): Decoder<boolean> {\n    return transformDecoder(config.size ?? getU8Decoder(), (value: bigint | number): boolean => Number(value) === 1);\n}\n\n/**\n * Creates a boolean codec.\n *\n * @param config - A set of config for the codec.\n */\nexport function getBooleanCodec(): FixedSizeCodec<boolean, boolean, 1>;\nexport function getBooleanCodec<TSize extends number>(\n    config: BooleanCodecConfig<NumberCodec> & { size: FixedSizeNumberCodec<TSize> },\n): FixedSizeCodec<boolean, boolean, TSize>;\nexport function getBooleanCodec(config: BooleanCodecConfig<NumberCodec>): VariableSizeCodec<boolean>;\nexport function getBooleanCodec(config: BooleanCodecConfig<NumberCodec> = {}): Codec<boolean> {\n    return combineCodec(getBooleanEncoder(config), getBooleanDecoder(config));\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\n/**\n * Encodes byte arrays as provided.\n *\n * To control the size of the encoded byte array, you can use\n * the `fixEncoderSize` or `addEncoderSizePrefix` functions.\n */\nexport function getBytesEncoder(): VariableSizeEncoder<ReadonlyUint8Array | Uint8Array> {\n    return createEncoder({\n        getSizeFromValue: value => value.length,\n        write: (value, bytes, offset) => {\n            bytes.set(value, offset);\n            return offset + value.length;\n        },\n    });\n}\n\n/**\n * Decodes byte arrays as-is.\n *\n * To control the size of the decoded byte array, you can use\n * the `fixDecoderSize` or `addDecoderSizePrefix` functions.\n */\nexport function getBytesDecoder(): VariableSizeDecoder<ReadonlyUint8Array> {\n    return createDecoder({\n        read: (bytes, offset) => {\n            const slice = bytes.slice(offset);\n            return [slice, offset + slice.length];\n        },\n    });\n}\n\n/**\n * Creates a sized bytes codec.\n *\n * To control the size of the encoded and decoded byte arrays,\n * you can use the `fixCodecSize` or `addCodecSizePrefix` functions.\n */\nexport function getBytesCodec(): VariableSizeCodec<ReadonlyUint8Array | Uint8Array, ReadonlyUint8Array> {\n    return combineCodec(getBytesEncoder(), getBytesDecoder());\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nconst enum HexC {\n    ZERO = 48, // 0\n    NINE = 57, // 9\n    A_UP = 65, // A\n    F_UP = 70, // F\n    A_LO = 97, // a\n    F_LO = 102, // f\n}\n\nconst INVALID_STRING_ERROR_BASE_CONFIG = {\n    alphabet: '0123456789abcdef',\n    base: 16,\n} as const;\n\nfunction charCodeToBase16(char: number) {\n    if (char >= HexC.ZERO && char <= HexC.NINE) return char - HexC.ZERO;\n    if (char >= HexC.A_UP && char <= HexC.F_UP) return char - (HexC.A_UP - 10);\n    if (char >= HexC.A_LO && char <= HexC.F_LO) return char - (HexC.A_LO - 10);\n}\n\n/** Encodes strings in base16. */\nexport const getBase16Encoder = (): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.ceil(value.length / 2),\n        write(value: string, bytes, offset) {\n            const len = value.length;\n            const al = len / 2;\n            if (len === 1) {\n                const c = value.charCodeAt(0);\n                const n = charCodeToBase16(c);\n                if (n === undefined) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                bytes.set([n], offset);\n                return 1 + offset;\n            }\n            const hexBytes = new Uint8Array(al);\n            for (let i = 0, j = 0; i < al; i++) {\n                const c1 = value.charCodeAt(j++);\n                const c2 = value.charCodeAt(j++);\n\n                const n1 = charCodeToBase16(c1);\n                const n2 = charCodeToBase16(c2);\n                if (n1 === undefined || (n2 === undefined && !Number.isNaN(c2))) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                hexBytes[i] = !Number.isNaN(c2) ? (n1 << 4) | (n2 ?? 0) : n1;\n            }\n\n            bytes.set(hexBytes, offset);\n            return hexBytes.length + offset;\n        },\n    });\n\n/** Decodes strings in base16. */\nexport const getBase16Decoder = (): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n            return [value, bytes.length];\n        },\n    });\n\n/** Encodes and decodes strings in base16. */\nexport const getBase16Codec = (): VariableSizeCodec<string> => combineCodec(getBase16Encoder(), getBase16Decoder());\n","import {\n    combineCodec,\n    containsBytes,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\nimport { getBase16Decoder } from '@solana/codecs-strings';\nimport { SOLANA_ERROR__CODECS__INVALID_CONSTANT, SolanaError } from '@solana/errors';\n\n/**\n * Creates a void encoder that always sets the provided byte array when encoding.\n */\nexport function getConstantEncoder<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeEncoder<void, TConstant['length']> {\n    return createEncoder({\n        fixedSize: constant.length,\n        write: (_, bytes, offset) => {\n            bytes.set(constant, offset);\n            return offset + constant.length;\n        },\n    });\n}\n\n/**\n * Creates a void decoder that reads the next bytes and fails if they do not match the provided constant.\n */\nexport function getConstantDecoder<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeDecoder<void, TConstant['length']> {\n    return createDecoder({\n        fixedSize: constant.length,\n        read: (bytes, offset) => {\n            const base16 = getBase16Decoder();\n            if (!containsBytes(bytes, constant, offset)) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_CONSTANT, {\n                    constant,\n                    data: bytes,\n                    hexConstant: base16.decode(constant),\n                    hexData: base16.decode(bytes),\n                    offset,\n                });\n            }\n            return [undefined, offset + constant.length];\n        },\n    });\n}\n\n/**\n * Creates a void codec that always sets the provided byte array\n * when encoding and, when decoding, asserts that the next\n * bytes match the provided byte array.\n */\nexport function getConstantCodec<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeCodec<void, void, TConstant['length']> {\n    return combineCodec(getConstantEncoder(constant), getConstantDecoder(constant));\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidNumberOfItemsForCodec } from './assertions';\nimport { DrainOuterGeneric, getFixedSize, getMaxSize, sumCodecSizes } from './utils';\n\ntype GetEncoderTypeFromItems<TItems extends readonly Encoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TItems]: TItems[I] extends Encoder<infer TFrom> ? TFrom : never;\n}>;\n\ntype GetDecoderTypeFromItems<TItems extends readonly Decoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TItems]: TItems[I] extends Decoder<infer TTo> ? TTo : never;\n}>;\n\n/**\n * Creates a encoder for a tuple-like array.\n *\n * @param items - The encoders to use for each item in the tuple.\n */\nexport function getTupleEncoder<const TItems extends readonly FixedSizeEncoder<any>[]>(\n    items: TItems,\n): FixedSizeEncoder<GetEncoderTypeFromItems<TItems>>;\nexport function getTupleEncoder<const TItems extends readonly Encoder<any>[]>(\n    items: TItems,\n): VariableSizeEncoder<GetEncoderTypeFromItems<TItems>>;\nexport function getTupleEncoder<const TItems extends readonly Encoder<any>[]>(\n    items: TItems,\n): Encoder<GetEncoderTypeFromItems<TItems>> {\n    type TFrom = GetEncoderTypeFromItems<TItems>;\n    const fixedSize = sumCodecSizes(items.map(getFixedSize));\n    const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize === null\n            ? {\n                  getSizeFromValue: (value: TFrom) =>\n                      items.map((item, index) => getEncodedSize(value[index], item)).reduce((all, one) => all + one, 0),\n                  maxSize,\n              }\n            : { fixedSize }),\n        write: (value: TFrom, bytes, offset) => {\n            assertValidNumberOfItemsForCodec('tuple', items.length, value.length);\n            items.forEach((item, index) => {\n                offset = item.write(value[index], bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Creates a decoder for a tuple-like array.\n *\n * @param items - The decoders to use for each item in the tuple.\n */\n\nexport function getTupleDecoder<const TItems extends readonly FixedSizeDecoder<any>[]>(\n    items: TItems,\n): FixedSizeDecoder<GetDecoderTypeFromItems<TItems>>;\nexport function getTupleDecoder<const TItems extends readonly Decoder<any>[]>(\n    items: TItems,\n): VariableSizeDecoder<GetDecoderTypeFromItems<TItems>>;\nexport function getTupleDecoder<const TItems extends readonly Decoder<any>[]>(\n    items: TItems,\n): Decoder<GetDecoderTypeFromItems<TItems>> {\n    type TTo = GetDecoderTypeFromItems<TItems>;\n    const fixedSize = sumCodecSizes(items.map(getFixedSize));\n    const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize === null ? { maxSize } : { fixedSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const values = [] as Array<any> & TTo;\n            items.forEach(item => {\n                const [newValue, newOffset] = item.read(bytes, offset);\n                values.push(newValue);\n                offset = newOffset;\n            });\n            return [values, offset];\n        },\n    });\n}\n\n/**\n * Creates a codec for a tuple-like array.\n *\n * @param items - The codecs to use for each item in the tuple.\n */\nexport function getTupleCodec<const TItems extends readonly FixedSizeCodec<any>[]>(\n    items: TItems,\n): FixedSizeCodec<GetEncoderTypeFromItems<TItems>, GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>>;\nexport function getTupleCodec<const TItems extends readonly Codec<any>[]>(\n    items: TItems,\n): VariableSizeCodec<\n    GetEncoderTypeFromItems<TItems>,\n    GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>\n>;\nexport function getTupleCodec<const TItems extends readonly Codec<any>[]>(\n    items: TItems,\n): Codec<GetEncoderTypeFromItems<TItems>, GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>> {\n    return combineCodec(\n        getTupleEncoder(items),\n        getTupleDecoder(items) as Decoder<GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>>,\n    );\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    getEncodedSize,\n    isFixedSize,\n    Offset,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\nimport { DrainOuterGeneric, getMaxSize, maxCodecSizes } from './utils';\n\ntype GetEncoderTypeFromVariants<TVariants extends readonly Encoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TVariants]: TVariants[I] extends Encoder<infer TFrom> ? TFrom : never;\n}>[number];\n\ntype GetDecoderTypeFromVariants<TVariants extends readonly Decoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TVariants]: TVariants[I] extends Decoder<infer TFrom> ? TFrom : never;\n}>[number];\n\n/**\n * Creates a union encoder from the provided array of encoder.\n *\n * @param variants - The variant encoders of the union.\n * @param getIndexFromValue - A function that returns the index of the variant from the provided value.\n */\nexport function getUnionEncoder<const TVariants extends readonly Encoder<any>[]>(\n    variants: TVariants,\n    getIndexFromValue: (value: GetEncoderTypeFromVariants<TVariants>) => number,\n): Encoder<GetEncoderTypeFromVariants<TVariants>> {\n    type TFrom = GetEncoderTypeFromVariants<TVariants>;\n    const fixedSize = getUnionFixedSize(variants);\n    const write: Encoder<TFrom>['write'] = (variant, bytes, offset) => {\n        const index = getIndexFromValue(variant);\n        assertValidVariantIndex(variants, index);\n        return variants[index].write(variant, bytes, offset);\n    };\n\n    if (fixedSize !== null) {\n        return createEncoder({ fixedSize, write });\n    }\n\n    const maxSize = getUnionMaxSize(variants);\n    return createEncoder({\n        ...(maxSize !== null ? { maxSize } : {}),\n        getSizeFromValue: variant => {\n            const index = getIndexFromValue(variant);\n            assertValidVariantIndex(variants, index);\n            return getEncodedSize(variant, variants[index]);\n        },\n        write,\n    });\n}\n\n/**\n * Creates a union decoder from the provided array of decoder.\n *\n * @param variants - The variant decoders of the union.\n * @param getIndexFromBytes - A function that returns the index of the variant from the byte array.\n */\nexport function getUnionDecoder<const TVariants extends readonly Decoder<any>[]>(\n    variants: TVariants,\n    getIndexFromBytes: (bytes: ReadonlyUint8Array, offset: Offset) => number,\n): Decoder<GetDecoderTypeFromVariants<TVariants>> {\n    type TTo = GetDecoderTypeFromVariants<TVariants>;\n    const fixedSize = getUnionFixedSize(variants);\n    const read: Decoder<TTo>['read'] = (bytes, offset) => {\n        const index = getIndexFromBytes(bytes, offset);\n        assertValidVariantIndex(variants, index);\n        return variants[index].read(bytes, offset);\n    };\n\n    if (fixedSize !== null) {\n        return createDecoder({ fixedSize, read });\n    }\n\n    const maxSize = getUnionMaxSize(variants);\n    return createDecoder({ ...(maxSize !== null ? { maxSize } : {}), read });\n}\n\n/**\n * Creates a union codec from the provided array of codec.\n *\n * @param variants - The variant codecs of the union.\n * @param getIndexFromValue - A function that returns the index of the variant from the provided value.\n * @param getIndexFromBytes - A function that returns the index of the variant from the byte array.\n */\nexport function getUnionCodec<const TVariants extends readonly Codec<any>[]>(\n    variants: TVariants,\n    getIndexFromValue: (value: GetEncoderTypeFromVariants<TVariants>) => number,\n    getIndexFromBytes: (bytes: ReadonlyUint8Array, offset: Offset) => number,\n): Codec<\n    GetEncoderTypeFromVariants<TVariants>,\n    GetDecoderTypeFromVariants<TVariants> & GetEncoderTypeFromVariants<TVariants>\n> {\n    return combineCodec(\n        getUnionEncoder(variants, getIndexFromValue),\n        getUnionDecoder(variants, getIndexFromBytes) as Decoder<\n            GetDecoderTypeFromVariants<TVariants> & GetEncoderTypeFromVariants<TVariants>\n        >,\n    );\n}\n\nfunction assertValidVariantIndex(variants: readonly unknown[], index: number) {\n    if (typeof variants[index] === 'undefined') {\n        throw new SolanaError(SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, {\n            maxRange: variants.length - 1,\n            minRange: 0,\n            variant: index,\n        });\n    }\n}\n\nfunction getUnionFixedSize<const TVariants extends readonly (Decoder<any> | Encoder<any>)[]>(variants: TVariants) {\n    if (variants.length === 0) return 0;\n    if (!isFixedSize(variants[0])) return null;\n    const variantSize = variants[0].fixedSize;\n    const sameSizedVariants = variants.every(variant => isFixedSize(variant) && variant.fixedSize === variantSize);\n    return sameSizedVariants ? variantSize : null;\n}\n\nfunction getUnionMaxSize<const TVariants extends readonly (Decoder<any> | Encoder<any>)[]>(variants: TVariants) {\n    return maxCodecSizes(variants.map(variant => getMaxSize(variant)));\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Codec, combineCodec, Decoder, Encoder, transformDecoder, transformEncoder } from '@solana/codecs-core';\nimport { getU8Decoder, getU8Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, SolanaError } from '@solana/errors';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\nimport { getUnionDecoder, getUnionEncoder } from './union';\nimport { DrainOuterGeneric } from './utils';\n\n/**\n * Defines a discriminated union using discriminated union types.\n *\n * @example\n * ```ts\n * type WebPageEvent =\n *   | { __kind: 'pageview', url: string }\n *   | { __kind: 'click', x: number, y: number };\n * ```\n */\nexport type DiscriminatedUnion<\n    TDiscriminatorProperty extends string = '__kind',\n    TDiscriminatorValue extends string = string,\n> = {\n    [P in TDiscriminatorProperty]: TDiscriminatorValue;\n};\n\n/**\n * Extracts a variant from a discriminated union.\n *\n * @example\n * ```ts\n * type WebPageEvent =\n *   | { __kind: 'pageview', url: string }\n *   | { __kind: 'click', x: number, y: number };\n * type ClickEvent = GetDiscriminatedUnionVariant<WebPageEvent, '__kind', 'click'>;\n * // -> { __kind: 'click', x: number, y: number }\n * ```\n */\nexport type GetDiscriminatedUnionVariant<\n    TUnion extends DiscriminatedUnion<TDiscriminatorProperty>,\n    TDiscriminatorProperty extends string,\n    TDiscriminatorValue extends TUnion[TDiscriminatorProperty],\n> = Extract<TUnion, DiscriminatedUnion<TDiscriminatorProperty, TDiscriminatorValue>>;\n\n/**\n * Extracts a variant from a discriminated union without its discriminator.\n *\n * @example\n * ```ts\n * type WebPageEvent =\n *   | { __kind: 'pageview', url: string }\n *   | { __kind: 'click', x: number, y: number };\n * type ClickEvent = GetDiscriminatedUnionVariantContent<WebPageEvent, '__kind', 'click'>;\n * // -> { x: number, y: number }\n * ```\n */\nexport type GetDiscriminatedUnionVariantContent<\n    TUnion extends DiscriminatedUnion<TDiscriminatorProperty>,\n    TDiscriminatorProperty extends string,\n    TDiscriminatorValue extends TUnion[TDiscriminatorProperty],\n> = Omit<GetDiscriminatedUnionVariant<TUnion, TDiscriminatorProperty, TDiscriminatorValue>, TDiscriminatorProperty>;\n\n/** Defines the config for discriminated union codecs. */\nexport type DiscriminatedUnionCodecConfig<\n    TDiscriminatorProperty extends string = '__kind',\n    TDiscriminatorSize = NumberCodec | NumberDecoder | NumberEncoder,\n> = {\n    /**\n     * The property name of the discriminator.\n     * @defaultValue `__kind`.\n     */\n    discriminator?: TDiscriminatorProperty;\n    /**\n     * The codec to use for the enum discriminator prefixing the variant.\n     * @defaultValue u8 prefix.\n     */\n    size?: TDiscriminatorSize;\n};\n\ntype DiscriminatorValue = bigint | boolean | number | string | null | undefined;\ntype Variants<T> = readonly (readonly [DiscriminatorValue, T])[];\ntype ArrayIndices<T extends readonly unknown[]> = Exclude<Partial<T>['length'], T['length']> & number;\n\ntype GetEncoderTypeFromVariants<\n    TVariants extends Variants<Encoder<any>>,\n    TDiscriminatorProperty extends string,\n> = DrainOuterGeneric<{\n    [I in ArrayIndices<TVariants>]: (TVariants[I][1] extends Encoder<infer TFrom>\n        ? TFrom extends object\n            ? TFrom\n            : object\n        : never) & { [P in TDiscriminatorProperty]: TVariants[I][0] };\n}>[ArrayIndices<TVariants>];\n\ntype GetDecoderTypeFromVariants<\n    TVariants extends Variants<Decoder<any>>,\n    TDiscriminatorProperty extends string,\n> = DrainOuterGeneric<{\n    [I in ArrayIndices<TVariants>]: (TVariants[I][1] extends Decoder<infer TTo>\n        ? TTo extends object\n            ? TTo\n            : object\n        : never) & { [P in TDiscriminatorProperty]: TVariants[I][0] };\n}>[ArrayIndices<TVariants>];\n\n/**\n * Creates a discriminated union encoder.\n *\n * @param variants - The variant encoders of the discriminated union.\n * @param config - A set of config for the encoder.\n */\nexport function getDiscriminatedUnionEncoder<\n    const TVariants extends Variants<Encoder<any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberEncoder> = {},\n): Encoder<GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>> {\n    type TFrom = GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>;\n    const discriminatorProperty = (config.discriminator ?? '__kind') as TDiscriminatorProperty;\n    const prefix = config.size ?? getU8Encoder();\n    return getUnionEncoder(\n        variants.map(([, variant], index) =>\n            transformEncoder(getTupleEncoder([prefix, variant]), (value: TFrom): [number, TFrom] => [index, value]),\n        ),\n        value => getVariantDiscriminator(variants, value[discriminatorProperty]),\n    );\n}\n\n/**\n * Creates a discriminated union decoder.\n *\n * @param variants - The variant decoders of the discriminated union.\n * @param config - A set of config for the decoder.\n */\nexport function getDiscriminatedUnionDecoder<\n    const TVariants extends Variants<Decoder<any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberDecoder> = {},\n): Decoder<GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty>> {\n    const discriminatorProperty = config.discriminator ?? '__kind';\n    const prefix = config.size ?? getU8Decoder();\n    return getUnionDecoder(\n        variants.map(([discriminator, variant]) =>\n            transformDecoder(getTupleDecoder([prefix, variant]), ([, value]) => ({\n                [discriminatorProperty]: discriminator,\n                ...value,\n            })),\n        ),\n        (bytes, offset) => Number(prefix.read(bytes, offset)[0]),\n    );\n}\n\n/**\n * Creates a discriminated union codec.\n *\n * @param variants - The variant codecs of the discriminated union.\n * @param config - A set of config for the codec.\n */\nexport function getDiscriminatedUnionCodec<\n    const TVariants extends Variants<Codec<any, any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberCodec> = {},\n): Codec<\n    GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>,\n    GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty> &\n        GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n> {\n    return combineCodec(\n        getDiscriminatedUnionEncoder(variants, config),\n        getDiscriminatedUnionDecoder(variants, config) as Decoder<\n            GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty> &\n                GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n        >,\n    );\n}\n\nfunction getVariantDiscriminator<const TVariants extends Variants<Decoder<any> | Encoder<any>>>(\n    variants: TVariants,\n    discriminatorValue: DiscriminatorValue,\n) {\n    const discriminator = variants.findIndex(([key]) => discriminatorValue === key);\n    if (discriminator < 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, {\n            value: discriminatorValue,\n            variants: variants.map(([key]) => key),\n        });\n    }\n    return discriminator;\n}\n\n/** @deprecated Use `getDiscriminatedUnionEncoder` instead. */\nexport const getDataEnumEncoder = getDiscriminatedUnionEncoder;\n\n/** @deprecated Use `getDiscriminatedUnionDecoder` instead. */\nexport const getDataEnumDecoder = getDiscriminatedUnionDecoder;\n\n/** @deprecated Use `getDiscriminatedUnionCodec` instead. */\nexport const getDataEnumCodec = getDiscriminatedUnionCodec;\n","/**\n * Defines the \"lookup object\" of an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * ```\n */\nexport type EnumLookupObject = { [key: string]: number | string };\n\n/**\n * Returns the allowed input for an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * type DirectionInput = GetEnumFrom<Direction>; // \"Left\" | \"Right\" | 0 | 1\n * ```\n */\nexport type GetEnumFrom<TEnum extends EnumLookupObject> = TEnum[keyof TEnum] | keyof TEnum;\n\n/**\n * Returns all the available variants of an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * type DirectionOutput = GetEnumTo<Direction>; // 0 | 1\n * ```\n */\nexport type GetEnumTo<TEnum extends EnumLookupObject> = TEnum[keyof TEnum];\n\nexport function getEnumStats(constructor: EnumLookupObject) {\n    const numericalValues = [...new Set(Object.values(constructor).filter(v => typeof v === 'number'))].sort();\n    const enumRecord = Object.fromEntries(Object.entries(constructor).slice(numericalValues.length)) as Record<\n        string,\n        number | string\n    >;\n    const enumKeys = Object.keys(enumRecord);\n    const enumValues = Object.values(enumRecord);\n    const stringValues: string[] = [\n        ...new Set([...enumKeys, ...enumValues.filter((v): v is string => typeof v === 'string')]),\n    ];\n\n    return { enumKeys, enumRecord, enumValues, numericalValues, stringValues };\n}\n\nexport function getEnumIndexFromVariant({\n    enumKeys,\n    enumValues,\n    variant,\n}: {\n    enumKeys: string[];\n    enumValues: (number | string)[];\n    variant: number | string | symbol;\n}): number {\n    const valueIndex = findLastIndex(enumValues, value => value === variant);\n    if (valueIndex >= 0) return valueIndex;\n    return enumKeys.findIndex(key => key === variant);\n}\n\nexport function getEnumIndexFromDiscriminator({\n    discriminator,\n    enumKeys,\n    enumValues,\n    useValuesAsDiscriminators,\n}: {\n    discriminator: number;\n    enumKeys: string[];\n    enumValues: (number | string)[];\n    useValuesAsDiscriminators: boolean;\n}): number {\n    if (!useValuesAsDiscriminators) {\n        return discriminator >= 0 && discriminator < enumKeys.length ? discriminator : -1;\n    }\n    return findLastIndex(enumValues, value => value === discriminator);\n}\n\nfunction findLastIndex<T>(array: Array<T>, predicate: (value: T, index: number, obj: T[]) => boolean): number {\n    let l = array.length;\n    while (l--) {\n        if (predicate(array[l], l, array)) return l;\n    }\n    return -1;\n}\n\nexport function formatNumericalValues(values: number[]): string {\n    if (values.length === 0) return '';\n    let range: [number, number] = [values[0], values[0]];\n    const ranges: string[] = [];\n    for (let index = 1; index < values.length; index++) {\n        const value = values[index];\n        if (range[1] + 1 === value) {\n            range[1] = value;\n        } else {\n            ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n            range = [value, value];\n        }\n    }\n    ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n    return ranges.join(', ');\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\nimport {\n    SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS,\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT,\n    SolanaError,\n} from '@solana/errors';\n\nimport {\n    EnumLookupObject,\n    formatNumericalValues,\n    GetEnumFrom,\n    getEnumIndexFromDiscriminator,\n    getEnumIndexFromVariant,\n    getEnumStats,\n    GetEnumTo,\n} from './enum-helpers';\n\n/** Defines the config for enum codecs. */\nexport type EnumCodecConfig<TDiscriminator extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The codec to use for the enum discriminator.\n     * @defaultValue u8 discriminator.\n     */\n    size?: TDiscriminator;\n\n    /**\n     * When set to `true`, numeric values will be used as discriminantors and\n     * an error will be thrown if a string value is found on the enum.\n     * @defaultValue `false`\n     */\n    useValuesAsDiscriminators?: boolean;\n};\n\n/**\n * Creates an enum encoder.\n *\n * @param constructor - The constructor of the enum.\n * @param config - A set of config for the encoder.\n */\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberEncoder>, 'size'>,\n): FixedSizeEncoder<GetEnumFrom<TEnum>, 1>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberEncoder> & { size: FixedSizeNumberEncoder<TSize> },\n): FixedSizeEncoder<GetEnumFrom<TEnum>, TSize>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<GetEnumFrom<TEnum>>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberEncoder> = {},\n): Encoder<GetEnumFrom<TEnum>> {\n    const prefix = config.size ?? getU8Encoder();\n    const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n    const { enumKeys, enumValues, numericalValues, stringValues } = getEnumStats(constructor);\n    if (useValuesAsDiscriminators && enumValues.some(value => typeof value === 'string')) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n            stringValues: enumValues.filter((v): v is string => typeof v === 'string'),\n        });\n    }\n    return transformEncoder(prefix, (variant: GetEnumFrom<TEnum>): number => {\n        const index = getEnumIndexFromVariant({ enumKeys, enumValues, variant });\n        if (index < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT, {\n                formattedNumericalValues: formatNumericalValues(numericalValues),\n                numericalValues,\n                stringValues,\n                variant,\n            });\n        }\n        return useValuesAsDiscriminators ? (enumValues[index] as number) : index;\n    });\n}\n\n/**\n * Creates an enum decoder.\n *\n * @param constructor - The constructor of the enum.\n * @param config - A set of config for the decoder.\n */\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberDecoder>, 'size'>,\n): FixedSizeDecoder<GetEnumTo<TEnum>, 1>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberDecoder> & { size: FixedSizeNumberDecoder<TSize> },\n): FixedSizeDecoder<GetEnumTo<TEnum>, TSize>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<GetEnumTo<TEnum>>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberDecoder> = {},\n): Decoder<GetEnumTo<TEnum>> {\n    const prefix = config.size ?? getU8Decoder();\n    const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n    const { enumKeys, enumValues, numericalValues } = getEnumStats(constructor);\n    if (useValuesAsDiscriminators && enumValues.some(value => typeof value === 'string')) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n            stringValues: enumValues.filter((v): v is string => typeof v === 'string'),\n        });\n    }\n    return transformDecoder(prefix, (value: bigint | number): GetEnumTo<TEnum> => {\n        const discriminator = Number(value);\n        const index = getEnumIndexFromDiscriminator({\n            discriminator,\n            enumKeys,\n            enumValues,\n            useValuesAsDiscriminators,\n        });\n        if (index < 0) {\n            const validDiscriminators = useValuesAsDiscriminators\n                ? numericalValues\n                : [...Array(enumKeys.length).keys()];\n            throw new SolanaError(SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, {\n                discriminator,\n                formattedValidDiscriminators: formatNumericalValues(validDiscriminators),\n                validDiscriminators,\n            });\n        }\n        return enumValues[index] as GetEnumTo<TEnum>;\n    });\n}\n\n/**\n * Creates an enum codec.\n *\n * @param constructor - The constructor of the enum.\n * @param config - A set of config for the codec.\n */\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberCodec>, 'size'>,\n): FixedSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>, 1>;\nexport function getEnumCodec<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberCodec> & { size: FixedSizeNumberCodec<TSize> },\n): FixedSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>, TSize>;\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberCodec>,\n): VariableSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>>;\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberCodec> = {},\n): Codec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>> {\n    return combineCodec(getEnumEncoder(constructor, config), getEnumDecoder(constructor, config));\n}\n\n/** @deprecated Use `getEnumEncoder` instead. */\nexport const getScalarEnumEncoder = getEnumEncoder;\n\n/** @deprecated Use `getEnumDecoder` instead. */\nexport const getScalarEnumDecoder = getEnumDecoder;\n\n/** @deprecated Use `getEnumCodec` instead. */\nexport const getScalarEnumCodec = getEnumCodec;\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/**\n * Prefixes a given encoder with a list of void encoders.\n * All void encoders are hidden from the returned encoder.\n */\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    prefixedEncoders: readonly FixedSizeEncoder<void>[],\n): FixedSizeEncoder<TFrom>;\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    prefixedEncoders: readonly Encoder<void>[],\n): VariableSizeEncoder<TFrom>;\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    prefixedEncoders: readonly Encoder<void>[],\n): Encoder<TFrom> {\n    return transformEncoder(\n        getTupleEncoder([...prefixedEncoders, encoder]) as Encoder<readonly [...void[], TFrom]>,\n        (value: TFrom) => [...prefixedEncoders.map(() => undefined), value] as const,\n    );\n}\n\n/**\n * Prefixes a given decoder with a list of void decoder.\n * All void decoder are hidden from the returned decoder.\n */\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    prefixedDecoders: readonly FixedSizeDecoder<void>[],\n): FixedSizeDecoder<TTo>;\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    prefixedDecoders: readonly Decoder<void>[],\n): VariableSizeDecoder<TTo>;\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    prefixedDecoders: readonly Decoder<void>[],\n): Decoder<TTo> {\n    return transformDecoder(\n        getTupleDecoder([...prefixedDecoders, decoder]) as Decoder<readonly [...void[], TTo]>,\n        tuple => tuple[tuple.length - 1] as TTo,\n    );\n}\n\n/**\n * Prefixes a given codec with a list of void codec.\n * All void codec are hidden from the returned codec.\n */\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    prefixedCodecs: readonly FixedSizeCodec<void>[],\n): FixedSizeCodec<TFrom, TTo>;\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefixedCodecs: readonly Codec<void>[],\n): VariableSizeCodec<TFrom, TTo>;\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefixedCodecs: readonly Codec<void>[],\n): Codec<TFrom, TTo> {\n    return combineCodec(getHiddenPrefixEncoder(codec, prefixedCodecs), getHiddenPrefixDecoder(codec, prefixedCodecs));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/**\n * Suffixes a given encoder with a list of void encoders.\n * All void encoders are hidden from the returned encoder.\n */\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    suffixedEncoders: readonly FixedSizeEncoder<void>[],\n): FixedSizeEncoder<TFrom>;\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    suffixedEncoders: readonly Encoder<void>[],\n): VariableSizeEncoder<TFrom>;\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    suffixedEncoders: readonly Encoder<void>[],\n): Encoder<TFrom> {\n    return transformEncoder(\n        getTupleEncoder([encoder, ...suffixedEncoders]) as Encoder<readonly [TFrom, ...void[]]>,\n        (value: TFrom) => [value, ...suffixedEncoders.map(() => undefined)] as const,\n    );\n}\n\n/**\n * Suffixes a given decoder with a list of void decoder.\n * All void decoder are hidden from the returned decoder.\n */\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    suffixedDecoders: readonly FixedSizeDecoder<void>[],\n): FixedSizeDecoder<TTo>;\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    suffixedDecoders: readonly Decoder<void>[],\n): VariableSizeDecoder<TTo>;\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    suffixedDecoders: readonly Decoder<void>[],\n): Decoder<TTo> {\n    return transformDecoder(\n        getTupleDecoder([decoder, ...suffixedDecoders]) as Decoder<readonly [TTo, ...void[]]>,\n        tuple => tuple[0],\n    );\n}\n\n/**\n * Suffixes a given codec with a list of void codec.\n * All void codec are hidden from the returned codec.\n */\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    suffixedCodecs: readonly FixedSizeCodec<void>[],\n): FixedSizeCodec<TFrom, TTo>;\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    suffixedCodecs: readonly Codec<void>[],\n): VariableSizeCodec<TFrom, TTo>;\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    suffixedCodecs: readonly Codec<void>[],\n): Codec<TFrom, TTo> {\n    return combineCodec(getHiddenSuffixEncoder(codec, suffixedCodecs), getHiddenSuffixDecoder(codec, suffixedCodecs));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { ArrayLikeCodecSize, getArrayDecoder, getArrayEncoder } from './array';\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/** Defines the config for Map codecs. */\nexport type MapCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size of the array.\n     * @defaultValue u32 prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Creates a encoder for a map.\n *\n * @param key - The encoder to use for the map's keys.\n * @param value - The encoder to use for the map's values.\n * @param config - A set of config for the encoder.\n */\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<Map<TFromKey, TFromValue>, 0>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: FixedSizeEncoder<TFromKey>,\n    value: FixedSizeEncoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<Map<TFromKey, TFromValue>>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config?: MapCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<Map<TFromKey, TFromValue>>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> = {},\n): Encoder<Map<TFromKey, TFromValue>> {\n    return transformEncoder(\n        getArrayEncoder(getTupleEncoder([key, value]), config as object),\n        (map: Map<TFromKey, TFromValue>): [TFromKey, TFromValue][] => [...map.entries()],\n    );\n}\n\n/**\n * Creates a decoder for a map.\n *\n * @param key - The decoder to use for the map's keys.\n * @param value - The decoder to use for the map's values.\n * @param config - A set of config for the decoder.\n */\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<Map<TToKey, TToValue>, 0>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: FixedSizeDecoder<TToKey>,\n    value: FixedSizeDecoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<Map<TToKey, TToValue>>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config?: MapCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<Map<TToKey, TToValue>>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> = {},\n): Decoder<Map<TToKey, TToValue>> {\n    return transformDecoder(\n        getArrayDecoder(getTupleDecoder([key, value]), config as object) as Decoder<[TToKey, TToValue][]>,\n        (entries: [TToKey, TToValue][]): Map<TToKey, TToValue> => new Map(entries),\n    );\n}\n\n/**\n * Creates a codec for a map.\n *\n * @param key - The codec to use for the map's keys.\n * @param value - The codec to use for the map's values.\n * @param config - A set of config for the codec.\n */\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>, 0>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: FixedSizeCodec<TFromKey, TToKey>,\n    value: FixedSizeCodec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config?: MapCodecConfig<NumberCodec>,\n): VariableSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> = {},\n): Codec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>> {\n    return combineCodec(getMapEncoder(key, value, config as object), getMapDecoder(key, value, config as object));\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\n\n/**\n * Creates a void encoder.\n */\nexport function getUnitEncoder(): FixedSizeEncoder<void, 0> {\n    return createEncoder({\n        fixedSize: 0,\n        write: (_value, _bytes, offset) => offset,\n    });\n}\n\n/**\n * Creates a void decoder.\n */\nexport function getUnitDecoder(): FixedSizeDecoder<void, 0> {\n    return createDecoder({\n        fixedSize: 0,\n        read: (_bytes: ReadonlyUint8Array | Uint8Array, offset) => [undefined, offset],\n    });\n}\n\n/**\n * Creates a void codec.\n */\nexport function getUnitCodec(): FixedSizeCodec<void, void, 0> {\n    return combineCodec(getUnitEncoder(), getUnitDecoder());\n}\n","import {\n    assertIsFixedSize,\n    Codec,\n    combineCodec,\n    containsBytes,\n    Decoder,\n    Encoder,\n    fixDecoderSize,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    fixEncoderSize,\n    ReadonlyUint8Array,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\nimport { getBooleanDecoder, getBooleanEncoder } from './boolean';\nimport { getConstantDecoder, getConstantEncoder } from './constant';\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\nimport { getUnionDecoder, getUnionEncoder } from './union';\nimport { getUnitDecoder, getUnitEncoder } from './unit';\n\n/** Defines the config for nullable codecs. */\nexport type NullableCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * Defines how the `None` (or `null`) value should be represented.\n     *\n     * By default, no none value is used. This means a `null` value will be\n     * represented by the absence of the item.\n     *\n     * When `'zeroes'` is provided, a `null` value will skip the bytes that would\n     * have been used for the item. Note that this returns a fixed-size codec\n     * and thus will only work if the item codec is of fixed size.\n     *\n     * When a custom byte array is provided, a `null` value will be represented\n     * by the provided byte array. Note that this returns a variable-size codec\n     * since the byte array representing `null` does not need to match the size\n     * of the item codec.\n     *\n     * @defaultValue No none value is used.\n     */\n    noneValue?: ReadonlyUint8Array | 'zeroes';\n\n    /**\n     * The codec to use for the boolean prefix, if any.\n     *\n     * By default a `u8` number is used as a prefix to determine if the value is `null`.\n     * The value `0` is encoded for `null` and `1` if the value is present.\n     * This can be set to any number codec to customize the prefix.\n     *\n     * When `null` is provided, no prefix is used and the `noneValue` is used to\n     * determine if the value is `null`. If no `noneValue` is provided, then the\n     * absence of any bytes is used to determine if the value is `null`.\n     *\n     * @defaultValue `u8` prefix.\n     */\n    prefix?: TPrefix | null;\n};\n\n/**\n * Creates a encoder for an optional value using `null` as the `None` value.\n *\n * @param item - The encoder to use for the value that may be present.\n * @param config - A set of config for the encoder.\n */\nexport function getNullableEncoder<TFrom, TSize extends number>(\n    item: FixedSizeEncoder<TFrom, TSize>,\n    config: NullableCodecConfig<NumberEncoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeEncoder<TFrom | null, TSize>;\nexport function getNullableEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: NullableCodecConfig<FixedSizeNumberEncoder> & { noneValue: 'zeroes' },\n): FixedSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: NullableCodecConfig<NumberEncoder> & { noneValue: 'zeroes' },\n): VariableSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: NullableCodecConfig<NumberEncoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: NullableCodecConfig<NumberEncoder> = {},\n): Encoder<TFrom | null> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformEncoder(getUnitEncoder(), (_boolean: boolean) => undefined);\n        }\n        return getBooleanEncoder({ size: config.prefix ?? getU8Encoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixEncoderSize(getUnitEncoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitEncoder();\n        }\n        return getConstantEncoder(config.noneValue);\n    })();\n\n    return getUnionEncoder(\n        [\n            transformEncoder(getTupleEncoder([prefix, noneValue]), (_value: null): [boolean, void] => [\n                false,\n                undefined,\n            ]),\n            transformEncoder(getTupleEncoder([prefix, item]), (value: TFrom): [boolean, TFrom] => [true, value]),\n        ],\n        variant => Number(variant !== null),\n    );\n}\n\n/**\n * Creates a decoder for an optional value using `null` as the `None` value.\n *\n * @param item - The decoder to use for the value that may be present.\n * @param config - A set of config for the decoder.\n */\nexport function getNullableDecoder<TTo, TSize extends number>(\n    item: FixedSizeDecoder<TTo, TSize>,\n    config: NullableCodecConfig<NumberDecoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeDecoder<TTo | null, TSize>;\nexport function getNullableDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: NullableCodecConfig<FixedSizeNumberDecoder> & { noneValue: 'zeroes' },\n): FixedSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: NullableCodecConfig<NumberDecoder> & { noneValue: 'zeroes' },\n): VariableSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: NullableCodecConfig<NumberDecoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: NullableCodecConfig<NumberDecoder> = {},\n): Decoder<TTo | null> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformDecoder(getUnitDecoder(), () => false);\n        }\n        return getBooleanDecoder({ size: config.prefix ?? getU8Decoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixDecoderSize(getUnitDecoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitDecoder();\n        }\n        return getConstantDecoder(config.noneValue);\n    })();\n\n    return getUnionDecoder(\n        [\n            transformDecoder(getTupleDecoder([prefix, noneValue]), () => null),\n            transformDecoder(getTupleDecoder([prefix, item]), ([, value]): TTo => value),\n        ],\n        (bytes, offset) => {\n            if (config.prefix === null && !config.noneValue) {\n                return Number(offset < bytes.length);\n            }\n            if (config.prefix === null && config.noneValue != null) {\n                const zeroValue =\n                    config.noneValue === 'zeroes' ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;\n                return containsBytes(bytes, zeroValue, offset) ? 0 : 1;\n            }\n            return Number(prefix.read(bytes, offset)[0]);\n        },\n    );\n}\n\n/**\n * Creates a codec for an optional value using `null` as the `None` value.\n *\n * @param item - The codec to use for the value that may be present.\n * @param config - A set of config for the codec.\n */\nexport function getNullableCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    item: FixedSizeCodec<TFrom, TTo, TSize>,\n    config: NullableCodecConfig<NumberCodec> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeCodec<TFrom | null, TTo | null, TSize>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: NullableCodecConfig<FixedSizeNumberCodec> & { noneValue: 'zeroes' },\n): FixedSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: NullableCodecConfig<NumberCodec> & { noneValue: 'zeroes' },\n): VariableSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: NullableCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: NullableCodecConfig<NumberCodec> = {},\n): Codec<TFrom | null, TTo | null> {\n    type ConfigCast = NullableCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array };\n    return combineCodec(\n        getNullableEncoder<TFrom>(item, config as ConfigCast),\n        getNullableDecoder<TTo>(item, config as ConfigCast),\n    );\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { ArrayLikeCodecSize, getArrayDecoder, getArrayEncoder } from './array';\n\n/** Defines the config for set codecs. */\nexport type SetCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size of the set.\n     * @defaultValue u32 prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Encodes an set of items.\n *\n * @param item - The encoder to use for the set's items.\n * @param config - A set of config for the encoder.\n */\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<Set<TFrom>, 0>;\nexport function getSetEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<Set<TFrom>>;\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: SetCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<Set<TFrom>>;\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> = {},\n): Encoder<Set<TFrom>> {\n    return transformEncoder(getArrayEncoder(item, config as object), (set: Set<TFrom>): TFrom[] => [...set]);\n}\n\n/**\n * Decodes an set of items.\n *\n * @param item - The encoder to use for the set's items.\n * @param config - A set of config for the encoder.\n */\nexport function getSetDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: SetCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<Set<TTo>, 0>;\nexport function getSetDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: SetCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<Set<TTo>>;\nexport function getSetDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: SetCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<Set<TTo>>;\nexport function getSetDecoder<TTo>(item: Decoder<TTo>, config: SetCodecConfig<NumberDecoder> = {}): Decoder<Set<TTo>> {\n    return transformDecoder(getArrayDecoder(item, config as object), (entries: TTo[]): Set<TTo> => new Set(entries));\n}\n\n/**\n * Creates a codec for an set of items.\n *\n * @param item - The codec to use for the set's items.\n * @param config - A set of config for the codec.\n */\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<Set<TFrom>, Set<TTo>, 0>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<Set<TFrom>, Set<TTo>>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: SetCodecConfig<NumberCodec>,\n): VariableSizeCodec<Set<TFrom>, Set<TTo>>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> = {},\n): Codec<Set<TFrom>, Set<TTo>> {\n    return combineCodec(getSetEncoder(item, config as object), getSetDecoder(item, config as object));\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { DrainOuterGeneric, getFixedSize, getMaxSize, sumCodecSizes } from './utils';\n\ntype Fields<T> = readonly (readonly [string, T])[];\ntype ArrayIndices<T extends readonly unknown[]> = Exclude<Partial<T>['length'], T['length']> & number;\n\ntype GetEncoderTypeFromFields<TFields extends Fields<Encoder<any>>> = DrainOuterGeneric<{\n    [I in ArrayIndices<TFields> as TFields[I][0]]: TFields[I][1] extends Encoder<infer TFrom> ? TFrom : never;\n}>;\n\ntype GetDecoderTypeFromFields<TFields extends Fields<Decoder<any>>> = DrainOuterGeneric<{\n    [I in ArrayIndices<TFields> as TFields[I][0]]: TFields[I][1] extends Decoder<infer TTo> ? TTo : never;\n}>;\n\n/**\n * Creates a encoder for a custom object.\n *\n * @param fields - The name and encoder of each field.\n */\nexport function getStructEncoder<const TFields extends Fields<FixedSizeEncoder<any>>>(\n    fields: TFields,\n): FixedSizeEncoder<GetEncoderTypeFromFields<TFields>>;\nexport function getStructEncoder<const TFields extends Fields<Encoder<any>>>(\n    fields: TFields,\n): VariableSizeEncoder<GetEncoderTypeFromFields<TFields>>;\nexport function getStructEncoder<const TFields extends Fields<Encoder<any>>>(\n    fields: TFields,\n): Encoder<GetEncoderTypeFromFields<TFields>> {\n    type TFrom = GetEncoderTypeFromFields<TFields>;\n    const fieldCodecs = fields.map(([, codec]) => codec);\n    const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n    const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize === null\n            ? {\n                  getSizeFromValue: (value: TFrom) =>\n                      fields\n                          .map(([key, codec]) => getEncodedSize(value[key as keyof TFrom], codec))\n                          .reduce((all, one) => all + one, 0),\n                  maxSize,\n              }\n            : { fixedSize }),\n        write: (struct: TFrom, bytes, offset) => {\n            fields.forEach(([key, codec]) => {\n                offset = codec.write(struct[key as keyof TFrom], bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Creates a decoder for a custom object.\n *\n * @param fields - The name and decoder of each field.\n */\nexport function getStructDecoder<const TFields extends Fields<FixedSizeDecoder<any>>>(\n    fields: TFields,\n): FixedSizeDecoder<GetDecoderTypeFromFields<TFields>>;\nexport function getStructDecoder<const TFields extends Fields<Decoder<any>>>(\n    fields: TFields,\n): VariableSizeDecoder<GetDecoderTypeFromFields<TFields>>;\nexport function getStructDecoder<const TFields extends Fields<Decoder<any>>>(\n    fields: TFields,\n): Decoder<GetDecoderTypeFromFields<TFields>> {\n    type TTo = GetDecoderTypeFromFields<TFields>;\n    const fieldCodecs = fields.map(([, codec]) => codec);\n    const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n    const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize === null ? { maxSize } : { fixedSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const struct = {} as TTo;\n            fields.forEach(([key, codec]) => {\n                const [value, newOffset] = codec.read(bytes, offset);\n                offset = newOffset;\n                struct[key as keyof TTo] = value;\n            });\n            return [struct, offset];\n        },\n    });\n}\n\n/**\n * Creates a codec for a custom object.\n *\n * @param fields - The name and codec of each field.\n */\nexport function getStructCodec<const TFields extends Fields<FixedSizeCodec<any>>>(\n    fields: TFields,\n): FixedSizeCodec<\n    GetEncoderTypeFromFields<TFields>,\n    GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>\n>;\nexport function getStructCodec<const TFields extends Fields<Codec<any>>>(\n    fields: TFields,\n): VariableSizeCodec<\n    GetEncoderTypeFromFields<TFields>,\n    GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>\n>;\nexport function getStructCodec<const TFields extends Fields<Codec<any>>>(\n    fields: TFields,\n): Codec<GetEncoderTypeFromFields<TFields>, GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>> {\n    return combineCodec(\n        getStructEncoder(fields),\n        getStructDecoder(fields) as Decoder<GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>>,\n    );\n}\n","import {\n    combineCodec,\n    Decoder,\n    Encoder,\n    fixDecoderSize,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    fixEncoderSize,\n    transformEncoder,\n} from '@solana/codecs-core';\nimport { getBase58Decoder, getBase58Encoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH,\n    SolanaError,\n} from '@solana/errors';\n\nexport type Blockhash = string & { readonly __brand: unique symbol };\n\nlet memoizedBase58Encoder: Encoder<string> | undefined;\nlet memoizedBase58Decoder: Decoder<string> | undefined;\n\nfunction getMemoizedBase58Encoder(): Encoder<string> {\n    if (!memoizedBase58Encoder) memoizedBase58Encoder = getBase58Encoder();\n    return memoizedBase58Encoder;\n}\n\nfunction getMemoizedBase58Decoder(): Decoder<string> {\n    if (!memoizedBase58Decoder) memoizedBase58Decoder = getBase58Decoder();\n    return memoizedBase58Decoder;\n}\n\nexport function isBlockhash(putativeBlockhash: string): putativeBlockhash is Blockhash {\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest value (32 bytes of zeroes)\n        putativeBlockhash.length < 32 ||\n        // Highest value (32 bytes of 255)\n        putativeBlockhash.length > 44\n    ) {\n        return false;\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const base58Encoder = getMemoizedBase58Encoder();\n    const bytes = base58Encoder.encode(putativeBlockhash);\n    const numBytes = bytes.byteLength;\n    if (numBytes !== 32) {\n        return false;\n    }\n    return true;\n}\n\nexport function assertIsBlockhash(putativeBlockhash: string): asserts putativeBlockhash is Blockhash {\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest value (32 bytes of zeroes)\n        putativeBlockhash.length < 32 ||\n        // Highest value (32 bytes of 255)\n        putativeBlockhash.length > 44\n    ) {\n        throw new SolanaError(SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE, {\n            actualLength: putativeBlockhash.length,\n        });\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const base58Encoder = getMemoizedBase58Encoder();\n    const bytes = base58Encoder.encode(putativeBlockhash);\n    const numBytes = bytes.byteLength;\n    if (numBytes !== 32) {\n        throw new SolanaError(SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH, {\n            actualLength: numBytes,\n        });\n    }\n}\n\nexport function blockhash(putativeBlockhash: string): Blockhash {\n    assertIsBlockhash(putativeBlockhash);\n    return putativeBlockhash;\n}\n\nexport function getBlockhashEncoder(): FixedSizeEncoder<Blockhash, 32> {\n    return transformEncoder(fixEncoderSize(getMemoizedBase58Encoder(), 32), putativeBlockhash =>\n        blockhash(putativeBlockhash),\n    );\n}\n\nexport function getBlockhashDecoder(): FixedSizeDecoder<Blockhash, 32> {\n    return fixDecoderSize(getMemoizedBase58Decoder(), 32) as FixedSizeDecoder<Blockhash, 32>;\n}\n\nexport function getBlockhashCodec(): FixedSizeCodec<Blockhash, Blockhash, 32> {\n    return combineCodec(getBlockhashEncoder(), getBlockhashDecoder());\n}\n\nexport function getBlockhashComparator(): (x: string, y: string) => number {\n    return new Intl.Collator('en', {\n        caseFirst: 'lower',\n        ignorePunctuation: false,\n        localeMatcher: 'best fit',\n        numeric: false,\n        sensitivity: 'variant',\n        usage: 'sort',\n    }).compare;\n}\n","export type MainnetUrl = string & { '~cluster': 'mainnet' };\nexport type DevnetUrl = string & { '~cluster': 'devnet' };\nexport type TestnetUrl = string & { '~cluster': 'testnet' };\nexport type ClusterUrl = DevnetUrl | MainnetUrl | TestnetUrl | string;\n\nexport function mainnet(putativeString: string): MainnetUrl {\n    return putativeString as MainnetUrl;\n}\nexport function devnet(putativeString: string): DevnetUrl {\n    return putativeString as DevnetUrl;\n}\nexport function testnet(putativeString: string): TestnetUrl {\n    return putativeString as TestnetUrl;\n}\n","import { SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, SolanaError } from '@solana/errors';\n\nexport type Commitment = 'confirmed' | 'finalized' | 'processed';\n\nfunction getCommitmentScore(commitment: Commitment): number {\n    switch (commitment) {\n        case 'finalized':\n            return 2;\n        case 'confirmed':\n            return 1;\n        case 'processed':\n            return 0;\n        default:\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, {\n                unexpectedValue: commitment satisfies never,\n            });\n    }\n}\n\nexport function commitmentComparator(a: Commitment, b: Commitment): -1 | 0 | 1 {\n    if (a === b) {\n        return 0;\n    }\n    return getCommitmentScore(a) < getCommitmentScore(b) ? -1 : 1;\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n} from '@solana/codecs-core';\nimport { getU64Decoder, getU64Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\nexport type Lamports = bigint & { readonly __brand: unique symbol };\n\n// Largest possible value to be represented by a u64\nconst maxU64Value = 18446744073709551615n; // 2n ** 64n - 1n\n\nlet memoizedU64Encoder: FixedSizeEncoder<bigint | number, 8> | undefined;\nlet memoizedU64Decoder: FixedSizeDecoder<bigint, 8> | undefined;\n\nfunction getMemoizedU64Encoder(): FixedSizeEncoder<bigint | number, 8> {\n    if (!memoizedU64Encoder) memoizedU64Encoder = getU64Encoder();\n    return memoizedU64Encoder;\n}\n\nfunction getMemoizedU64Decoder(): FixedSizeDecoder<bigint, 8> {\n    if (!memoizedU64Decoder) memoizedU64Decoder = getU64Decoder();\n    return memoizedU64Decoder;\n}\n\nexport function isLamports(putativeLamports: bigint): putativeLamports is Lamports {\n    return putativeLamports >= 0 && putativeLamports <= maxU64Value;\n}\n\nexport function assertIsLamports(putativeLamports: bigint): asserts putativeLamports is Lamports {\n    if (putativeLamports < 0 || putativeLamports > maxU64Value) {\n        throw new SolanaError(SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE);\n    }\n}\n\nexport function lamports(putativeLamports: bigint): Lamports {\n    assertIsLamports(putativeLamports);\n    return putativeLamports;\n}\n\ntype ExtractAdditionalProps<T, U> = Omit<T, keyof U>;\n\nexport function getDefaultLamportsEncoder(): FixedSizeEncoder<Lamports, 8> {\n    return getLamportsEncoder(getMemoizedU64Encoder());\n}\n\nexport function getLamportsEncoder<TEncoder extends NumberEncoder>(\n    innerEncoder: TEncoder,\n): Encoder<Lamports> & ExtractAdditionalProps<TEncoder, NumberEncoder> {\n    return innerEncoder;\n}\n\nexport function getDefaultLamportsDecoder(): FixedSizeDecoder<Lamports, 8> {\n    return getLamportsDecoder(getMemoizedU64Decoder());\n}\n\nexport function getLamportsDecoder<TDecoder extends NumberDecoder>(\n    innerDecoder: TDecoder,\n): Decoder<Lamports> & ExtractAdditionalProps<TDecoder, NumberDecoder> {\n    return transformDecoder<bigint | number, Lamports>(innerDecoder, value =>\n        lamports(typeof value === 'bigint' ? value : BigInt(value)),\n    ) as Decoder<Lamports> & ExtractAdditionalProps<TDecoder, NumberDecoder>;\n}\n\nexport function getDefaultLamportsCodec(): FixedSizeCodec<Lamports, Lamports, 8> {\n    return combineCodec(getDefaultLamportsEncoder(), getDefaultLamportsDecoder());\n}\n\nexport function getLamportsCodec<TCodec extends NumberCodec>(\n    innerCodec: TCodec,\n): Codec<Lamports, Lamports> & ExtractAdditionalProps<TCodec, NumberCodec> {\n    return combineCodec(getLamportsEncoder(innerCodec), getLamportsDecoder(innerCodec)) as Codec<Lamports, Lamports> &\n        ExtractAdditionalProps<TCodec, NumberCodec>;\n}\n","import { SOLANA_ERROR__MALFORMED_BIGINT_STRING, SolanaError } from '@solana/errors';\n\nexport type StringifiedBigInt = string & { readonly __brand: unique symbol };\n\nexport function isStringifiedBigInt(putativeBigInt: string): putativeBigInt is StringifiedBigInt {\n    try {\n        BigInt(putativeBigInt);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\nexport function assertIsStringifiedBigInt(putativeBigInt: string): asserts putativeBigInt is StringifiedBigInt {\n    try {\n        BigInt(putativeBigInt);\n    } catch {\n        throw new SolanaError(SOLANA_ERROR__MALFORMED_BIGINT_STRING, {\n            value: putativeBigInt,\n        });\n    }\n}\n\nexport function stringifiedBigInt(putativeBigInt: string): StringifiedBigInt {\n    assertIsStringifiedBigInt(putativeBigInt);\n    return putativeBigInt;\n}\n","import { SOLANA_ERROR__MALFORMED_NUMBER_STRING, SolanaError } from '@solana/errors';\n\nexport type StringifiedNumber = string & { readonly __brand: unique symbol };\n\nexport function isStringifiedNumber(putativeNumber: string): putativeNumber is StringifiedNumber {\n    return !Number.isNaN(Number(putativeNumber));\n}\n\nexport function assertIsStringifiedNumber(putativeNumber: string): asserts putativeNumber is StringifiedNumber {\n    if (Number.isNaN(Number(putativeNumber))) {\n        throw new SolanaError(SOLANA_ERROR__MALFORMED_NUMBER_STRING, {\n            value: putativeNumber,\n        });\n    }\n}\n\nexport function stringifiedNumber(putativeNumber: string): StringifiedNumber {\n    assertIsStringifiedNumber(putativeNumber);\n    return putativeNumber;\n}\n","import { SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\nexport type UnixTimestamp = bigint & { readonly __brand: unique symbol };\n\n// Largest possible value to be represented by an i64\nconst maxI64Value = 9223372036854775807n; // 2n ** 63n - 1n\nconst minI64Value = -9223372036854775808n; // -(2n ** 63n)\n\nexport function isUnixTimestamp(putativeTimestamp: bigint): putativeTimestamp is UnixTimestamp {\n    return putativeTimestamp >= minI64Value && putativeTimestamp <= maxI64Value;\n}\n\nexport function assertIsUnixTimestamp(putativeTimestamp: bigint): asserts putativeTimestamp is UnixTimestamp {\n    if (putativeTimestamp < minI64Value || putativeTimestamp > maxI64Value) {\n        throw new SolanaError(SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE, {\n            value: putativeTimestamp,\n        });\n    }\n}\n\nexport function unixTimestamp(putativeTimestamp: bigint): UnixTimestamp {\n    assertIsUnixTimestamp(putativeTimestamp);\n    return putativeTimestamp;\n}\n","import {\n    type FetchAccountConfig,\n    fetchEncodedAccount,\n    fetchJsonParsedAccount,\n    type MaybeAccount,\n    type MaybeEncodedAccount,\n} from '@solana/accounts';\nimport type { Address } from '@solana/addresses';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { JsonParsedSysvarAccount } from '@solana/rpc-parsed-types';\nimport type { Rpc } from '@solana/rpc-spec';\n\nexport const SYSVAR_CLOCK_ADDRESS =\n    'SysvarC1ock11111111111111111111111111111111' as Address<'SysvarC1ock11111111111111111111111111111111'>;\nexport const SYSVAR_EPOCH_REWARDS_ADDRESS =\n    'SysvarEpochRewards1111111111111111111111111' as Address<'SysvarEpochRewards1111111111111111111111111'>;\nexport const SYSVAR_EPOCH_SCHEDULE_ADDRESS =\n    'SysvarEpochSchedu1e111111111111111111111111' as Address<'SysvarEpochSchedu1e111111111111111111111111'>;\nexport const SYSVAR_FEES_ADDRESS =\n    'SysvarFees111111111111111111111111111111111' as Address<'SysvarFees111111111111111111111111111111111'>;\nexport const SYSVAR_INSTRUCTIONS_ADDRESS =\n    'Sysvar1nstructions1111111111111111111111111' as Address<'Sysvar1nstructions1111111111111111111111111'>;\nexport const SYSVAR_LAST_RESTART_SLOT_ADDRESS =\n    'SysvarLastRestartS1ot1111111111111111111111' as Address<'SysvarLastRestartS1ot1111111111111111111111'>;\nexport const SYSVAR_RECENT_BLOCKHASHES_ADDRESS =\n    'SysvarRecentB1ockHashes11111111111111111111' as Address<'SysvarRecentB1ockHashes11111111111111111111'>;\nexport const SYSVAR_RENT_ADDRESS =\n    'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\nexport const SYSVAR_SLOT_HASHES_ADDRESS =\n    'SysvarS1otHashes111111111111111111111111111' as Address<'SysvarS1otHashes111111111111111111111111111'>;\nexport const SYSVAR_SLOT_HISTORY_ADDRESS =\n    'SysvarS1otHistory11111111111111111111111111' as Address<'SysvarS1otHistory11111111111111111111111111'>;\nexport const SYSVAR_STAKE_HISTORY_ADDRESS =\n    'SysvarStakeHistory1111111111111111111111111' as Address<'SysvarStakeHistory1111111111111111111111111'>;\n\ntype SysvarAddress =\n    | typeof SYSVAR_CLOCK_ADDRESS\n    | typeof SYSVAR_EPOCH_REWARDS_ADDRESS\n    | typeof SYSVAR_EPOCH_SCHEDULE_ADDRESS\n    | typeof SYSVAR_FEES_ADDRESS\n    | typeof SYSVAR_INSTRUCTIONS_ADDRESS\n    | typeof SYSVAR_LAST_RESTART_SLOT_ADDRESS\n    | typeof SYSVAR_RECENT_BLOCKHASHES_ADDRESS\n    | typeof SYSVAR_RENT_ADDRESS\n    | typeof SYSVAR_SLOT_HASHES_ADDRESS\n    | typeof SYSVAR_SLOT_HISTORY_ADDRESS\n    | typeof SYSVAR_STAKE_HISTORY_ADDRESS;\n\n/**\n * Fetch an encoded sysvar account.\n *\n * Sysvars are special accounts that contain dynamically-updated data about the\n * network cluster, the blockchain history, and the executing transaction.\n */\nexport async function fetchEncodedSysvarAccount<TAddress extends SysvarAddress>(\n    rpc: Rpc<GetAccountInfoApi>,\n    address: TAddress,\n    config?: FetchAccountConfig,\n): Promise<MaybeEncodedAccount<TAddress>> {\n    return await fetchEncodedAccount<TAddress>(rpc, address, config);\n}\n\n/**\n * Fetch a JSON-parsed sysvar account.\n *\n * Sysvars are special accounts that contain dynamically-updated data about the\n * network cluster, the blockchain history, and the executing transaction.\n */\nexport async function fetchJsonParsedSysvarAccount<TAddress extends SysvarAddress>(\n    rpc: Rpc<GetAccountInfoApi>,\n    address: TAddress,\n    config?: FetchAccountConfig,\n): Promise<MaybeAccount<JsonParsedSysvarAccount, TAddress> | MaybeEncodedAccount<TAddress>> {\n    return await fetchJsonParsedAccount<JsonParsedSysvarAccount, TAddress>(rpc, address, config);\n}\n","import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    type FixedSizeCodec,\n    type FixedSizeDecoder,\n    type FixedSizeEncoder,\n    getI64Decoder,\n    getI64Encoder,\n    getStructDecoder,\n    getStructEncoder,\n    getU64Decoder,\n    getU64Encoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport type { Epoch, Slot, UnixTimestamp } from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_CLOCK_ADDRESS } from './sysvar';\n\ntype SysvarClockSize = 40;\n\n/**\n * The `Clock` sysvar.\n *\n * Information about the network’s clock, ticks, slots, etc.\n */\nexport type SysvarClock = Readonly<{\n    epoch: Epoch;\n    epochStartTimestamp: UnixTimestamp;\n    leaderScheduleEpoch: Epoch;\n    slot: Slot;\n    unixTimestamp: UnixTimestamp;\n}>;\n\nexport function getSysvarClockEncoder(): FixedSizeEncoder<SysvarClock, SysvarClockSize> {\n    return getStructEncoder([\n        ['slot', getU64Encoder()],\n        ['epochStartTimestamp', getI64Encoder()],\n        ['epoch', getU64Encoder()],\n        ['leaderScheduleEpoch', getU64Encoder()],\n        ['unixTimestamp', getI64Encoder()],\n    ]) as FixedSizeEncoder<SysvarClock, SysvarClockSize>;\n}\n\nexport function getSysvarClockDecoder(): FixedSizeDecoder<SysvarClock, SysvarClockSize> {\n    return getStructDecoder([\n        ['slot', getU64Decoder()],\n        ['epochStartTimestamp', getI64Decoder()],\n        ['epoch', getU64Decoder()],\n        ['leaderScheduleEpoch', getU64Decoder()],\n        ['unixTimestamp', getI64Decoder()],\n    ]) as FixedSizeDecoder<SysvarClock, SysvarClockSize>;\n}\n\nexport function getSysvarClockCodec(): FixedSizeCodec<SysvarClock, SysvarClock, SysvarClockSize> {\n    return combineCodec(getSysvarClockEncoder(), getSysvarClockDecoder());\n}\n\n/**\n * Fetch the `Clock` sysvar.\n *\n * Information about the network’s clock, ticks, slots, etc.\n */\nexport async function fetchSysvarClock(rpc: Rpc<GetAccountInfoApi>, config?: FetchAccountConfig): Promise<SysvarClock> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_CLOCK_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarClockDecoder());\n    return decoded.data;\n}\n","import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    type FixedSizeCodec,\n    type FixedSizeDecoder,\n    type FixedSizeEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getU64Decoder,\n    getU64Encoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_EPOCH_REWARDS_ADDRESS } from './sysvar';\n\ntype SysvarEpochRewardsSize = 24;\n\n/**\n * The `EpochRewards` sysvar.\n *\n * Tracks the progress of epoch rewards distribution. It includes:\n * - Total rewards for the current epoch, in lamports.\n * - Rewards for the current epoch distributed so far, in lamports.\n * - Distribution completed block height, i.e. distribution of all staking rewards for the current\n *   epoch will be completed at this block height.\n *\n * Note that `EpochRewards` only lasts for a handful of blocks at the start of\n * an epoch. When all rewards have been distributed, the sysvar is deleted.\n * See https://github.com/solana-labs/solana/blob/e0203f22dc83cb792fa97f91dbe6e924cbd08af1/docs/src/runtime/sysvars.md?plain=1#L155-L168\n */\nexport type SysvarEpochRewards = Readonly<{\n    distributedRewards: bigint;\n    distributionCompleteBlockHeight: bigint;\n    totalRewards: bigint;\n}>;\n\nexport function getSysvarEpochRewardsEncoder(): FixedSizeEncoder<SysvarEpochRewards, SysvarEpochRewardsSize> {\n    return getStructEncoder([\n        ['distributionCompleteBlockHeight', getU64Encoder()],\n        ['distributedRewards', getU64Encoder()],\n        ['totalRewards', getU64Encoder()],\n    ]) as FixedSizeEncoder<SysvarEpochRewards, SysvarEpochRewardsSize>;\n}\n\nexport function getSysvarEpochRewardsDecoder(): FixedSizeDecoder<SysvarEpochRewards, SysvarEpochRewardsSize> {\n    return getStructDecoder([\n        ['distributionCompleteBlockHeight', getU64Decoder()],\n        ['distributedRewards', getU64Decoder()],\n        ['totalRewards', getU64Decoder()],\n    ]) as FixedSizeDecoder<SysvarEpochRewards, SysvarEpochRewardsSize>;\n}\n\nexport function getSysvarEpochRewardsCodec(): FixedSizeCodec<\n    SysvarEpochRewards,\n    SysvarEpochRewards,\n    SysvarEpochRewardsSize\n> {\n    return combineCodec(getSysvarEpochRewardsEncoder(), getSysvarEpochRewardsDecoder());\n}\n\n/**\n * Fetch the `EpochRewards` sysvar.\n *\n * Tracks the progress of epoch rewards distribution. It includes:\n * - Total rewards for the current epoch, in lamports.\n * - Rewards for the current epoch distributed so far, in lamports.\n * - Distribution completed block height, i.e. distribution of all staking rewards for the current\n *   epoch will be completed at this block height.\n *\n * Note that `EpochRewards` only lasts for a handful of blocks at the start of\n * an epoch. When all rewards have been distributed, the sysvar is deleted.\n * See https://github.com/solana-labs/solana/blob/e0203f22dc83cb792fa97f91dbe6e924cbd08af1/docs/src/runtime/sysvars.md?plain=1#L155-L168\n */\nexport async function fetchSysvarEpochRewards(\n    rpc: Rpc<GetAccountInfoApi>,\n    config?: FetchAccountConfig,\n): Promise<SysvarEpochRewards> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_EPOCH_REWARDS_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarEpochRewardsDecoder());\n    return decoded.data;\n}\n","import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    type FixedSizeCodec,\n    type FixedSizeDecoder,\n    type FixedSizeEncoder,\n    getBooleanDecoder,\n    getBooleanEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getU64Decoder,\n    getU64Encoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport type { Epoch, Slot } from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_EPOCH_SCHEDULE_ADDRESS } from './sysvar';\n\ntype SysvarEpochScheduleSize = 33;\n\n/**\n * The `EpochSchedule` sysvar.\n *\n * Information about epoch duration.\n */\nexport type SysvarEpochSchedule = Readonly<{\n    firstNormalEpoch: Epoch;\n    firstNormalSlot: Slot;\n    leaderScheduleSlotOffset: bigint;\n    slotsPerEpoch: bigint;\n    warmup: boolean;\n}>;\n\nexport function getSysvarEpochScheduleEncoder(): FixedSizeEncoder<SysvarEpochSchedule, SysvarEpochScheduleSize> {\n    return getStructEncoder([\n        ['slotsPerEpoch', getU64Encoder()],\n        ['leaderScheduleSlotOffset', getU64Encoder()],\n        ['warmup', getBooleanEncoder()],\n        ['firstNormalEpoch', getU64Encoder()],\n        ['firstNormalSlot', getU64Encoder()],\n    ]) as FixedSizeEncoder<SysvarEpochSchedule, SysvarEpochScheduleSize>;\n}\n\nexport function getSysvarEpochScheduleDecoder(): FixedSizeDecoder<SysvarEpochSchedule, SysvarEpochScheduleSize> {\n    return getStructDecoder([\n        ['slotsPerEpoch', getU64Decoder()],\n        ['leaderScheduleSlotOffset', getU64Decoder()],\n        ['warmup', getBooleanDecoder()],\n        ['firstNormalEpoch', getU64Decoder()],\n        ['firstNormalSlot', getU64Decoder()],\n    ]) as FixedSizeDecoder<SysvarEpochSchedule, SysvarEpochScheduleSize>;\n}\n\nexport function getSysvarEpochScheduleCodec(): FixedSizeCodec<\n    SysvarEpochSchedule,\n    SysvarEpochSchedule,\n    SysvarEpochScheduleSize\n> {\n    return combineCodec(getSysvarEpochScheduleEncoder(), getSysvarEpochScheduleDecoder());\n}\n\n/**\n * Fetch the `EpochSchedule` sysvar.\n *\n * Information about epoch duration.\n */\nexport async function fetchSysvarEpochSchedule(\n    rpc: Rpc<GetAccountInfoApi>,\n    config?: FetchAccountConfig,\n): Promise<SysvarEpochSchedule> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_EPOCH_SCHEDULE_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarEpochScheduleDecoder());\n    return decoded.data;\n}\n","import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    type FixedSizeCodec,\n    type FixedSizeDecoder,\n    type FixedSizeEncoder,\n    getStructDecoder,\n    getStructEncoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport { getDefaultLamportsDecoder, getDefaultLamportsEncoder, Lamports } from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_FEES_ADDRESS } from './sysvar';\n\ntype FeeCalculator = Readonly<{\n    lamportsPerSignature: Lamports;\n}>;\n\ntype SysvarFeesSize = 8;\n\n/**\n * The `Fees` sysvar.\n *\n * Current cluster fees.\n */\nexport type SysvarFees = Readonly<{\n    feeCalculator: FeeCalculator;\n}>;\n\nexport function getSysvarFeesEncoder(): FixedSizeEncoder<SysvarFees, SysvarFeesSize> {\n    return getStructEncoder([\n        ['feeCalculator', getStructEncoder([['lamportsPerSignature', getDefaultLamportsEncoder()]])],\n    ]) as FixedSizeEncoder<SysvarFees, SysvarFeesSize>;\n}\n\nexport function getSysvarFeesDecoder(): FixedSizeDecoder<SysvarFees, SysvarFeesSize> {\n    return getStructDecoder([\n        ['feeCalculator', getStructDecoder([['lamportsPerSignature', getDefaultLamportsDecoder()]])],\n    ]) as FixedSizeDecoder<SysvarFees, SysvarFeesSize>;\n}\n\nexport function getSysvarFeesCodec(): FixedSizeCodec<SysvarFees, SysvarFees, SysvarFeesSize> {\n    return combineCodec(getSysvarFeesEncoder(), getSysvarFeesDecoder());\n}\n\n/**\n * Fetch the `Fees` sysvar.\n *\n * Current cluster fees.\n */\nexport async function fetchSysvarFees(rpc: Rpc<GetAccountInfoApi>, config?: FetchAccountConfig): Promise<SysvarFees> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_FEES_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarFeesDecoder());\n    return decoded.data;\n}\n","import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    type FixedSizeCodec,\n    type FixedSizeDecoder,\n    type FixedSizeEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getU64Decoder,\n    getU64Encoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport type { Slot } from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_LAST_RESTART_SLOT_ADDRESS } from './sysvar';\n\ntype SysvarLastRestartSlotSize = 8;\n\n/**\n * The `LastRestartSlot` sysvar.\n *\n * Information about the last restart slot (hard fork).\n *\n * The `LastRestartSlot` sysvar provides access to the last restart slot kept in the\n * bank fork for the slot on the fork that executes the current transaction.\n * In case there was no fork it returns `0`.\n */\nexport type SysvarLastRestartSlot = Readonly<{\n    lastRestartSlot: Slot;\n}>;\n\nexport function getSysvarLastRestartSlotEncoder(): FixedSizeEncoder<SysvarLastRestartSlot, SysvarLastRestartSlotSize> {\n    return getStructEncoder([['lastRestartSlot', getU64Encoder()]]) as FixedSizeEncoder<\n        SysvarLastRestartSlot,\n        SysvarLastRestartSlotSize\n    >;\n}\n\nexport function getSysvarLastRestartSlotDecoder(): FixedSizeDecoder<SysvarLastRestartSlot, SysvarLastRestartSlotSize> {\n    return getStructDecoder([['lastRestartSlot', getU64Decoder()]]) as FixedSizeDecoder<\n        SysvarLastRestartSlot,\n        SysvarLastRestartSlotSize\n    >;\n}\n\nexport function getSysvarLastRestartSlotCodec(): FixedSizeCodec<\n    SysvarLastRestartSlot,\n    SysvarLastRestartSlot,\n    SysvarLastRestartSlotSize\n> {\n    return combineCodec(getSysvarLastRestartSlotEncoder(), getSysvarLastRestartSlotDecoder());\n}\n\n/**\n * Fetch the `LastRestartSlot` sysvar.\n *\n * Information about the last restart slot (hard fork).\n *\n * The `LastRestartSlot` sysvar provides access to the last restart slot kept in the\n * bank fork for the slot on the fork that executes the current transaction.\n * In case there was no fork it returns `0`.\n */\nexport async function fetchSysvarLastRestartSlot(\n    rpc: Rpc<GetAccountInfoApi>,\n    config?: FetchAccountConfig,\n): Promise<SysvarLastRestartSlot> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_LAST_RESTART_SLOT_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarLastRestartSlotDecoder());\n    return decoded.data;\n}\n","import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    getArrayDecoder,\n    getArrayEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    type VariableSizeCodec,\n    type VariableSizeDecoder,\n    type VariableSizeEncoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport {\n    type Blockhash,\n    getBlockhashDecoder,\n    getBlockhashEncoder,\n    getDefaultLamportsDecoder,\n    getDefaultLamportsEncoder,\n    type Lamports,\n} from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_RECENT_BLOCKHASHES_ADDRESS } from './sysvar';\n\ntype FeeCalculator = Readonly<{\n    lamportsPerSignature: Lamports;\n}>;\ntype Entry = Readonly<{\n    blockhash: Blockhash;\n    feeCalculator: FeeCalculator;\n}>;\n\n/**\n * The `RecentBlockhashes` sysvar.\n *\n * Information about recent blocks and their fee calculators.\n */\nexport type SysvarRecentBlockhashes = Entry[];\n\nexport function getSysvarRecentBlockhashesEncoder(): VariableSizeEncoder<SysvarRecentBlockhashes> {\n    return getArrayEncoder(\n        getStructEncoder([\n            ['blockhash', getBlockhashEncoder()],\n            ['feeCalculator', getStructEncoder([['lamportsPerSignature', getDefaultLamportsEncoder()]])],\n        ]),\n    );\n}\n\nexport function getSysvarRecentBlockhashesDecoder(): VariableSizeDecoder<SysvarRecentBlockhashes> {\n    return getArrayDecoder(\n        getStructDecoder([\n            ['blockhash', getBlockhashDecoder()],\n            ['feeCalculator', getStructDecoder([['lamportsPerSignature', getDefaultLamportsDecoder()]])],\n        ]),\n    );\n}\n\nexport function getSysvarRecentBlockhashesCodec(): VariableSizeCodec<SysvarRecentBlockhashes> {\n    return combineCodec(getSysvarRecentBlockhashesEncoder(), getSysvarRecentBlockhashesDecoder());\n}\n\n/**\n * Fetch the `RecentBlockhashes` sysvar.\n *\n * Information about recent blocks and their fee calculators.\n */\nexport async function fetchSysvarRecentBlockhashes(\n    rpc: Rpc<GetAccountInfoApi>,\n    config?: FetchAccountConfig,\n): Promise<SysvarRecentBlockhashes> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_RECENT_BLOCKHASHES_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarRecentBlockhashesDecoder());\n    return decoded.data;\n}\n","import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    type FixedSizeCodec,\n    type FixedSizeDecoder,\n    type FixedSizeEncoder,\n    getF64Decoder,\n    getF64Encoder,\n    getStructDecoder,\n    getStructEncoder,\n    getU8Decoder,\n    getU8Encoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport { getDefaultLamportsDecoder, getDefaultLamportsEncoder, type Lamports } from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_RENT_ADDRESS } from './sysvar';\n\ntype SysvarRentSize = 17;\n\n/**\n * The `Rent` sysvar.\n *\n * Configuration for network rent.\n */\nexport type SysvarRent = Readonly<{\n    burnPercent: number;\n    exemptionThreshold: number;\n    lamportsPerByteYear: Lamports;\n}>;\n\nexport function getSysvarRentEncoder(): FixedSizeEncoder<SysvarRent, SysvarRentSize> {\n    return getStructEncoder([\n        ['lamportsPerByteYear', getDefaultLamportsEncoder()],\n        ['exemptionThreshold', getF64Encoder()],\n        ['burnPercent', getU8Encoder()],\n    ]) as FixedSizeEncoder<SysvarRent, SysvarRentSize>;\n}\n\nexport function getSysvarRentDecoder(): FixedSizeDecoder<SysvarRent, SysvarRentSize> {\n    return getStructDecoder([\n        ['lamportsPerByteYear', getDefaultLamportsDecoder()],\n        ['exemptionThreshold', getF64Decoder()],\n        ['burnPercent', getU8Decoder()],\n    ]) as FixedSizeDecoder<SysvarRent, SysvarRentSize>;\n}\n\nexport function getSysvarRentCodec(): FixedSizeCodec<SysvarRent, SysvarRent, SysvarRentSize> {\n    return combineCodec(getSysvarRentEncoder(), getSysvarRentDecoder());\n}\n\n/**\n * Fetch the `Rent` sysvar.\n *\n * Configuration for network rent.\n */\nexport async function fetchSysvarRent(rpc: Rpc<GetAccountInfoApi>, config?: FetchAccountConfig): Promise<SysvarRent> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_RENT_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarRentDecoder());\n    return decoded.data;\n}\n","import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    getArrayDecoder,\n    getArrayEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getU64Decoder,\n    getU64Encoder,\n    type VariableSizeCodec,\n    type VariableSizeDecoder,\n    type VariableSizeEncoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport { type Blockhash, getBlockhashDecoder, getBlockhashEncoder, type Slot } from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_SLOT_HASHES_ADDRESS } from './sysvar';\n\ntype Entry = Readonly<{\n    hash: Blockhash;\n    slot: Slot;\n}>;\n\n/**\n * The `SlotHashes` sysvar.\n *\n * The most recent hashes of a slot's parent banks.\n */\nexport type SysvarSlotHashes = Entry[];\n\nexport function getSysvarSlotHashesEncoder(): VariableSizeEncoder<SysvarSlotHashes> {\n    return getArrayEncoder(\n        getStructEncoder([\n            ['slot', getU64Encoder()],\n            ['hash', getBlockhashEncoder()],\n        ]),\n    );\n}\n\nexport function getSysvarSlotHashesDecoder(): VariableSizeDecoder<SysvarSlotHashes> {\n    return getArrayDecoder(\n        getStructDecoder([\n            ['slot', getU64Decoder()],\n            ['hash', getBlockhashDecoder()],\n        ]),\n    );\n}\n\nexport function getSysvarSlotHashesCodec(): VariableSizeCodec<SysvarSlotHashes> {\n    return combineCodec(getSysvarSlotHashesEncoder(), getSysvarSlotHashesDecoder());\n}\n\n/**\n * Fetch the `SlotHashes` sysvar.\n *\n * The most recent hashes of a slot's parent banks.\n */\nexport async function fetchSysvarSlotHashes(\n    rpc: Rpc<GetAccountInfoApi>,\n    config?: FetchAccountConfig,\n): Promise<SysvarSlotHashes> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_SLOT_HASHES_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarSlotHashesDecoder());\n    return decoded.data;\n}\n","import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    type FixedSizeCodec,\n    type FixedSizeDecoder,\n    type FixedSizeEncoder,\n    getArrayCodec,\n    getU64Codec,\n    getU64Decoder,\n    getU64Encoder,\n    ReadonlyUint8Array,\n} from '@solana/codecs';\nimport {\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS,\n    SolanaError,\n} from '@solana/errors';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport type { Slot } from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_SLOT_HISTORY_ADDRESS } from './sysvar';\n\nconst BITVEC_DISCRIMINATOR = 1;\n// Max number of bits in the bitvector.\n// The Solana SDK defines a constant `MAX_ENTRIES` representing the maximum\n// number of bits that can be represented by the bitvector in the `SlotHistory`\n// sysvar. This value is 1024 * 1024 = 1_048_576.\n// See https://github.com/solana-labs/solana/blob/e0203f22dc83cb792fa97f91dbe6e924cbd08af1/sdk/program/src/slot_history.rs#L43\nconst BITVEC_NUM_BITS = 1024 * 1024;\n// The length of the bitvector in blocks.\n// At 64 bits per block, this is 1024 * 1024 / 64 = 16_384.\nconst BITVEC_LENGTH = BITVEC_NUM_BITS / 64;\n\nconst SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE =\n    1 + // Discriminator\n    8 + // bitvector length (u64)\n    BITVEC_LENGTH * 8 +\n    8 + // Number of bits (u64)\n    8; // Next slot (u64)\n\nlet memoizedU64Encoder: FixedSizeEncoder<bigint, 8> | undefined;\nlet memoizedU64Decoder: FixedSizeDecoder<bigint, 8> | undefined;\nlet memoizedU64ArrayEncoder: FixedSizeEncoder<bigint[]> | undefined;\nlet memoizedU64ArrayDecoder: FixedSizeDecoder<bigint[]> | undefined;\n\nfunction getMemoizedU64Encoder(): FixedSizeEncoder<bigint, 8> {\n    if (!memoizedU64Encoder) memoizedU64Encoder = getU64Encoder();\n    return memoizedU64Encoder;\n}\nfunction getMemoizedU64Decoder(): FixedSizeDecoder<bigint, 8> {\n    if (!memoizedU64Decoder) memoizedU64Decoder = getU64Decoder();\n    return memoizedU64Decoder;\n}\nfunction getMemoizedU64ArrayEncoder(): FixedSizeEncoder<bigint[], typeof BITVEC_LENGTH> {\n    if (!memoizedU64ArrayEncoder) memoizedU64ArrayEncoder = getArrayCodec(getU64Codec(), { size: BITVEC_LENGTH });\n    return memoizedU64ArrayEncoder;\n}\nfunction getMemoizedU64ArrayDecoder(): FixedSizeDecoder<bigint[], typeof BITVEC_LENGTH> {\n    if (!memoizedU64ArrayDecoder) memoizedU64ArrayDecoder = getArrayCodec(getU64Codec(), { size: BITVEC_LENGTH });\n    return memoizedU64ArrayDecoder;\n}\n\ntype SysvarSlotHistorySize = typeof SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE;\n\n/**\n * The `SlotHistory` sysvar.\n *\n * A bitvector of slots present over the last epoch.\n */\nexport type SysvarSlotHistory = {\n    bits: bigint[];\n    nextSlot: Slot;\n};\n\nexport function getSysvarSlotHistoryEncoder(): FixedSizeEncoder<SysvarSlotHistory, SysvarSlotHistorySize> {\n    return createEncoder({\n        fixedSize: SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE,\n        write: (value: SysvarSlotHistory, bytes, offset) => {\n            // First byte is the bitvector discriminator.\n            bytes.set([BITVEC_DISCRIMINATOR], offset);\n            offset += 1;\n            // Next 8 bytes are the bitvector length.\n            getMemoizedU64Encoder().write(BigInt(BITVEC_LENGTH), bytes, offset);\n            offset += 8;\n            // Next `BITVEC_LENGTH` bytes are the bitvector.\n            // Any missing bits are assumed to be 0.\n            getMemoizedU64ArrayEncoder().write(value.bits, bytes, offset);\n            offset += BITVEC_LENGTH * 8;\n            // Next 8 bytes are the number of bits.\n            getMemoizedU64Encoder().write(BigInt(BITVEC_NUM_BITS), bytes, offset);\n            offset += 8;\n            // Next 8 bytes are the next slot.\n            getMemoizedU64Encoder().write(value.nextSlot, bytes, offset);\n            offset += 8;\n            return offset;\n        },\n    });\n}\n\nexport function getSysvarSlotHistoryDecoder(): FixedSizeDecoder<SysvarSlotHistory, SysvarSlotHistorySize> {\n    return createDecoder({\n        fixedSize: SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE,\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            // Byte length should be exact.\n            if (bytes.length != SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n                    actual: bytes.length,\n                    expected: SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE,\n                });\n            }\n            // First byte is the bitvector discriminator.\n            const discriminator = bytes[offset];\n            offset += 1;\n            if (discriminator !== BITVEC_DISCRIMINATOR) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, {\n                    actual: discriminator,\n                    expected: BITVEC_DISCRIMINATOR,\n                });\n            }\n            // Next 8 bytes are the bitvector length.\n            const bitVecLength = getMemoizedU64Decoder().read(bytes, offset)[0];\n            offset += 8;\n            if (bitVecLength !== BigInt(BITVEC_LENGTH)) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, {\n                    actual: bitVecLength,\n                    codecDescription: 'SysvarSlotHistoryCodec',\n                    expected: BITVEC_LENGTH,\n                });\n            }\n            // Next `BITVEC_LENGTH` bytes are the bitvector.\n            const bits = getMemoizedU64ArrayDecoder().read(bytes, offset)[0];\n            offset += BITVEC_LENGTH * 8;\n            // Next 8 bytes are the number of bits.\n            const numBits = getMemoizedU64Decoder().read(bytes, offset)[0];\n            offset += 8;\n            if (numBits !== BigInt(BITVEC_NUM_BITS)) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, {\n                    actual: numBits,\n                    codecDescription: 'SysvarSlotHistoryCodec',\n                    expected: BITVEC_NUM_BITS,\n                });\n            }\n            // Next 8 bytes are the next slot.\n            const nextSlot = getMemoizedU64Decoder().read(bytes, offset)[0];\n            offset += 8;\n            return [\n                {\n                    bits,\n                    nextSlot,\n                },\n                offset,\n            ];\n        },\n    });\n}\n\nexport function getSysvarSlotHistoryCodec(): FixedSizeCodec<\n    SysvarSlotHistory,\n    SysvarSlotHistory,\n    SysvarSlotHistorySize\n> {\n    return combineCodec(getSysvarSlotHistoryEncoder(), getSysvarSlotHistoryDecoder());\n}\n\n/**\n * Fetch the `SlotHistory` sysvar.\n *\n * A bitvector of slots present over the last epoch.\n */\nexport async function fetchSysvarSlotHistory(\n    rpc: Rpc<GetAccountInfoApi>,\n    config?: FetchAccountConfig,\n): Promise<SysvarSlotHistory> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_SLOT_HISTORY_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarSlotHistoryDecoder());\n    return decoded.data;\n}\n","import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    getArrayDecoder,\n    getArrayEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    type VariableSizeCodec,\n    type VariableSizeDecoder,\n    type VariableSizeEncoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport { getDefaultLamportsDecoder, getDefaultLamportsEncoder, type Lamports } from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_STAKE_HISTORY_ADDRESS } from './sysvar';\n\ntype Entry = Readonly<{\n    activating: Lamports;\n    deactivating: Lamports;\n    effective: Lamports;\n}>;\n\n/**\n * The `StakeHistory` sysvar.\n *\n * History of stake activations and de-activations.\n */\nexport type SysvarStakeHistory = Entry[];\n\nexport function getSysvarStakeHistoryEncoder(): VariableSizeEncoder<SysvarStakeHistory> {\n    return getArrayEncoder(\n        getStructEncoder([\n            ['effective', getDefaultLamportsEncoder()],\n            ['activating', getDefaultLamportsEncoder()],\n            ['deactivating', getDefaultLamportsEncoder()],\n        ]),\n    );\n}\n\nexport function getSysvarStakeHistoryDecoder(): VariableSizeDecoder<SysvarStakeHistory> {\n    return getArrayDecoder(\n        getStructDecoder([\n            ['effective', getDefaultLamportsDecoder()],\n            ['activating', getDefaultLamportsDecoder()],\n            ['deactivating', getDefaultLamportsDecoder()],\n        ]),\n    );\n}\n\nexport function getSysvarStakeHistoryCodec(): VariableSizeCodec<SysvarStakeHistory> {\n    return combineCodec(getSysvarStakeHistoryEncoder(), getSysvarStakeHistoryDecoder());\n}\n\n/**\n * Fetch the `StakeHistory` sysvar.\n *\n * History of stake activations and de-activations.\n */\nexport async function fetchSysvarStakeHistory(\n    rpc: Rpc<GetAccountInfoApi>,\n    config?: FetchAccountConfig,\n): Promise<SysvarStakeHistory> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_STAKE_HISTORY_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarStakeHistoryDecoder());\n    return decoded.data;\n}\n","import {\n  fetchAllMaybeToken,\n  fetchAllMint,\n  findAssociatedTokenPda,\n  getCloseAccountInstruction,\n  getCreateAssociatedTokenInstruction,\n  getInitializeAccount3Instruction,\n  getSyncNativeInstruction,\n  TOKEN_PROGRAM_ADDRESS,\n} from \"@solana-program/token\";\nimport type {\n  Account,\n  Address,\n  GetAccountInfoApi,\n  GetMinimumBalanceForRentExemptionApi,\n  GetMultipleAccountsApi,\n  IInstruction,\n  MaybeAccount,\n  Rpc,\n  TransactionSigner,\n} from \"@solana/web3.js\";\nimport {\n  address,\n  generateKeyPairSigner,\n  getAddressDecoder,\n  getAddressEncoder,\n  lamports,\n} from \"@solana/web3.js\";\nimport { NATIVE_MINT_WRAPPING_STRATEGY } from \"./config\";\nimport {\n  getCreateAccountInstruction,\n  getCreateAccountWithSeedInstruction,\n  getTransferSolInstruction,\n} from \"@solana-program/system\";\nimport { getTokenSize } from \"@solana-program/token\";\nimport { getTokenSize as getTokenSizeWithExtensions } from \"@solana-program/token-2022\";\nimport type { ExtensionArgs, Mint } from \"@solana-program/token-2022\";\nimport type { TransferFee } from \"@orca-so/whirlpools-core\";\nimport assert from \"assert\";\n\n// This file is not exported through the barrel file\n\n/** The public key for the native mint (SOL) */\nexport const NATIVE_MINT = address(\n  \"So11111111111111111111111111111111111111112\",\n);\n\n/**\n * Represents the instructions and associated addresses for preparing token accounts during a transaction.\n */\ntype TokenAccountInstructions = {\n  /** A list of instructions required to create the necessary token accounts. */\n  createInstructions: IInstruction[];\n\n  /** A list of instructions to clean up (e.g., close) token accounts after the transaction is complete. */\n  cleanupInstructions: IInstruction[];\n\n  /** A mapping of mint addresses to their respective token account addresses. */\n  tokenAccountAddresses: Record<Address, Address>;\n};\n\nfunction mintFilter(x: Address) {\n  if (\n    NATIVE_MINT_WRAPPING_STRATEGY === \"none\" ||\n    NATIVE_MINT_WRAPPING_STRATEGY === \"ata\"\n  ) {\n    return true;\n  }\n  return x != NATIVE_MINT;\n}\n\n/**\n *\n * Prepare token acounts required for a transaction. This will create\n * ATAs for the supplied mints.\n *\n * The NATIVE_MINT is a special case where this function will optionally wrap/unwrap\n * Native Mint based on the NATIVE_MINT_WRAPPING_STRATEGY.\n *\n * @param rpc\n * @param owner the owner to create token accounts for\n * @param spec the mints (and amounts) required in the token accounts\n * @returns Instructions and addresses for the required token accounts\n */\nexport async function prepareTokenAccountsInstructions(\n  rpc: Rpc<\n    GetAccountInfoApi &\n      GetMultipleAccountsApi &\n      GetMinimumBalanceForRentExemptionApi\n  >,\n  owner: TransactionSigner,\n  spec: Address[] | Record<Address, bigint | number>,\n): Promise<TokenAccountInstructions> {\n  const mintAddresses = Array.isArray(spec)\n    ? spec\n    : (Object.keys(spec) as Address[]);\n  const nativeMintIndex = mintAddresses.indexOf(NATIVE_MINT);\n  const hasNativeMint = nativeMintIndex !== -1;\n  const mints = await fetchAllMint(rpc, mintAddresses.filter(mintFilter));\n  const tokenAddresses = await Promise.all(\n    mints.map((mint) =>\n      findAssociatedTokenPda({\n        owner: owner.address,\n        mint: mint.address,\n        tokenProgram: mint.programAddress,\n      }).then((x) => x[0]),\n    ),\n  );\n  const tokenAccounts = await fetchAllMaybeToken(rpc, tokenAddresses);\n  const tokenAccountAddresses: Record<Address, Address> = {};\n\n  const createInstructions: IInstruction[] = [];\n  const cleanupInstructions: IInstruction[] = [];\n\n  for (let i = 0; i < mints.length; i++) {\n    const mint = mints[i];\n    const tokenAccount = tokenAccounts[i];\n    tokenAccountAddresses[mint.address] = tokenAccount.address;\n    if (tokenAccount.exists) {\n      continue;\n    }\n    createInstructions.push(\n      getCreateAssociatedTokenInstruction({\n        payer: owner,\n        owner: owner.address,\n        ata: tokenAccount.address,\n        mint: mint.address,\n        tokenProgram: mint.programAddress,\n      }),\n    );\n  }\n\n  if (!Array.isArray(spec)) {\n    for (let i = 0; i < mints.length; i++) {\n      const mint = mints[i];\n      if (\n        mint.address === NATIVE_MINT &&\n        NATIVE_MINT_WRAPPING_STRATEGY !== \"none\"\n      ) {\n        continue;\n      }\n      const tokenAccount = tokenAccounts[i];\n      const existingBalance = tokenAccount.exists\n        ? tokenAccount.data.amount\n        : 0n;\n      assert(\n        BigInt(spec[mint.address]) <= existingBalance,\n        `Token account for ${mint.address} does not have the required balance`,\n      );\n    }\n  }\n\n  if (hasNativeMint && NATIVE_MINT_WRAPPING_STRATEGY === \"keypair\") {\n    const keypair = await generateKeyPairSigner();\n    const space = getTokenSize();\n    let amount = await rpc\n      .getMinimumBalanceForRentExemption(BigInt(space))\n      .send();\n\n    if (!Array.isArray(spec)) {\n      amount = lamports(amount + BigInt(spec[NATIVE_MINT]));\n    }\n\n    createInstructions.push(\n      getCreateAccountInstruction({\n        payer: owner,\n        newAccount: keypair,\n        lamports: amount,\n        space,\n        programAddress: TOKEN_PROGRAM_ADDRESS,\n      }),\n      getInitializeAccount3Instruction({\n        account: keypair.address,\n        mint: NATIVE_MINT,\n        owner: owner.address,\n      }),\n    );\n    cleanupInstructions.push(\n      getCloseAccountInstruction({\n        account: keypair.address,\n        owner,\n        destination: owner.address,\n      }),\n    );\n    tokenAccountAddresses[NATIVE_MINT] = keypair.address;\n  }\n\n  if (hasNativeMint && NATIVE_MINT_WRAPPING_STRATEGY === \"seed\") {\n    const space = getTokenSize();\n    let amount = await rpc\n      .getMinimumBalanceForRentExemption(BigInt(space))\n      .send();\n\n    if (!Array.isArray(spec)) {\n      amount = lamports(amount + BigInt(spec[NATIVE_MINT]));\n    }\n\n    // Generating secure seed takes longer and is not really needed here.\n    // With date, it should only create collisions if the same owner\n    // creates multiple accounts at exactly the same time (in ms)\n    const seed = Date.now().toString();\n    const buffer = await crypto.subtle.digest(\n      \"SHA-256\",\n      Buffer.concat([\n        Buffer.from(getAddressEncoder().encode(owner.address)),\n        Buffer.from(seed),\n        Buffer.from(getAddressEncoder().encode(TOKEN_PROGRAM_ADDRESS)),\n      ]),\n    );\n    tokenAccountAddresses[NATIVE_MINT] = getAddressDecoder().decode(\n      new Uint8Array(buffer),\n    );\n\n    createInstructions.push(\n      getCreateAccountWithSeedInstruction({\n        payer: owner,\n        newAccount: tokenAccountAddresses[NATIVE_MINT],\n        base: owner.address,\n        baseAccount: owner,\n        seed: seed,\n        space,\n        amount,\n        programAddress: TOKEN_PROGRAM_ADDRESS,\n      }),\n      getInitializeAccount3Instruction({\n        account: tokenAccountAddresses[NATIVE_MINT],\n        mint: NATIVE_MINT,\n        owner: owner.address,\n      }),\n    );\n\n    cleanupInstructions.push(\n      getCloseAccountInstruction({\n        account: tokenAccountAddresses[NATIVE_MINT],\n        owner,\n        destination: owner.address,\n      }),\n    );\n  }\n\n  if (hasNativeMint && NATIVE_MINT_WRAPPING_STRATEGY === \"ata\") {\n    const account = tokenAccounts[nativeMintIndex];\n    const existingBalance = account.exists ? account.data.amount : 0n;\n\n    if (!Array.isArray(spec) && existingBalance < BigInt(spec[NATIVE_MINT])) {\n      createInstructions.push(\n        getTransferSolInstruction({\n          source: owner,\n          destination: tokenAccountAddresses[NATIVE_MINT],\n          amount: BigInt(spec[NATIVE_MINT]) - existingBalance,\n        }),\n        getSyncNativeInstruction({\n          account: tokenAccountAddresses[NATIVE_MINT],\n        }),\n      );\n    }\n\n    if (!account.exists) {\n      cleanupInstructions.push(\n        getCloseAccountInstruction({\n          account: account.address,\n          owner,\n          destination: owner.address,\n        }),\n      );\n    }\n  }\n\n  return {\n    createInstructions,\n    cleanupInstructions,\n    tokenAccountAddresses,\n  };\n}\n\n/**\n * Retrieves the current transfer fee configuration for a given token mint based on the current epoch.\n *\n * This function checks the mint's transfer fee configuration and returns the appropriate fee\n * structure (older or newer) depending on the current epoch. If no transfer fee configuration is found,\n * it returns `undefined`.\n *\n * @param {Mint} mint - The mint account of the token, which may include transfer fee extensions.\n * @param {bigint} currentEpoch - The current epoch to determine the applicable transfer fee.\n *\n * @returns {TransferFee | undefined} - The transfer fee configuration for the given mint, or `undefined` if no transfer fee is configured.\n */\nexport function getCurrentTransferFee(\n  mint: MaybeAccount<Mint> | Account<Mint> | null,\n  currentEpoch: bigint,\n): TransferFee | undefined {\n  if (\n    mint == null ||\n    (\"exists\" in mint && !mint.exists) ||\n    mint.data.extensions.__option === \"None\"\n  ) {\n    return undefined;\n  }\n  const feeConfig = mint.data.extensions.value.find(\n    (x) => x.__kind === \"TransferFeeConfig\",\n  );\n  if (feeConfig == null) {\n    return undefined;\n  }\n  const transferFee =\n    currentEpoch >= feeConfig.newerTransferFee.epoch\n      ? feeConfig.newerTransferFee\n      : feeConfig.olderTransferFee;\n  return {\n    feeBps: transferFee.transferFeeBasisPoints,\n    maxFee: transferFee.maximumFee,\n  };\n}\n\n/**\n * Builds the required account extensions for a given mint. This should only be used\n * for non-ATA token accounts since ATA accounts should also add the ImmutableOwner extension.\n *\n * https://github.com/solana-labs/solana-program-library/blob/3844bfac50990c1aa4dfb30f244f8c13178fc3fa/token/program-2022/src/extension/mod.rs#L1276\n *\n * @param {Mint} mint - The mint account to build extensions for.\n * @returns {ExtensionArgs[]} An array of extension arguments.\n */\nexport function getAccountExtensions(mint: Mint): ExtensionArgs[] {\n  if (mint.extensions.__option === \"None\") {\n    return [];\n  }\n  const extensions: ExtensionArgs[] = [];\n  for (const extension of mint.extensions.value) {\n    switch (extension.__kind) {\n      case \"TransferFeeConfig\":\n        extensions.push({\n          __kind: \"TransferFeeAmount\",\n          withheldAmount: 0n,\n        });\n        break;\n      case \"NonTransferable\":\n        extensions.push({\n          __kind: \"NonTransferableAccount\",\n        });\n        break;\n      case \"TransferHook\":\n        extensions.push({\n          __kind: \"TransferHookAccount\",\n          transferring: false,\n        });\n        break;\n    }\n  }\n  return extensions;\n}\n\n/**\n * Orders two mints by canonical byte order.\n *\n * @param {Address} mint1\n * @param {Address} mint2\n * @returns {[Address, Address]} [mint1, mint2] if mint1 should come first, [mint2, mint1] otherwise\n */\nexport function orderMints(mint1: Address, mint2: Address): [Address, Address] {\n  const encoder = getAddressEncoder();\n  const mint1Bytes = new Uint8Array(encoder.encode(mint1));\n  const mint2Bytes = new Uint8Array(encoder.encode(mint2));\n  return Buffer.compare(mint1Bytes, mint2Bytes) < 0\n    ? [mint1, mint2]\n    : [mint2, mint1];\n}\n\n/**\n * Returns the token size for a given mint account.\n *\n * @param {Account<Mint>} mint - The mint account to get the token size for.\n * @returns {number} The token size for the given mint account.\n */\nexport function getTokenSizeForMint(mint: Account<Mint>): number {\n  const extensions = getAccountExtensions(mint.data);\n  return extensions.length === 0\n    ? getTokenSize()\n    : getTokenSizeWithExtensions(extensions);\n}\n","import type { SysvarRent } from \"@solana/sysvars\";\n\n/**\n * The overhead storage size for accounts.\n */\nconst ACCOUNT_STORAGE_OVERHEAD = 128;\n\n/**\n * Calculates the minimum balance required for rent exemption for a given account size.\n *\n * @param {Rpc} rpc - The Solana RPC client to fetch sysvar rent data.\n * @param {number} dataSize - The size of the account data in bytes.\n * @returns {bigint} The minimum balance required for rent exemption in lamports.\n */\nexport function calculateMinimumBalanceForRentExemption(\n  rent: SysvarRent,\n  dataSize: number,\n): bigint {\n  const dataSizeForRent = BigInt(dataSize + ACCOUNT_STORAGE_OVERHEAD);\n  const rentLamportsPerYear = rent.lamportsPerByteYear * dataSizeForRent;\n  const minimumBalance = rentLamportsPerYear * BigInt(rent.exemptionThreshold);\n\n  return minimumBalance;\n}\n","import type { Whirlpool } from \"@orca-so/whirlpools-client\";\nimport {\n  fetchAllTickArray,\n  fetchPosition,\n  fetchWhirlpool,\n  getClosePositionInstruction,\n  getClosePositionWithTokenExtensionsInstruction,\n  getCollectFeesV2Instruction,\n  getCollectRewardV2Instruction,\n  getDecreaseLiquidityV2Instruction,\n  getPositionAddress,\n  getTickArrayAddress,\n} from \"@orca-so/whirlpools-client\";\nimport type {\n  CollectFeesQuote,\n  CollectRewardsQuote,\n  DecreaseLiquidityQuote,\n  TickRange,\n  TransferFee,\n} from \"@orca-so/whirlpools-core\";\nimport {\n  _MAX_TICK_INDEX,\n  _MIN_TICK_INDEX,\n  getTickArrayStartTickIndex,\n  decreaseLiquidityQuote,\n  decreaseLiquidityQuoteA,\n  decreaseLiquidityQuoteB,\n  collectFeesQuote,\n  collectRewardsQuote,\n  getTickIndexInArray,\n} from \"@orca-so/whirlpools-core\";\nimport type {\n  Address,\n  GetAccountInfoApi,\n  GetEpochInfoApi,\n  GetMinimumBalanceForRentExemptionApi,\n  GetMultipleAccountsApi,\n  IInstruction,\n  Rpc,\n  TransactionSigner,\n} from \"@solana/web3.js\";\nimport { DEFAULT_ADDRESS, FUNDER, SLIPPAGE_TOLERANCE_BPS } from \"./config\";\nimport {\n  findAssociatedTokenPda,\n  TOKEN_PROGRAM_ADDRESS,\n} from \"@solana-program/token\";\nimport {\n  getCurrentTransferFee,\n  prepareTokenAccountsInstructions,\n} from \"./token\";\nimport {\n  fetchAllMint,\n  fetchAllMaybeMint,\n  TOKEN_2022_PROGRAM_ADDRESS,\n} from \"@solana-program/token-2022\";\nimport { MEMO_PROGRAM_ADDRESS } from \"@solana-program/memo\";\nimport assert from \"assert\";\n\n// TODO: allow specify number as well as bigint\n// TODO: transfer hook\n\n/**\n * Represents the parameters for decreasing liquidity.\n * You must choose only one of the properties (`liquidity`, `tokenA`, or `tokenB`).\n * The SDK will compute the other two based on the input provided.\n */\nexport type DecreaseLiquidityQuoteParam =\n  | {\n      /** The amount of liquidity to decrease.*/\n      liquidity: bigint;\n    }\n  | {\n      /** The amount of Token A to withdraw.*/\n      tokenA: bigint;\n    }\n  | {\n      /** The amount of Token B to withdraw.*/\n      tokenB: bigint;\n    };\n\n/**\n * Represents the instructions and quote for decreasing liquidity in a position.\n */\nexport type DecreaseLiquidityInstructions = {\n  /** The quote details for decreasing liquidity, including the liquidity delta, estimated tokens, and minimum token amounts based on slippage tolerance. */\n  quote: DecreaseLiquidityQuote;\n\n  /** The list of instructions required to decrease liquidity. */\n  instructions: IInstruction[];\n};\n\nfunction getDecreaseLiquidityQuote(\n  param: DecreaseLiquidityQuoteParam,\n  pool: Whirlpool,\n  tickRange: TickRange,\n  slippageToleranceBps: number,\n  transferFeeA: TransferFee | undefined,\n  transferFeeB: TransferFee | undefined,\n): DecreaseLiquidityQuote {\n  if (\"liquidity\" in param) {\n    return decreaseLiquidityQuote(\n      param.liquidity,\n      slippageToleranceBps,\n      pool.sqrtPrice,\n      tickRange.tickLowerIndex,\n      tickRange.tickUpperIndex,\n      transferFeeA,\n      transferFeeB,\n    );\n  } else if (\"tokenA\" in param) {\n    return decreaseLiquidityQuoteA(\n      param.tokenA,\n      slippageToleranceBps,\n      pool.sqrtPrice,\n      tickRange.tickLowerIndex,\n      tickRange.tickUpperIndex,\n      transferFeeA,\n      transferFeeB,\n    );\n  } else {\n    return decreaseLiquidityQuoteB(\n      param.tokenB,\n      slippageToleranceBps,\n      pool.sqrtPrice,\n      tickRange.tickLowerIndex,\n      tickRange.tickUpperIndex,\n      transferFeeA,\n      transferFeeB,\n    );\n  }\n}\n\n/**\n * Generates instructions to decrease liquidity from an existing position in an Orca Whirlpool.\n *\n * @param {SolanaRpc} rpc - A Solana RPC client for fetching necessary accounts and pool data.\n * @param {Address} positionMintAddress - The mint address of the NFT that represents ownership of the position from which liquidity will be removed.\n * @param {DecreaseLiquidityQuoteParam} param - Defines the liquidity removal method (liquidity, tokenA, or tokenB).\n * @param {number} [slippageToleranceBps=SLIPPAGE_TOLERANCE_BPS] - The acceptable slippage tolerance in basis points.\n * @param {TransactionSigner} [authority=FUNDER] - The account authorizing the liquidity removal.\n *\n * @returns {Promise<DecreaseLiquidityInstructions>} A promise resolving to an object containing the decrease liquidity quote and instructions.\n *\n * @example\n * import { decreaseLiquidityInstructions, setWhirlpoolsConfig } from '@orca-so/whirlpools';\n * import { createSolanaRpc, devnet, address } from '@solana/web3.js';\n * import { loadWallet } from './utils';\n *\n * await setWhirlpoolsConfig('solanaDevnet');\n * const devnetRpc = createSolanaRpc(devnet('https://api.devnet.solana.com'));\n * const wallet = await loadWallet();\n * const positionMint = address(\"HqoV7Qv27REUtmd9UKSJGGmCRNx3531t33bDG1BUfo9K\");\n * const param = { tokenA: 10n };\n * const { quote, instructions } = await decreaseLiquidityInstructions(\n *   devnetRpc,\n *   positionMint,\n *   param,\n *   100,\n *   wallet\n * );\n *\n * console.log(`Quote token max B: ${quote.tokenEstB}`);\n */\nexport async function decreaseLiquidityInstructions(\n  rpc: Rpc<\n    GetAccountInfoApi &\n      GetMultipleAccountsApi &\n      GetMinimumBalanceForRentExemptionApi &\n      GetEpochInfoApi\n  >,\n  positionMintAddress: Address,\n  param: DecreaseLiquidityQuoteParam,\n  slippageToleranceBps: number = SLIPPAGE_TOLERANCE_BPS,\n  authority: TransactionSigner = FUNDER,\n): Promise<DecreaseLiquidityInstructions> {\n  assert(\n    authority.address !== DEFAULT_ADDRESS,\n    \"Either supply the authority or set the default funder\",\n  );\n\n  const positionAddress = await getPositionAddress(positionMintAddress);\n  const position = await fetchPosition(rpc, positionAddress[0]);\n  const whirlpool = await fetchWhirlpool(rpc, position.data.whirlpool);\n\n  const currentEpoch = await rpc.getEpochInfo().send();\n  const [mintA, mintB, positionMint] = await fetchAllMint(rpc, [\n    whirlpool.data.tokenMintA,\n    whirlpool.data.tokenMintB,\n    positionMintAddress,\n  ]);\n  const transferFeeA = getCurrentTransferFee(mintA, currentEpoch.epoch);\n  const transferFeeB = getCurrentTransferFee(mintB, currentEpoch.epoch);\n\n  const quote = getDecreaseLiquidityQuote(\n    param,\n    whirlpool.data,\n    position.data,\n    slippageToleranceBps,\n    transferFeeA,\n    transferFeeB,\n  );\n  const instructions: IInstruction[] = [];\n\n  const lowerTickArrayStartIndex = getTickArrayStartTickIndex(\n    position.data.tickLowerIndex,\n    whirlpool.data.tickSpacing,\n  );\n  const upperTickArrayStartIndex = getTickArrayStartTickIndex(\n    position.data.tickUpperIndex,\n    whirlpool.data.tickSpacing,\n  );\n\n  const [positionTokenAccount, tickArrayLower, tickArrayUpper] =\n    await Promise.all([\n      findAssociatedTokenPda({\n        owner: authority.address,\n        mint: positionMintAddress,\n        tokenProgram: positionMint.programAddress,\n      }).then((x) => x[0]),\n      getTickArrayAddress(whirlpool.address, lowerTickArrayStartIndex).then(\n        (x) => x[0],\n      ),\n      getTickArrayAddress(whirlpool.address, upperTickArrayStartIndex).then(\n        (x) => x[0],\n      ),\n    ]);\n\n  const { createInstructions, cleanupInstructions, tokenAccountAddresses } =\n    await prepareTokenAccountsInstructions(rpc, authority, [\n      whirlpool.data.tokenMintA,\n      whirlpool.data.tokenMintB,\n    ]);\n\n  instructions.push(...createInstructions);\n\n  instructions.push(\n    getDecreaseLiquidityV2Instruction({\n      whirlpool: whirlpool.address,\n      positionAuthority: authority,\n      position: position.address,\n      positionTokenAccount,\n      tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],\n      tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],\n      tokenVaultA: whirlpool.data.tokenVaultA,\n      tokenVaultB: whirlpool.data.tokenVaultB,\n      tokenMintA: whirlpool.data.tokenMintA,\n      tokenMintB: whirlpool.data.tokenMintB,\n      tokenProgramA: mintA.programAddress,\n      tokenProgramB: mintB.programAddress,\n      memoProgram: MEMO_PROGRAM_ADDRESS,\n      tickArrayLower,\n      tickArrayUpper,\n      liquidityAmount: quote.liquidityDelta,\n      tokenMinA: quote.tokenMinA,\n      tokenMinB: quote.tokenMinB,\n      remainingAccountsInfo: null,\n    }),\n  );\n\n  instructions.push(...cleanupInstructions);\n\n  return { quote, instructions };\n}\n\n/**\n * Represents the instructions and quotes for closing a liquidity position in an Orca Whirlpool.\n * Extends `DecreaseLiquidityInstructions` and adds additional fee and reward details.\n */\nexport type ClosePositionInstructions = DecreaseLiquidityInstructions & {\n  /** The fees collected from the position, including the amounts for token A (`fee_owed_a`) and token B (`fee_owed_b`). */\n  feesQuote: CollectFeesQuote;\n\n  /** The rewards collected from the position, including up to three reward tokens (`reward_owed_1`, `reward_owed_2`, and `reward_owed_3`). */\n  rewardsQuote: CollectRewardsQuote;\n};\n\n/**\n * Generates instructions to close a liquidity position in an Orca Whirlpool. This includes collecting all fees,\n * rewards, removing any remaining liquidity, and closing the position.\n *\n * @param {SolanaRpc} rpc - A Solana RPC client for fetching accounts and pool data.\n * @param {Address} positionMintAddress - The mint address of the NFT that represents ownership of the position to be closed.\n * @param {number} [slippageToleranceBps=SLIPPAGE_TOLERANCE_BPS] - The acceptable slippage tolerance in basis points.\n * @param {TransactionSigner} [authority=FUNDER] - The account authorizing the transaction.\n *\n * @returns {Promise<ClosePositionInstructions>} A promise resolving to an object containing instructions, fees quote, rewards quote, and the liquidity quote for the closed position.\n *\n * @example\n * import { closePositionInstructions, setWhirlpoolsConfig } from '@orca-so/whirlpools';\n * import { createSolanaRpc, devnet, address } from '@solana/web3.js';\n * import { loadWallet } from './utils';\n *\n * await setWhirlpoolsConfig('solanaDevnet');\n * const devnetRpc = createSolanaRpc(devnet('https://api.devnet.solana.com'));\n * const wallet = await loadWallet();\n * const positionMint = address(\"HqoV7Qv27REUtmd9UKSJGGmCRNx3531t33bDG1BUfo9K\");\n *\n * const { instructions, quote, feesQuote, rewardsQuote } = await closePositionInstructions(\n *   devnetRpc,\n *   positionMint,\n *   100,\n *   wallet\n * );\n *\n * console.log(`Quote token max B: ${quote.tokenEstB}`);\n * console.log(`Fees owed token A: ${feesQuote.feeOwedA}`);\n * console.log(`Rewards '1' owed: ${rewardsQuote.rewards[0].rewardsOwed}`);\n * console.log(`Number of instructions:, ${instructions.length}`);\n */\nexport async function closePositionInstructions(\n  rpc: Rpc<\n    GetAccountInfoApi &\n      GetMultipleAccountsApi &\n      GetMinimumBalanceForRentExemptionApi &\n      GetEpochInfoApi\n  >,\n  positionMintAddress: Address,\n  slippageToleranceBps: number = SLIPPAGE_TOLERANCE_BPS,\n  authority: TransactionSigner = FUNDER,\n): Promise<ClosePositionInstructions> {\n  assert(\n    authority.address !== DEFAULT_ADDRESS,\n    \"Either supply an authority or set the default funder\",\n  );\n\n  const positionAddress = await getPositionAddress(positionMintAddress);\n  const position = await fetchPosition(rpc, positionAddress[0]);\n  const whirlpool = await fetchWhirlpool(rpc, position.data.whirlpool);\n\n  const currentEpoch = await rpc.getEpochInfo().send();\n  const [mintA, mintB, positionMint, ...rewardMints] = await fetchAllMaybeMint(\n    rpc,\n    [\n      whirlpool.data.tokenMintA,\n      whirlpool.data.tokenMintB,\n      positionMintAddress,\n      ...whirlpool.data.rewardInfos\n        .map((x) => x.mint)\n        .filter((x) => x !== DEFAULT_ADDRESS),\n    ],\n  );\n\n  assert(mintA.exists, \"Token A not found\");\n  assert(mintB.exists, \"Token B not found\");\n  assert(positionMint.exists, \"Position mint not found\");\n\n  const transferFeeA = getCurrentTransferFee(mintA, currentEpoch.epoch);\n  const transferFeeB = getCurrentTransferFee(mintB, currentEpoch.epoch);\n\n  const quote = getDecreaseLiquidityQuote(\n    { liquidity: position.data.liquidity },\n    whirlpool.data,\n    position.data,\n    slippageToleranceBps,\n    transferFeeA,\n    transferFeeB,\n  );\n\n  const lowerTickArrayStartIndex = getTickArrayStartTickIndex(\n    position.data.tickLowerIndex,\n    whirlpool.data.tickSpacing,\n  );\n  const upperTickArrayStartIndex = getTickArrayStartTickIndex(\n    position.data.tickUpperIndex,\n    whirlpool.data.tickSpacing,\n  );\n\n  const [positionTokenAccount, lowerTickArrayAddress, upperTickArrayAddress] =\n    await Promise.all([\n      findAssociatedTokenPda({\n        owner: authority.address,\n        mint: positionMintAddress,\n        tokenProgram: positionMint.programAddress,\n      }).then((x) => x[0]),\n      getTickArrayAddress(whirlpool.address, lowerTickArrayStartIndex).then(\n        (x) => x[0],\n      ),\n      getTickArrayAddress(whirlpool.address, upperTickArrayStartIndex).then(\n        (x) => x[0],\n      ),\n    ]);\n\n  const [lowerTickArray, upperTickArray] = await fetchAllTickArray(rpc, [\n    lowerTickArrayAddress,\n    upperTickArrayAddress,\n  ]);\n\n  const lowerTick =\n    lowerTickArray.data.ticks[\n      getTickIndexInArray(\n        position.data.tickLowerIndex,\n        lowerTickArrayStartIndex,\n        whirlpool.data.tickSpacing,\n      )\n    ];\n  const upperTick =\n    upperTickArray.data.ticks[\n      getTickIndexInArray(\n        position.data.tickUpperIndex,\n        upperTickArrayStartIndex,\n        whirlpool.data.tickSpacing,\n      )\n    ];\n\n  const feesQuote = collectFeesQuote(\n    whirlpool.data,\n    position.data,\n    lowerTick,\n    upperTick,\n    transferFeeA,\n    transferFeeB,\n  );\n  const currentUnixTimestamp = BigInt(Math.floor(Date.now() / 1000));\n  const rewardsQuote = collectRewardsQuote(\n    whirlpool.data,\n    position.data,\n    lowerTick,\n    upperTick,\n    currentUnixTimestamp,\n    getCurrentTransferFee(rewardMints[0], currentEpoch.epoch),\n    getCurrentTransferFee(rewardMints[1], currentEpoch.epoch),\n    getCurrentTransferFee(rewardMints[2], currentEpoch.epoch),\n  );\n\n  const requiredMints: Set<Address> = new Set();\n  if (\n    quote.liquidityDelta > 0n ||\n    feesQuote.feeOwedA > 0n ||\n    feesQuote.feeOwedB > 0n\n  ) {\n    requiredMints.add(whirlpool.data.tokenMintA);\n    requiredMints.add(whirlpool.data.tokenMintB);\n  }\n\n  for (let i = 0; i < rewardsQuote.rewards.length; i++) {\n    if (rewardsQuote.rewards[i].rewardsOwed > 0n) {\n      requiredMints.add(whirlpool.data.rewardInfos[i].mint);\n    }\n  }\n\n  const { createInstructions, cleanupInstructions, tokenAccountAddresses } =\n    await prepareTokenAccountsInstructions(\n      rpc,\n      authority,\n      Array.from(requiredMints),\n    );\n\n  const instructions: IInstruction[] = [];\n  instructions.push(...createInstructions);\n\n  if (quote.liquidityDelta > 0n) {\n    instructions.push(\n      getDecreaseLiquidityV2Instruction({\n        whirlpool: whirlpool.address,\n        positionAuthority: authority,\n        position: positionAddress[0],\n        positionTokenAccount,\n        tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],\n        tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],\n        tokenVaultA: whirlpool.data.tokenVaultA,\n        tokenVaultB: whirlpool.data.tokenVaultB,\n        tickArrayLower: lowerTickArrayAddress,\n        tickArrayUpper: upperTickArrayAddress,\n        liquidityAmount: quote.liquidityDelta,\n        tokenMinA: quote.tokenMinA,\n        tokenMinB: quote.tokenMinB,\n        tokenMintA: whirlpool.data.tokenMintA,\n        tokenMintB: whirlpool.data.tokenMintB,\n        tokenProgramA: mintA.programAddress,\n        tokenProgramB: mintB.programAddress,\n        memoProgram: MEMO_PROGRAM_ADDRESS,\n        remainingAccountsInfo: null,\n      }),\n    );\n  }\n\n  if (feesQuote.feeOwedA > 0n || feesQuote.feeOwedB > 0n) {\n    instructions.push(\n      getCollectFeesV2Instruction({\n        whirlpool: whirlpool.address,\n        positionAuthority: authority,\n        position: positionAddress[0],\n        positionTokenAccount,\n        tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],\n        tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],\n        tokenVaultA: whirlpool.data.tokenVaultA,\n        tokenVaultB: whirlpool.data.tokenVaultB,\n        tokenMintA: whirlpool.data.tokenMintA,\n        tokenMintB: whirlpool.data.tokenMintB,\n        tokenProgramA: mintA.programAddress,\n        tokenProgramB: mintB.programAddress,\n        memoProgram: MEMO_PROGRAM_ADDRESS,\n        remainingAccountsInfo: null,\n      }),\n    );\n  }\n\n  for (let i = 0; i < rewardsQuote.rewards.length; i++) {\n    if (rewardsQuote.rewards[i].rewardsOwed === 0n) {\n      continue;\n    }\n    const rewardMint = rewardMints[i];\n    assert(rewardMint.exists, `Reward mint ${i} not found`);\n    instructions.push(\n      getCollectRewardV2Instruction({\n        whirlpool: whirlpool.address,\n        positionAuthority: authority,\n        position: positionAddress[0],\n        positionTokenAccount,\n        rewardOwnerAccount: tokenAccountAddresses[rewardMint.address],\n        rewardVault: whirlpool.data.rewardInfos[i].vault,\n        rewardIndex: i,\n        rewardMint: rewardMint.address,\n        rewardTokenProgram: rewardMint.programAddress,\n        memoProgram: MEMO_PROGRAM_ADDRESS,\n        remainingAccountsInfo: null,\n      }),\n    );\n  }\n\n  switch (positionMint.programAddress) {\n    case TOKEN_PROGRAM_ADDRESS:\n      instructions.push(\n        getClosePositionInstruction({\n          positionAuthority: authority,\n          position: positionAddress[0],\n          positionTokenAccount,\n          positionMint: positionMintAddress,\n          receiver: authority.address,\n        }),\n      );\n      break;\n    case TOKEN_2022_PROGRAM_ADDRESS:\n      instructions.push(\n        getClosePositionWithTokenExtensionsInstruction({\n          positionAuthority: authority,\n          position: positionAddress[0],\n          positionTokenAccount,\n          positionMint: positionMintAddress,\n          receiver: authority.address,\n          token2022Program: TOKEN_2022_PROGRAM_ADDRESS,\n        }),\n      );\n      break;\n    default:\n      throw new Error(\"Invalid token program\");\n  }\n\n  instructions.push(...cleanupInstructions);\n\n  return {\n    instructions,\n    quote,\n    feesQuote,\n    rewardsQuote,\n  };\n}\n","import type {\n  CollectFeesQuote,\n  CollectRewardsQuote,\n} from \"@orca-so/whirlpools-core\";\nimport {\n  collectFeesQuote,\n  collectRewardsQuote,\n  getTickArrayStartTickIndex,\n  getTickIndexInArray,\n} from \"@orca-so/whirlpools-core\";\nimport type {\n  Rpc,\n  GetAccountInfoApi,\n  Address,\n  IInstruction,\n  TransactionSigner,\n  GetMultipleAccountsApi,\n  GetMinimumBalanceForRentExemptionApi,\n  GetEpochInfoApi,\n} from \"@solana/web3.js\";\nimport { DEFAULT_ADDRESS, FUNDER } from \"./config\";\nimport {\n  fetchAllTickArray,\n  fetchPosition,\n  fetchWhirlpool,\n  getCollectFeesV2Instruction,\n  getCollectRewardV2Instruction,\n  getPositionAddress,\n  getTickArrayAddress,\n  getUpdateFeesAndRewardsInstruction,\n} from \"@orca-so/whirlpools-client\";\nimport { findAssociatedTokenPda } from \"@solana-program/token\";\nimport {\n  getCurrentTransferFee,\n  prepareTokenAccountsInstructions,\n} from \"./token\";\nimport { fetchAllMaybeMint } from \"@solana-program/token-2022\";\nimport { MEMO_PROGRAM_ADDRESS } from \"@solana-program/memo\";\nimport assert from \"assert\";\n\n// TODO: Transfer hook\n\n/**\n * Represents the instructions and quotes for harvesting a position.\n */\nexport type HarvestPositionInstructions = {\n  /** A breakdown of the fees owed to the position owner, detailing the amounts for token A (`fee_owed_a`) and token B (`fee_owed_b`). */\n  feesQuote: CollectFeesQuote;\n\n  /** A breakdown of the rewards owed, detailing up to three reward tokens (`reward_owed_1`, `reward_owed_2`, and `reward_owed_3`). */\n  rewardsQuote: CollectRewardsQuote;\n\n  /** A list of instructions required to harvest the position. */\n  instructions: IInstruction[];\n};\n\n/**\n * This function creates a set of instructions that collect any accumulated fees and rewards from a position.\n * The liquidity remains in place, and the position stays open.\n *\n * @param {SolanaRpc} rpc\n *    A Solana RPC client used to interact with the blockchain.\n * @param {Address} positionMintAddress\n *    The position mint address you want to harvest fees and rewards from.\n * @param {TransactionSigner} [authority=FUNDER]\n *    The account that authorizes the transaction. Defaults to a predefined funder.\n *\n * @returns {Promise<HarvestPositionInstructions>}\n *    A promise that resolves to an object containing the instructions, fees, and rewards quotes.\n * @example\n * import { harvestPositionInstructions, setWhirlpoolsConfig } from '@orca-so/whirlpools';\n * import { createSolanaRpc, devnet, address } from '@solana/web3.js';\n * import { loadWallet } from './utils';\n *\n * await setWhirlpoolsConfig('solanaDevnet');\n * const devnetRpc = createSolanaRpc(devnet('https://api.devnet.solana.com'));\n * const wallet = await loadWallet();\n * const positionMint = address(\"HqoV7Qv27REUtmd9UKSJGGmCRNx3531t33bDG1BUfo9K\");\n *\n * const { feesQuote, rewardsQuote, instructions } = await harvestPositionInstructions(\n *   devnetRpc,\n *   positionMint,\n *   wallet\n * );\n *\n * console.log(`Fees owed token A: ${feesQuote.feeOwedA}`);\n * console.log(`Rewards '1' owed: ${rewardsQuote.rewards[0].rewardsOwed}`);\n */\nexport async function harvestPositionInstructions(\n  rpc: Rpc<\n    GetAccountInfoApi &\n      GetMultipleAccountsApi &\n      GetMinimumBalanceForRentExemptionApi &\n      GetEpochInfoApi\n  >,\n  positionMintAddress: Address,\n  authority: TransactionSigner = FUNDER,\n): Promise<HarvestPositionInstructions> {\n  assert(\n    authority.address !== DEFAULT_ADDRESS,\n    \"Either supply an authority or set the default funder\",\n  );\n\n  const currentEpoch = await rpc.getEpochInfo().send();\n  const positionAddress = await getPositionAddress(positionMintAddress);\n  const position = await fetchPosition(rpc, positionAddress[0]);\n  const whirlpool = await fetchWhirlpool(rpc, position.data.whirlpool);\n  const [mintA, mintB, positionMint, ...rewardMints] = await fetchAllMaybeMint(\n    rpc,\n    [\n      whirlpool.data.tokenMintA,\n      whirlpool.data.tokenMintB,\n      positionMintAddress,\n      ...whirlpool.data.rewardInfos\n        .map((x) => x.mint)\n        .filter((x) => x !== DEFAULT_ADDRESS),\n    ],\n  );\n\n  assert(mintA.exists, \"Token A not found\");\n  assert(mintB.exists, \"Token B not found\");\n  assert(positionMint.exists, \"Position mint not found\");\n\n  const lowerTickArrayStartIndex = getTickArrayStartTickIndex(\n    position.data.tickLowerIndex,\n    whirlpool.data.tickSpacing,\n  );\n  const upperTickArrayStartIndex = getTickArrayStartTickIndex(\n    position.data.tickUpperIndex,\n    whirlpool.data.tickSpacing,\n  );\n\n  const [positionTokenAccount, lowerTickArrayAddress, upperTickArrayAddress] =\n    await Promise.all([\n      findAssociatedTokenPda({\n        owner: authority.address,\n        mint: positionMintAddress,\n        tokenProgram: positionMint.programAddress,\n      }).then((x) => x[0]),\n      getTickArrayAddress(whirlpool.address, lowerTickArrayStartIndex).then(\n        (x) => x[0],\n      ),\n      getTickArrayAddress(whirlpool.address, upperTickArrayStartIndex).then(\n        (x) => x[0],\n      ),\n    ]);\n\n  const [lowerTickArray, upperTickArray] = await fetchAllTickArray(rpc, [\n    lowerTickArrayAddress,\n    upperTickArrayAddress,\n  ]);\n\n  const lowerTick =\n    lowerTickArray.data.ticks[\n      getTickIndexInArray(\n        position.data.tickLowerIndex,\n        lowerTickArrayStartIndex,\n        whirlpool.data.tickSpacing,\n      )\n    ];\n  const upperTick =\n    upperTickArray.data.ticks[\n      getTickIndexInArray(\n        position.data.tickUpperIndex,\n        upperTickArrayStartIndex,\n        whirlpool.data.tickSpacing,\n      )\n    ];\n\n  const feesQuote = collectFeesQuote(\n    whirlpool.data,\n    position.data,\n    lowerTick,\n    upperTick,\n    getCurrentTransferFee(mintA, currentEpoch.epoch),\n    getCurrentTransferFee(mintB, currentEpoch.epoch),\n  );\n  const currentUnixTimestamp = BigInt(Math.floor(Date.now() / 1000));\n  const rewardsQuote = collectRewardsQuote(\n    whirlpool.data,\n    position.data,\n    lowerTick,\n    upperTick,\n    currentUnixTimestamp,\n    getCurrentTransferFee(rewardMints[0], currentEpoch.epoch),\n    getCurrentTransferFee(rewardMints[1], currentEpoch.epoch),\n    getCurrentTransferFee(rewardMints[2], currentEpoch.epoch),\n  );\n\n  const requiredMints: Set<Address> = new Set();\n  if (feesQuote.feeOwedA > 0n || feesQuote.feeOwedB > 0n) {\n    requiredMints.add(whirlpool.data.tokenMintA);\n    requiredMints.add(whirlpool.data.tokenMintB);\n  }\n\n  for (let i = 0; i < rewardsQuote.rewards.length; i++) {\n    if (rewardsQuote.rewards[i].rewardsOwed > 0n) {\n      requiredMints.add(whirlpool.data.rewardInfos[i].mint);\n    }\n  }\n\n  const { createInstructions, cleanupInstructions, tokenAccountAddresses } =\n    await prepareTokenAccountsInstructions(\n      rpc,\n      authority,\n      Array.from(requiredMints),\n    );\n\n  const instructions: IInstruction[] = [];\n  instructions.push(...createInstructions);\n\n  if (position.data.liquidity > 0n) {\n    instructions.push(\n      getUpdateFeesAndRewardsInstruction({\n        whirlpool: whirlpool.address,\n        position: positionAddress[0],\n        tickArrayLower: lowerTickArrayAddress,\n        tickArrayUpper: upperTickArrayAddress,\n      }),\n    );\n  }\n\n  if (feesQuote.feeOwedA > 0n || feesQuote.feeOwedB > 0n) {\n    instructions.push(\n      getCollectFeesV2Instruction({\n        whirlpool: whirlpool.address,\n        positionAuthority: authority,\n        position: positionAddress[0],\n        positionTokenAccount,\n        tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],\n        tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],\n        tokenVaultA: whirlpool.data.tokenVaultA,\n        tokenVaultB: whirlpool.data.tokenVaultB,\n        tokenMintA: whirlpool.data.tokenMintA,\n        tokenMintB: whirlpool.data.tokenMintB,\n        tokenProgramA: mintA.programAddress,\n        tokenProgramB: mintB.programAddress,\n        memoProgram: MEMO_PROGRAM_ADDRESS,\n        remainingAccountsInfo: null,\n      }),\n    );\n  }\n\n  for (let i = 0; i < rewardsQuote.rewards.length; i++) {\n    if (rewardsQuote.rewards[i].rewardsOwed === 0n) {\n      continue;\n    }\n    const rewardMint = rewardMints[i];\n    assert(rewardMint.exists, `Reward mint ${i} not found`);\n    instructions.push(\n      getCollectRewardV2Instruction({\n        whirlpool: whirlpool.address,\n        positionAuthority: authority,\n        position: positionAddress[0],\n        positionTokenAccount,\n        rewardOwnerAccount: tokenAccountAddresses[rewardMint.address],\n        rewardVault: whirlpool.data.rewardInfos[i].vault,\n        rewardIndex: i,\n        rewardMint: rewardMint.address,\n        rewardTokenProgram: rewardMint.programAddress,\n        memoProgram: MEMO_PROGRAM_ADDRESS,\n        remainingAccountsInfo: null,\n      }),\n    );\n  }\n\n  instructions.push(...cleanupInstructions);\n\n  return {\n    feesQuote,\n    rewardsQuote,\n    instructions,\n  };\n}\n","import type { Whirlpool } from \"@orca-so/whirlpools-client\";\nimport {\n  fetchAllMaybeTickArray,\n  fetchPosition,\n  fetchWhirlpool,\n  getIncreaseLiquidityV2Instruction,\n  getInitializeTickArrayInstruction,\n  getOpenPositionWithTokenExtensionsInstruction,\n  getPositionAddress,\n  getTickArrayAddress,\n  getTickArraySize,\n} from \"@orca-so/whirlpools-client\";\nimport type {\n  IncreaseLiquidityQuote,\n  TransferFee,\n} from \"@orca-so/whirlpools-core\";\nimport {\n  _MAX_TICK_INDEX,\n  _MIN_TICK_INDEX,\n  getFullRangeTickIndexes,\n  getTickArrayStartTickIndex,\n  increaseLiquidityQuote,\n  increaseLiquidityQuoteA,\n  increaseLiquidityQuoteB,\n  priceToTickIndex,\n  getInitializableTickIndex,\n  orderTickIndexes,\n} from \"@orca-so/whirlpools-core\";\nimport type {\n  Account,\n  Address,\n  GetAccountInfoApi,\n  GetEpochInfoApi,\n  GetMinimumBalanceForRentExemptionApi,\n  GetMultipleAccountsApi,\n  IInstruction,\n  Lamports,\n  Rpc,\n  TransactionSigner,\n} from \"@solana/web3.js\";\nimport { address, generateKeyPairSigner, lamports } from \"@solana/web3.js\";\nimport { fetchSysvarRent } from \"@solana/sysvars\";\nimport {\n  DEFAULT_ADDRESS,\n  FUNDER,\n  SLIPPAGE_TOLERANCE_BPS,\n  SPLASH_POOL_TICK_SPACING,\n} from \"./config\";\nimport {\n  ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  findAssociatedTokenPda,\n} from \"@solana-program/token\";\nimport {\n  getCurrentTransferFee,\n  prepareTokenAccountsInstructions,\n} from \"./token\";\nimport type { Mint } from \"@solana-program/token-2022\";\nimport {\n  fetchAllMint,\n  TOKEN_2022_PROGRAM_ADDRESS,\n} from \"@solana-program/token-2022\";\nimport { MEMO_PROGRAM_ADDRESS } from \"@solana-program/memo\";\nimport assert from \"assert\";\nimport { calculateMinimumBalanceForRentExemption } from \"./sysvar\";\n\n// TODO: allow specify number as well as bigint\n// TODO: transfer hook\n\n/**\n * Represents the parameters for increasing liquidity.\n * You must choose only one of the properties (`liquidity`, `tokenA`, or `tokenB`).\n * The SDK will compute the other two based on the input provided.\n */\nexport type IncreaseLiquidityQuoteParam =\n  | {\n      /** The amount of liquidity to increase. */\n      liquidity: bigint;\n    }\n  | {\n      /** The amount of Token A to add. */\n      tokenA: bigint;\n    }\n  | {\n      /** The amount of Token B to add. */\n      tokenB: bigint;\n    };\n\n/**\n * Represents the instructions and quote for increasing liquidity in a position.\n */\nexport type IncreaseLiquidityInstructions = {\n  /** The quote object with details about the increase in liquidity, including the liquidity delta, estimated tokens, and maximum token amounts based on slippage tolerance. */\n  quote: IncreaseLiquidityQuote;\n\n  /** List of Solana transaction instructions to execute. */\n  instructions: IInstruction[];\n};\n\nfunction getIncreaseLiquidityQuote(\n  param: IncreaseLiquidityQuoteParam,\n  pool: Whirlpool,\n  tickLowerIndex: number,\n  tickUpperIndex: number,\n  slippageToleranceBps: number,\n  transferFeeA: TransferFee | undefined,\n  transferFeeB: TransferFee | undefined,\n): IncreaseLiquidityQuote {\n  if (\"liquidity\" in param) {\n    return increaseLiquidityQuote(\n      param.liquidity,\n      slippageToleranceBps,\n      pool.sqrtPrice,\n      tickLowerIndex,\n      tickUpperIndex,\n      transferFeeA,\n      transferFeeB,\n    );\n  } else if (\"tokenA\" in param) {\n    return increaseLiquidityQuoteA(\n      param.tokenA,\n      slippageToleranceBps,\n      pool.sqrtPrice,\n      tickLowerIndex,\n      tickUpperIndex,\n      transferFeeA,\n      transferFeeB,\n    );\n  } else {\n    return increaseLiquidityQuoteB(\n      param.tokenB,\n      slippageToleranceBps,\n      pool.sqrtPrice,\n      tickLowerIndex,\n      tickUpperIndex,\n      transferFeeA,\n      transferFeeB,\n    );\n  }\n}\n\n/**\n * Generates instructions to increase liquidity for an existing position.\n *\n * @param {SolanaRpc} rpc - The Solana RPC client.\n * @param {Address} positionMintAddress - The mint address of the NFT that represents the position.\n * @param {IncreaseLiquidityQuoteParam} param - The parameters for adding liquidity. Can specify liquidity, Token A, or Token B amounts.\n * @param {number} [slippageToleranceBps=SLIPPAGE_TOLERANCE_BPS] - The maximum acceptable slippage, in basis points (BPS).\n * @param {TransactionSigner} [authority=FUNDER] - The account that authorizes the transaction.\n * @returns {Promise<IncreaseLiquidityInstructions>} A promise that resolves to an object containing instructions, quote, position mint address, and initialization costs for increasing liquidity.\n *\n * @example\n * import { increaseLiquidityInstructions, setWhirlpoolsConfig } from '@orca-so/whirlpools';\n * import { createSolanaRpc, devnet, address } from '@solana/web3.js';\n * import { loadWallet } from './utils';\n *\n * await setWhirlpoolsConfig('solanaDevnet');\n * const devnetRpc = createSolanaRpc(devnet('https://api.devnet.solana.com'));\n * const wallet = await loadWallet();\n * const positionMint = address(\"HqoV7Qv27REUtmd9UKSJGGmCRNx3531t33bDG1BUfo9K\");\n * const param = { tokenA: 10n };\n * const { quote, instructions } = await increaseLiquidityInstructions(\n *   devnetRpc,\n *   positionMint,\n *   param,\n *   100,\n *   wallet\n * );\n *\n * console.log(`Quote token max B: ${quote.tokenEstB}`);\n */\nexport async function increaseLiquidityInstructions(\n  rpc: Rpc<\n    GetAccountInfoApi &\n      GetMultipleAccountsApi &\n      GetMinimumBalanceForRentExemptionApi &\n      GetEpochInfoApi\n  >,\n  positionMintAddress: Address,\n  param: IncreaseLiquidityQuoteParam,\n  slippageToleranceBps: number = SLIPPAGE_TOLERANCE_BPS,\n  authority: TransactionSigner = FUNDER,\n): Promise<IncreaseLiquidityInstructions> {\n  assert(\n    authority.address !== DEFAULT_ADDRESS,\n    \"Either supply the authority or set the default funder\",\n  );\n\n  const positionAddress = await getPositionAddress(positionMintAddress);\n  const position = await fetchPosition(rpc, positionAddress[0]);\n  const whirlpool = await fetchWhirlpool(rpc, position.data.whirlpool);\n\n  const currentEpoch = await rpc.getEpochInfo().send();\n  const [mintA, mintB, positionMint] = await fetchAllMint(rpc, [\n    whirlpool.data.tokenMintA,\n    whirlpool.data.tokenMintB,\n    positionMintAddress,\n  ]);\n  const transferFeeA = getCurrentTransferFee(mintA, currentEpoch.epoch);\n  const transferFeeB = getCurrentTransferFee(mintB, currentEpoch.epoch);\n\n  const quote = getIncreaseLiquidityQuote(\n    param,\n    whirlpool.data,\n    position.data.tickLowerIndex,\n    position.data.tickUpperIndex,\n    slippageToleranceBps,\n    transferFeeA,\n    transferFeeB,\n  );\n  const instructions: IInstruction[] = [];\n\n  const lowerTickArrayStartIndex = getTickArrayStartTickIndex(\n    position.data.tickLowerIndex,\n    whirlpool.data.tickSpacing,\n  );\n  const upperTickArrayStartIndex = getTickArrayStartTickIndex(\n    position.data.tickUpperIndex,\n    whirlpool.data.tickSpacing,\n  );\n\n  const [positionTokenAccount, tickArrayLower, tickArrayUpper] =\n    await Promise.all([\n      findAssociatedTokenPda({\n        owner: authority.address,\n        mint: positionMintAddress,\n        tokenProgram: positionMint.programAddress,\n      }).then((x) => x[0]),\n      getTickArrayAddress(whirlpool.address, lowerTickArrayStartIndex).then(\n        (x) => x[0],\n      ),\n      getTickArrayAddress(whirlpool.address, upperTickArrayStartIndex).then(\n        (x) => x[0],\n      ),\n    ]);\n\n  const { createInstructions, cleanupInstructions, tokenAccountAddresses } =\n    await prepareTokenAccountsInstructions(rpc, authority, {\n      [whirlpool.data.tokenMintA]: quote.tokenMaxA,\n      [whirlpool.data.tokenMintB]: quote.tokenMaxB,\n    });\n\n  instructions.push(...createInstructions);\n\n  // Since position exists tick arrays must also already exist\n\n  instructions.push(\n    getIncreaseLiquidityV2Instruction({\n      whirlpool: whirlpool.address,\n      positionAuthority: authority,\n      position: position.address,\n      positionTokenAccount,\n      tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],\n      tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],\n      tokenVaultA: whirlpool.data.tokenVaultA,\n      tokenVaultB: whirlpool.data.tokenVaultB,\n      tokenMintA: whirlpool.data.tokenMintA,\n      tokenMintB: whirlpool.data.tokenMintB,\n      tokenProgramA: mintA.programAddress,\n      tokenProgramB: mintB.programAddress,\n      tickArrayLower,\n      tickArrayUpper,\n      liquidityAmount: quote.liquidityDelta,\n      tokenMaxA: quote.tokenMaxA,\n      tokenMaxB: quote.tokenMaxB,\n      memoProgram: MEMO_PROGRAM_ADDRESS,\n      remainingAccountsInfo: null,\n    }),\n  );\n\n  instructions.push(...cleanupInstructions);\n\n  return {\n    quote,\n    instructions,\n  };\n}\n\n/**\n * Represents the instructions and quote for opening a position.\n * Extends IncreaseLiquidityInstructions with additional fields for position initialization.\n */\nexport type OpenPositionInstructions = IncreaseLiquidityInstructions & {\n  /** The initialization cost for opening the position in lamports. */\n  initializationCost: Lamports;\n\n  /** The mint address of the position NFT. */\n  positionMint: Address;\n};\n\nasync function internalOpenPositionInstructions(\n  rpc: Rpc<\n    GetAccountInfoApi &\n      GetMultipleAccountsApi &\n      GetMinimumBalanceForRentExemptionApi &\n      GetEpochInfoApi\n  >,\n  whirlpool: Account<Whirlpool>,\n  param: IncreaseLiquidityQuoteParam,\n  lowerTickIndex: number,\n  upperTickIndex: number,\n  mintA: Account<Mint>,\n  mintB: Account<Mint>,\n  slippageToleranceBps: number = SLIPPAGE_TOLERANCE_BPS,\n  funder: TransactionSigner = FUNDER,\n): Promise<OpenPositionInstructions> {\n  assert(\n    funder.address !== DEFAULT_ADDRESS,\n    \"Either supply a funder or set the default funder\",\n  );\n  const instructions: IInstruction[] = [];\n\n  const rent = await fetchSysvarRent(rpc);\n  let nonRefundableRent: bigint = 0n;\n\n  const tickRange = orderTickIndexes(lowerTickIndex, upperTickIndex);\n\n  const initializableLowerTickIndex = getInitializableTickIndex(\n    tickRange.tickLowerIndex,\n    whirlpool.data.tickSpacing,\n    false,\n  );\n  const initializableUpperTickIndex = getInitializableTickIndex(\n    tickRange.tickUpperIndex,\n    whirlpool.data.tickSpacing,\n    true,\n  );\n\n  const currentEpoch = await rpc.getEpochInfo().send();\n  const transferFeeA = getCurrentTransferFee(mintA, currentEpoch.epoch);\n  const transferFeeB = getCurrentTransferFee(mintB, currentEpoch.epoch);\n\n  const quote = getIncreaseLiquidityQuote(\n    param,\n    whirlpool.data,\n    initializableLowerTickIndex,\n    initializableUpperTickIndex,\n    slippageToleranceBps,\n    transferFeeA,\n    transferFeeB,\n  );\n\n  const positionMint = await generateKeyPairSigner();\n\n  const lowerTickArrayIndex = getTickArrayStartTickIndex(\n    initializableLowerTickIndex,\n    whirlpool.data.tickSpacing,\n  );\n  const upperTickArrayIndex = getTickArrayStartTickIndex(\n    initializableUpperTickIndex,\n    whirlpool.data.tickSpacing,\n  );\n\n  const [\n    positionAddress,\n    positionTokenAccount,\n    lowerTickArrayAddress,\n    upperTickArrayAddress,\n  ] = await Promise.all([\n    getPositionAddress(positionMint.address),\n    findAssociatedTokenPda({\n      owner: funder.address,\n      mint: positionMint.address,\n      tokenProgram: TOKEN_2022_PROGRAM_ADDRESS,\n    }).then((x) => x[0]),\n    getTickArrayAddress(whirlpool.address, lowerTickArrayIndex).then(\n      (x) => x[0],\n    ),\n    getTickArrayAddress(whirlpool.address, upperTickArrayIndex).then(\n      (x) => x[0],\n    ),\n  ]);\n\n  const { createInstructions, cleanupInstructions, tokenAccountAddresses } =\n    await prepareTokenAccountsInstructions(rpc, funder, {\n      [whirlpool.data.tokenMintA]: quote.tokenMaxA,\n      [whirlpool.data.tokenMintB]: quote.tokenMaxB,\n    });\n\n  instructions.push(...createInstructions);\n\n  const [lowerTickArray, upperTickArray] = await fetchAllMaybeTickArray(rpc, [\n    lowerTickArrayAddress,\n    upperTickArrayAddress,\n  ]);\n\n  if (!lowerTickArray.exists) {\n    instructions.push(\n      getInitializeTickArrayInstruction({\n        whirlpool: whirlpool.address,\n        funder,\n        tickArray: lowerTickArrayAddress,\n        startTickIndex: lowerTickArrayIndex,\n      }),\n    );\n    nonRefundableRent += calculateMinimumBalanceForRentExemption(\n      rent,\n      getTickArraySize(),\n    );\n  }\n\n  if (!upperTickArray.exists && lowerTickArrayIndex !== upperTickArrayIndex) {\n    instructions.push(\n      getInitializeTickArrayInstruction({\n        whirlpool: whirlpool.address,\n        funder,\n        tickArray: upperTickArrayAddress,\n        startTickIndex: upperTickArrayIndex,\n      }),\n    );\n    nonRefundableRent += calculateMinimumBalanceForRentExemption(\n      rent,\n      getTickArraySize(),\n    );\n  }\n\n  instructions.push(\n    getOpenPositionWithTokenExtensionsInstruction({\n      funder,\n      owner: funder.address,\n      position: positionAddress[0],\n      positionMint,\n      positionTokenAccount,\n      whirlpool: whirlpool.address,\n      associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n      tickLowerIndex: initializableLowerTickIndex,\n      tickUpperIndex: initializableUpperTickIndex,\n      token2022Program: TOKEN_2022_PROGRAM_ADDRESS,\n      metadataUpdateAuth: address(\n        \"3axbTs2z5GBy6usVbNVoqEgZMng3vZvMnAoX29BFfwhr\",\n      ),\n      withTokenMetadataExtension: true,\n    }),\n  );\n\n  instructions.push(\n    getIncreaseLiquidityV2Instruction({\n      whirlpool: whirlpool.address,\n      positionAuthority: funder,\n      position: positionAddress[0],\n      positionTokenAccount,\n      tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],\n      tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],\n      tokenVaultA: whirlpool.data.tokenVaultA,\n      tokenVaultB: whirlpool.data.tokenVaultB,\n      tokenMintA: whirlpool.data.tokenMintA,\n      tokenMintB: whirlpool.data.tokenMintB,\n      tokenProgramA: mintA.programAddress,\n      tokenProgramB: mintB.programAddress,\n      tickArrayLower: lowerTickArrayAddress,\n      tickArrayUpper: upperTickArrayAddress,\n      liquidityAmount: quote.liquidityDelta,\n      tokenMaxA: quote.tokenMaxA,\n      tokenMaxB: quote.tokenMaxB,\n      memoProgram: MEMO_PROGRAM_ADDRESS,\n      remainingAccountsInfo: null,\n    }),\n  );\n\n  instructions.push(...cleanupInstructions);\n\n  return {\n    instructions,\n    quote,\n    positionMint: positionMint.address,\n    initializationCost: lamports(nonRefundableRent),\n  };\n}\n\n/**\n * Opens a full-range position for a pool, typically used for Splash Pools or other full-range liquidity provisioning.\n *\n * @param {SolanaRpc} rpc - The Solana RPC client.\n * @param {Address} poolAddress - The address of the liquidity pool.\n * @param {IncreaseLiquidityQuoteParam} param - The parameters for adding liquidity, where one of `liquidity`, `tokenA`, or `tokenB` must be specified. The SDK will compute the others.\n * @param {number} [slippageToleranceBps=SLIPPAGE_TOLERANCE_BPS] - The maximum acceptable slippage, in basis points (BPS).\n * @param {TransactionSigner} [funder=FUNDER] - The account funding the transaction.\n * @returns {Promise<OpenPositionInstructions>} A promise that resolves to an object containing the instructions, quote, position mint address, and initialization costs for increasing liquidity.\n *\n * @example\n * import { openFullRangePositionInstructions, setWhirlpoolsConfig } from '@orca-so/whirlpools';\n * import { generateKeyPairSigner, createSolanaRpc, devnet, address } from '@solana/web3.js';\n *\n * await setWhirlpoolsConfig('solanaDevnet');\n * const devnetRpc = createSolanaRpc(devnet('https://api.devnet.solana.com'));\n * const wallet = await generateKeyPairSigner(); // CAUTION: This wallet is not persistent.\n *\n * const whirlpoolAddress = address(\"POOL_ADDRESS\");\n *\n * const param = { tokenA: 1_000_000n };\n *\n * const { quote, instructions, initializationCost, positionMint } = await openFullRangePositionInstructions(\n *   devnetRpc,\n *   whirlpoolAddress,\n *   param,\n *   100,\n *   wallet\n * );\n */\nexport async function openFullRangePositionInstructions(\n  rpc: Rpc<\n    GetAccountInfoApi &\n      GetMultipleAccountsApi &\n      GetMinimumBalanceForRentExemptionApi &\n      GetEpochInfoApi\n  >,\n  poolAddress: Address,\n  param: IncreaseLiquidityQuoteParam,\n  slippageToleranceBps: number = SLIPPAGE_TOLERANCE_BPS,\n  funder: TransactionSigner = FUNDER,\n): Promise<OpenPositionInstructions> {\n  const whirlpool = await fetchWhirlpool(rpc, poolAddress);\n  const tickRange = getFullRangeTickIndexes(whirlpool.data.tickSpacing);\n  const [mintA, mintB] = await fetchAllMint(rpc, [\n    whirlpool.data.tokenMintA,\n    whirlpool.data.tokenMintB,\n  ]);\n  return internalOpenPositionInstructions(\n    rpc,\n    whirlpool,\n    param,\n    tickRange.tickLowerIndex,\n    tickRange.tickUpperIndex,\n    mintA,\n    mintB,\n    slippageToleranceBps,\n    funder,\n  );\n}\n\n/**\n * Opens a new position in a concentrated liquidity pool within a specific price range.\n * This function allows you to provide liquidity for the specified range of prices and adjust liquidity parameters accordingly.\n *\n * **Note:** This function cannot be used with Splash Pools.\n *\n * @param {SolanaRpc} rpc - A Solana RPC client used to interact with the blockchain.\n * @param {Address} poolAddress - The address of the liquidity pool where the position will be opened.\n * @param {IncreaseLiquidityQuoteParam} param - The parameters for increasing liquidity, where you must choose one (`liquidity`, `tokenA`, or `tokenB`). The SDK will compute the other two.\n * @param {number} lowerPrice - The lower bound of the price range for the position.\n * @param {number} upperPrice - The upper bound of the price range for the position.\n * @param {number} [slippageToleranceBps=SLIPPAGE_TOLERANCE_BPS] - The slippage tolerance for adding liquidity, in basis points (BPS).\n * @param {TransactionSigner} [funder=FUNDER] - The account funding the transaction.\n *\n * @returns {Promise<OpenPositionInstructions>} A promise that resolves to an object containing instructions, quote, position mint address, and initialization costs for increasing liquidity.\n *\n * @example\n * import { openPositionInstructions, setWhirlpoolsConfig } from '@orca-so/whirlpools';\n * import { generateKeyPairSigner, createSolanaRpc, devnet, address } from '@solana/web3.js';\n *\n * await setWhirlpoolsConfig('solanaDevnet');\n * const devnetRpc = createSolanaRpc(devnet('https://api.devnet.solana.com'));\n * const wallet = await generateKeyPairSigner(); // CAUTION: This wallet is not persistent.\n *\n * const whirlpoolAddress = address(\"POOL_ADDRESS\");\n *\n * const param = { tokenA: 1_000_000n };\n * const lowerPrice = 0.00005;\n * const upperPrice = 0.00015;\n *\n * const { quote, instructions, initializationCost, positionMint } = await openPositionInstructions(\n *   devnetRpc,\n *   whirlpoolAddress,\n *   param,\n *   lowerPrice,\n *   upperPrice,\n *   100,\n *   wallet\n * );\n */\nexport async function openPositionInstructions(\n  rpc: Rpc<\n    GetAccountInfoApi &\n      GetMultipleAccountsApi &\n      GetMinimumBalanceForRentExemptionApi &\n      GetEpochInfoApi\n  >,\n  poolAddress: Address,\n  param: IncreaseLiquidityQuoteParam,\n  lowerPrice: number,\n  upperPrice: number,\n  slippageToleranceBps: number = SLIPPAGE_TOLERANCE_BPS,\n  funder: TransactionSigner = FUNDER,\n): Promise<OpenPositionInstructions> {\n  const whirlpool = await fetchWhirlpool(rpc, poolAddress);\n  assert(\n    whirlpool.data.tickSpacing !== SPLASH_POOL_TICK_SPACING,\n    \"Splash pools only support full range positions\",\n  );\n  const [mintA, mintB] = await fetchAllMint(rpc, [\n    whirlpool.data.tokenMintA,\n    whirlpool.data.tokenMintB,\n  ]);\n  const decimalsA = mintA.data.decimals;\n  const decimalsB = mintB.data.decimals;\n  const lowerTickIndex = priceToTickIndex(lowerPrice, decimalsA, decimalsB);\n  const upperTickIndex = priceToTickIndex(upperPrice, decimalsA, decimalsB);\n  return internalOpenPositionInstructions(\n    rpc,\n    whirlpool,\n    param,\n    lowerTickIndex,\n    upperTickIndex,\n    mintA,\n    mintB,\n    slippageToleranceBps,\n    funder,\n  );\n}\n","import type { Whirlpool } from \"@orca-so/whirlpools-client\";\nimport {\n  getFeeTierAddress,\n  getWhirlpoolAddress,\n  fetchWhirlpoolsConfig,\n  fetchFeeTier,\n  fetchMaybeWhirlpool,\n  fetchAllMaybeWhirlpool,\n  fetchAllFeeTierWithFilter,\n  feeTierWhirlpoolsConfigFilter,\n} from \"@orca-so/whirlpools-client\";\nimport type {\n  Rpc,\n  GetAccountInfoApi,\n  GetMultipleAccountsApi,\n  Address,\n  GetProgramAccountsApi,\n} from \"@solana/web3.js\";\nimport { SPLASH_POOL_TICK_SPACING, WHIRLPOOLS_CONFIG_ADDRESS } from \"./config\";\nimport { orderMints } from \"./token\";\nimport { sqrtPriceToPrice } from \"@orca-so/whirlpools-core\";\nimport { fetchAllMint } from \"@solana-program/token\";\n\n/**\n * Type representing a pool that is not yet initialized.\n */\nexport type InitializablePool = {\n  /** Indicates the pool is not initialized. */\n  initialized: false;\n} & Pick<\n  Whirlpool,\n  | \"whirlpoolsConfig\"\n  | \"tickSpacing\"\n  | \"feeRate\"\n  | \"protocolFeeRate\"\n  | \"tokenMintA\"\n  | \"tokenMintB\"\n>;\n\n/**\n * Type representing a pool that has been initialized.\n * Extends the `Whirlpool` type, inheriting all its properties.\n */\nexport type InitializedPool = {\n  /** Indicates the pool is initialized. */\n  initialized: true;\n  price: number;\n} & Whirlpool;\n\n/**\n * Combined type representing both initialized and uninitialized pools.\n */\nexport type PoolInfo = (InitializablePool | InitializedPool) & {\n  /** The address of the pool. */\n  address: Address;\n};\n\n/**\n * Fetches the details of a specific Splash Pool.\n *\n * @param {SolanaRpc} rpc - The Solana RPC client.\n * @param {Address} tokenMintOne - The first token mint address in the pool.\n * @param {Address} tokenMintTwo - The second token mint address in the pool.\n * @returns {Promise<PoolInfo>} - A promise that resolves to the pool information, which includes whether the pool is initialized or not.\n *\n * @example\n * import { fetchSplashPool, setWhirlpoolsConfig } from '@orca-so/whirlpools';\n * import { createSolanaRpc, devnet, address } from '@solana/web3.js';\n *\n * await setWhirlpoolsConfig('solanaDevnet');\n * const devnetRpc = createSolanaRpc(devnet('https://api.devnet.solana.com'));\n * const tokenMintOne = address(\"So11111111111111111111111111111111111111112\");\n * const tokenMintTwo = address(\"BRjpCHtyQLNCo8gqRUr8jtdAj5AjPYQaoqbvcZiHok1k\"); //devUSDC\n *\n * const poolInfo = await fetchSplashPool(\n *   devnetRpc,\n *   tokenMintOne,\n *   tokenMintTwo\n * );\n *\n * if (poolInfo.initialized) {\n *   console.log(\"Pool is initialized:\", poolInfo);\n * } else {\n *   console.log(\"Pool is not initialized:\", poolInfo);\n * };\n */\nexport async function fetchSplashPool(\n  rpc: Rpc<GetAccountInfoApi & GetMultipleAccountsApi>,\n  tokenMintOne: Address,\n  tokenMintTwo: Address,\n): Promise<PoolInfo> {\n  return fetchConcentratedLiquidityPool(\n    rpc,\n    tokenMintOne,\n    tokenMintTwo,\n    SPLASH_POOL_TICK_SPACING,\n  );\n}\n\n/**\n * Fetches the details of a specific Concentrated Liquidity Pool.\n *\n * @param {SolanaRpc} rpc - The Solana RPC client.\n * @param {Address} tokenMintOne - The first token mint address in the pool.\n * @param {Address} tokenMintTwo - The second token mint address in the pool.\n * @param {number} tickSpacing - The tick spacing of the pool.\n * @returns {Promise<PoolInfo>} - A promise that resolves to the pool information, which includes whether the pool is initialized or not.\n *\n * @example\n * import { fetchConcentratedLiquidityPool, setWhirlpoolsConfig } from '@orca-so/whirlpools';\n * import { createSolanaRpc, devnet, address } from '@solana/web3.js';\n *\n * await setWhirlpoolsConfig('solanaDevnet');\n * const devnetRpc = createSolanaRpc(devnet('https://api.devnet.solana.com'));\n *\n * const tokenMintOne = address(\"So11111111111111111111111111111111111111112\");\n * const tokenMintTwo = address(\"BRjpCHtyQLNCo8gqRUr8jtdAj5AjPYQaoqbvcZiHok1k\");\n * const tickSpacing = 64;\n *\n * const poolInfo = await fetchConcentratedLiquidityPool(\n *   devnetRpc,\n *   tokenMintOne,\n *   tokenMintTwo,\n *   tickSpacing\n * );\n *\n * if (poolInfo.initialized) {\n *   console.log(\"Pool is initialized:\", poolInfo);\n * } else {\n *   console.log(\"Pool is not initialized:\", poolInfo);\n * };\n */\nexport async function fetchConcentratedLiquidityPool(\n  rpc: Rpc<GetAccountInfoApi & GetMultipleAccountsApi>,\n  tokenMintOne: Address,\n  tokenMintTwo: Address,\n  tickSpacing: number,\n): Promise<PoolInfo> {\n  const [tokenMintA, tokenMintB] = orderMints(tokenMintOne, tokenMintTwo);\n  const feeTierAddress = await getFeeTierAddress(\n    WHIRLPOOLS_CONFIG_ADDRESS,\n    tickSpacing,\n  ).then((x) => x[0]);\n  const poolAddress = await getWhirlpoolAddress(\n    WHIRLPOOLS_CONFIG_ADDRESS,\n    tokenMintA,\n    tokenMintB,\n    tickSpacing,\n  ).then((x) => x[0]);\n\n  // TODO: this is multiple rpc calls. Can we do it in one?\n  const [configAccount, feeTierAccount, poolAccount] = await Promise.all([\n    fetchWhirlpoolsConfig(rpc, WHIRLPOOLS_CONFIG_ADDRESS),\n    fetchFeeTier(rpc, feeTierAddress),\n    fetchMaybeWhirlpool(rpc, poolAddress),\n  ]);\n\n  const [mintA, mintB] = await fetchAllMint(rpc, [tokenMintA, tokenMintB]);\n\n  if (poolAccount.exists) {\n    const poolPrice = sqrtPriceToPrice(\n      poolAccount.data.sqrtPrice,\n      mintA.data.decimals,\n      mintB.data.decimals,\n    );\n    return {\n      initialized: true,\n      address: poolAddress,\n      price: poolPrice,\n      ...poolAccount.data,\n    };\n  } else {\n    return {\n      initialized: false,\n      address: poolAddress,\n      whirlpoolsConfig: WHIRLPOOLS_CONFIG_ADDRESS,\n      tickSpacing,\n      feeRate: feeTierAccount.data.defaultFeeRate,\n      protocolFeeRate: configAccount.data.defaultProtocolFeeRate,\n      tokenMintA: tokenMintA,\n      tokenMintB: tokenMintB,\n    };\n  }\n}\n\n/**\n * Fetches all possible liquidity pools between two token mints in Orca Whirlpools.\n * If a pool does not exist, it creates a placeholder account for the uninitialized pool with default data\n *\n * @param {SolanaRpc} rpc - The Solana RPC client.\n * @param {Address} tokenMintOne - The first token mint address in the pool.\n * @param {Address} tokenMintTwo - The second token mint address in the pool.\n * @returns {Promise<PoolInfo[]>} - A promise that resolves to an array of pool information for each pool between the two tokens.\n *\n * @example\n * import { fetchWhirlpoolsByTokenPair, setWhirlpoolsConfig } from '@orca-so/whirlpools';\n * import { createSolanaRpc, devnet, address } from '@solana/web3.js';\n *\n * await setWhirlpoolsConfig('solanaDevnet');\n * const devnetRpc = createSolanaRpc(devnet('https://api.devnet.solana.com'));\n *\n * const tokenMintOne = address(\"So11111111111111111111111111111111111111112\");\n * const tokenMintTwo = address(\"BRjpCHtyQLNCo8gqRUr8jtdAj5AjPYQaoqbvcZiHok1k\");\n *\n * const poolInfos = await fetchWhirlpoolsByTokenPair(\n *   devnetRpc,\n *   tokenMintOne,\n *   tokenMintTwo\n * );\n *\n * poolInfos.forEach((poolInfo) => {\n *   if (poolInfo.initialized) {\n *     console.log(\"Pool is initialized:\", poolInfo);\n *   } else {\n *     console.log(\"Pool is not initialized:\", poolInfo);\n *   }\n * });\n */\nexport async function fetchWhirlpoolsByTokenPair(\n  rpc: Rpc<GetAccountInfoApi & GetMultipleAccountsApi & GetProgramAccountsApi>,\n  tokenMintOne: Address,\n  tokenMintTwo: Address,\n): Promise<PoolInfo[]> {\n  const [tokenMintA, tokenMintB] = orderMints(tokenMintOne, tokenMintTwo);\n  const feeTierAccounts = await fetchAllFeeTierWithFilter(\n    rpc,\n    feeTierWhirlpoolsConfigFilter(WHIRLPOOLS_CONFIG_ADDRESS),\n  );\n\n  const supportedTickSpacings = feeTierAccounts.map((x) => x.data.tickSpacing);\n\n  const poolAddresses = await Promise.all(\n    supportedTickSpacings.map((x) =>\n      getWhirlpoolAddress(\n        WHIRLPOOLS_CONFIG_ADDRESS,\n        tokenMintA,\n        tokenMintB,\n        x,\n      ).then((x) => x[0]),\n    ),\n  );\n\n  // TODO: this is multiple rpc calls. Can we do it in one?\n  const [configAccount, poolAccounts] = await Promise.all([\n    fetchWhirlpoolsConfig(rpc, WHIRLPOOLS_CONFIG_ADDRESS),\n    fetchAllMaybeWhirlpool(rpc, poolAddresses),\n  ]);\n\n  const [mintA, mintB] = await fetchAllMint(rpc, [tokenMintA, tokenMintB]);\n\n  const pools: PoolInfo[] = [];\n  for (let i = 0; i < supportedTickSpacings.length; i++) {\n    const tickSpacing = supportedTickSpacings[i];\n    const feeTierAccount = feeTierAccounts[i];\n    const poolAccount = poolAccounts[i];\n    const poolAddress = poolAddresses[i];\n\n    if (poolAccount.exists) {\n      const poolPrice = sqrtPriceToPrice(\n        poolAccount.data.sqrtPrice,\n        mintA.data.decimals,\n        mintB.data.decimals,\n      );\n      pools.push({\n        initialized: true,\n        address: poolAddress,\n        price: poolPrice,\n        ...poolAccount.data,\n      });\n    } else {\n      pools.push({\n        initialized: false,\n        address: poolAddress,\n        whirlpoolsConfig: WHIRLPOOLS_CONFIG_ADDRESS,\n        tickSpacing,\n        feeRate: feeTierAccount.data.defaultFeeRate,\n        protocolFeeRate: configAccount.data.defaultProtocolFeeRate,\n        tokenMintA,\n        tokenMintB,\n      });\n    }\n  }\n  return pools;\n}\n","import type { Position, PositionBundle } from \"@orca-so/whirlpools-client\";\nimport {\n  fetchAllMaybePosition,\n  fetchAllMaybePositionBundle,\n  fetchAllPosition,\n  fetchAllPositionWithFilter,\n  getBundledPositionAddress,\n  getPositionAddress,\n  getPositionBundleAddress,\n  positionWhirlpoolFilter,\n} from \"@orca-so/whirlpools-client\";\nimport { _POSITION_BUNDLE_SIZE } from \"@orca-so/whirlpools-core\";\nimport { getTokenDecoder, TOKEN_PROGRAM_ADDRESS } from \"@solana-program/token\";\nimport { TOKEN_2022_PROGRAM_ADDRESS } from \"@solana-program/token-2022\";\nimport type {\n  Account,\n  Address,\n  GetMultipleAccountsApi,\n  GetProgramAccountsApi,\n  GetTokenAccountsByOwnerApi,\n  Rpc,\n} from \"@solana/web3.js\";\nimport { getBase64Encoder } from \"@solana/web3.js\";\n\n/**\n * Represents a Position account.\n */\nexport type HydratedPosition = Account<Position> & {\n  isPositionBundle: false;\n};\n\n/**\n * Represents a Position Bundle account including its associated positions.\n */\nexport type HydratedPositionBundle = Account<PositionBundle> & {\n  positions: Account<Position>[];\n  isPositionBundle: true;\n};\n\n/**\n * Represents either a Position or Position Bundle account.\n */\nexport type PositionOrBundle = HydratedPosition | HydratedPositionBundle;\n\n/**\n * Represents a decoded Position or Position Bundle account.\n * Includes the token program address associated with the position.\n */\nexport type PositionData = PositionOrBundle & {\n  /** The token program associated with the position (either TOKEN_PROGRAM_ADDRESS or TOKEN_2022_PROGRAM_ADDRESS). */\n  tokenProgram: Address;\n};\n\nfunction getPositionInBundleAddresses(\n  positionBundle: PositionBundle,\n): Promise<Address>[] {\n  const buffer = Buffer.from(positionBundle.positionBitmap);\n  const positions: Promise<Address>[] = [];\n  for (let i = 0; i < _POSITION_BUNDLE_SIZE(); i++) {\n    const byteIndex = Math.floor(i / 8);\n    const bitIndex = i % 8;\n    if (buffer[byteIndex] & (1 << bitIndex)) {\n      positions.push(\n        getBundledPositionAddress(positionBundle.positionBundleMint, i).then(\n          (x) => x[0],\n        ),\n      );\n    }\n  }\n  return positions;\n}\n\n/**\n * Fetches all positions owned by a given wallet in the Orca Whirlpools.\n * It looks for token accounts owned by the wallet using both the TOKEN_PROGRAM_ADDRESS and TOKEN_2022_PROGRAM_ADDRESS.\n * For token accounts holding exactly 1 token (indicating a position or bundle), it fetches the corresponding position addresses,\n * decodes the accounts, and returns an array of position or bundle data.\n *\n * @param {SolanaRpc} rpc - The Solana RPC client used to fetch token accounts and multiple accounts.\n * @param {Address} owner - The wallet address whose positions you want to fetch.\n * @returns {Promise<PositionData[]>} - A promise that resolves to an array of decoded position data for the given owner.\n *\n * @example\n * import { fetchPositionsForOwner } from '@orca-so/whirlpools';\n * import { generateKeyPairSigner, createSolanaRpc, devnet } from '@solana/web3.js';\n *\n * const devnetRpc = createSolanaRpc(devnet('https://api.devnet.solana.com'));\n * const wallet = address(\"INSERT_WALLET_ADDRESS\");\n *\n * const positions = await fetchPositionsForOwner(devnetRpc, wallet.address);\n */\nexport async function fetchPositionsForOwner(\n  rpc: Rpc<GetTokenAccountsByOwnerApi & GetMultipleAccountsApi>,\n  owner: Address,\n): Promise<PositionData[]> {\n  const [tokenAccounts, token2022Accounts] = await Promise.all([\n    rpc\n      .getTokenAccountsByOwner(\n        owner,\n        { programId: TOKEN_PROGRAM_ADDRESS },\n        { encoding: \"base64\" },\n      )\n      .send(),\n    rpc\n      .getTokenAccountsByOwner(\n        owner,\n        { programId: TOKEN_2022_PROGRAM_ADDRESS },\n        { encoding: \"base64\" },\n      )\n      .send(),\n  ]);\n\n  const encoder = getBase64Encoder();\n  const decoder = getTokenDecoder();\n\n  const potentialTokens = [...tokenAccounts.value, ...token2022Accounts.value]\n    .map((x) => ({\n      ...decoder.decode(encoder.encode(x.account.data[0])),\n      tokenProgram: x.account.owner,\n    }))\n    .filter((x) => x.amount === 1n);\n\n  const positionAddresses = await Promise.all(\n    potentialTokens.map((x) => getPositionAddress(x.mint).then((x) => x[0])),\n  );\n\n  const positionBundleAddresses = await Promise.all(\n    potentialTokens.map((x) =>\n      getPositionBundleAddress(x.mint).then((x) => x[0]),\n    ),\n  );\n\n  // FIXME: need to batch if more than 100 position bundles?\n  const [positions, positionBundles] = await Promise.all([\n    fetchAllMaybePosition(rpc, positionAddresses),\n    fetchAllMaybePositionBundle(rpc, positionBundleAddresses),\n  ]);\n\n  const bundledPositionAddresses = await Promise.all(\n    positionBundles\n      .filter((x) => x.exists)\n      .flatMap((x) => getPositionInBundleAddresses(x.data)),\n  );\n\n  const bundledPositions = await fetchAllPosition(\n    rpc,\n    bundledPositionAddresses,\n  );\n  const bundledPositionMap = bundledPositions.reduce((acc, x) => {\n    const current = acc.get(x.data.positionMint) ?? [];\n    return acc.set(x.data.positionMint, [...current, x]);\n  }, new Map<Address, Account<Position>[]>());\n\n  const positionsOrBundles: PositionData[] = [];\n\n  for (let i = 0; i < potentialTokens.length; i++) {\n    const position = positions[i];\n    const positionBundle = positionBundles[i];\n    const token = potentialTokens[i];\n\n    if (position.exists) {\n      positionsOrBundles.push({\n        ...position,\n        tokenProgram: token.tokenProgram,\n        isPositionBundle: false,\n      });\n    }\n\n    if (positionBundle.exists) {\n      const positions =\n        bundledPositionMap.get(positionBundle.data.positionBundleMint) ?? [];\n      positionsOrBundles.push({\n        ...positionBundle,\n        positions,\n        tokenProgram: token.tokenProgram,\n        isPositionBundle: true,\n      });\n    }\n  }\n\n  return positionsOrBundles;\n}\n\n/**\n * Fetches all positions for a given Whirlpool.\n *\n * @param {SolanaRpc} rpc - The Solana RPC client used to fetch positions.\n * @param {Address} whirlpool - The address of the Whirlpool.\n * @returns {Promise<HydratedPosition[]>} - A promise that resolves to an array of hydrated positions.\n *\n * @example\n * import { fetchPositionsInWhirlpool } from '@orca-so/whirlpools';\n * import { createSolanaRpc, devnet, address } from '@solana/web3.js';\n *\n * const devnetRpc = createSolanaRpc(devnet('https://api.devnet.solana.com'));\n *\n * const whirlpool = address(\"Czfq3xZZDmsdGdUyrNLtRhGc47cXcZtLG4crryfu44zE\");\n * const positions = await fetchPositionsInWhirlpool(devnetRpc, whirlpool);\n */\nexport async function fetchPositionsInWhirlpool(\n  rpc: Rpc<GetProgramAccountsApi>,\n  whirlpool: Address,\n): Promise<HydratedPosition[]> {\n  const positions = await fetchAllPositionWithFilter(\n    rpc,\n    positionWhirlpoolFilter(whirlpool),\n  );\n  return positions.map((x) => ({\n    ...x,\n    isPositionBundle: false,\n  }));\n}\n","import type {\n  Account,\n  Address,\n  GetAccountInfoApi,\n  GetEpochInfoApi,\n  GetMinimumBalanceForRentExemptionApi,\n  GetMultipleAccountsApi,\n  IInstruction,\n  Rpc,\n  TransactionSigner,\n} from \"@solana/web3.js\";\nimport { AccountRole, lamports } from \"@solana/web3.js\";\nimport { FUNDER, SLIPPAGE_TOLERANCE_BPS } from \"./config\";\nimport type {\n  ExactInSwapQuote,\n  ExactOutSwapQuote,\n  TickArrayFacade,\n  TransferFee,\n} from \"@orca-so/whirlpools-core\";\nimport {\n  _TICK_ARRAY_SIZE,\n  getTickArrayStartTickIndex,\n  swapQuoteByInputToken,\n  swapQuoteByOutputToken,\n} from \"@orca-so/whirlpools-core\";\nimport type { Whirlpool } from \"@orca-so/whirlpools-client\";\nimport {\n  AccountsType,\n  fetchAllMaybeTickArray,\n  fetchWhirlpool,\n  getOracleAddress,\n  getSwapV2Instruction,\n  getTickArrayAddress,\n} from \"@orca-so/whirlpools-client\";\nimport {\n  getCurrentTransferFee,\n  prepareTokenAccountsInstructions,\n} from \"./token\";\nimport { MEMO_PROGRAM_ADDRESS } from \"@solana-program/memo\";\nimport { fetchAllMint } from \"@solana-program/token-2022\";\n\n// TODO: allow specify number as well as bigint\n// TODO: transfer hook\n\n/**\n * Parameters for an exact input swap.\n */\nexport type ExactInParams = {\n  /** The exact amount of input tokens to be swapped. */\n  inputAmount: bigint;\n};\n\n/**\n * Parameters for an exact output swap.\n */\nexport type ExactOutParams = {\n  /** The exact amount of output tokens to be received from the swap. */\n  outputAmount: bigint;\n};\n\n/**\n * Swap parameters, either for an exact input or exact output swap.\n */\nexport type SwapParams = (ExactInParams | ExactOutParams) & {\n  /** The mint address of the token being swapped. */\n  mint: Address;\n};\n\n/**\n * Swap quote that corresponds to the type of swap being executed (either input or output swap).\n *\n * @template T - The type of swap (input or output).\n */\nexport type SwapQuote<T extends SwapParams> = T extends ExactInParams\n  ? ExactInSwapQuote\n  : ExactOutSwapQuote;\n\n/**\n * Instructions and quote for executing a swap.\n *\n * @template T - The type of swap (input or output).\n */\nexport type SwapInstructions<T extends SwapParams> = {\n  /** The list of instructions needed to perform the swap. */\n  instructions: IInstruction[];\n\n  /** The swap quote, which includes information about the amounts involved in the swap. */\n  quote: SwapQuote<T>;\n};\n\nfunction createUninitializedTickArray(\n  address: Address,\n  startTickIndex: number,\n  programAddress: Address,\n): Account<TickArrayFacade> {\n  return {\n    address,\n    data: {\n      startTickIndex,\n      ticks: Array(_TICK_ARRAY_SIZE()).fill({\n        initialized: false,\n        liquidityNet: 0n,\n        liquidityGross: 0n,\n        feeGrowthOutsideA: 0n,\n        feeGrowthOutsideB: 0n,\n        rewardGrowthsOutside: [0n, 0n, 0n],\n      }),\n    },\n    executable: false,\n    lamports: lamports(0n),\n    programAddress,\n  };\n}\n\nasync function fetchTickArrayOrDefault(\n  rpc: Rpc<GetMultipleAccountsApi>,\n  whirlpool: Account<Whirlpool>,\n): Promise<Account<TickArrayFacade>[]> {\n  const tickArrayStartIndex = getTickArrayStartTickIndex(\n    whirlpool.data.tickCurrentIndex,\n    whirlpool.data.tickSpacing,\n  );\n  const offset = whirlpool.data.tickSpacing * _TICK_ARRAY_SIZE();\n\n  const tickArrayIndexes = [\n    tickArrayStartIndex,\n    tickArrayStartIndex + offset,\n    tickArrayStartIndex + offset * 2,\n    tickArrayStartIndex - offset,\n    tickArrayStartIndex - offset * 2,\n  ];\n\n  const tickArrayAddresses = await Promise.all(\n    tickArrayIndexes.map((startIndex) =>\n      getTickArrayAddress(whirlpool.address, startIndex).then((x) => x[0]),\n    ),\n  );\n\n  const maybeTickArrays = await fetchAllMaybeTickArray(rpc, tickArrayAddresses);\n\n  const tickArrays: Account<TickArrayFacade>[] = [];\n\n  for (let i = 0; i < maybeTickArrays.length; i++) {\n    const maybeTickArray = maybeTickArrays[i];\n    if (maybeTickArray.exists) {\n      tickArrays.push(maybeTickArray);\n    } else {\n      tickArrays.push(\n        createUninitializedTickArray(\n          tickArrayAddresses[i],\n          tickArrayIndexes[i],\n          whirlpool.programAddress,\n        ),\n      );\n    }\n  }\n\n  return tickArrays;\n}\n\nfunction getSwapQuote<T extends SwapParams>(\n  params: T,\n  whirlpool: Whirlpool,\n  transferFeeA: TransferFee | undefined,\n  transferFeeB: TransferFee | undefined,\n  tickArrays: TickArrayFacade[],\n  specifiedTokenA: boolean,\n  slippageToleranceBps: number,\n): SwapQuote<T> {\n  if (\"inputAmount\" in params) {\n    return swapQuoteByInputToken(\n      params.inputAmount,\n      specifiedTokenA,\n      slippageToleranceBps,\n      whirlpool,\n      tickArrays,\n      transferFeeA,\n      transferFeeB,\n    ) as SwapQuote<T>;\n  }\n\n  return swapQuoteByOutputToken(\n    params.outputAmount,\n    specifiedTokenA,\n    slippageToleranceBps,\n    whirlpool,\n    tickArrays,\n    transferFeeA,\n    transferFeeB,\n  ) as SwapQuote<T>;\n}\n\n/**\n * Generates the instructions necessary to execute a token swap in an Orca Whirlpool.\n * It handles both exact input and exact output swaps, fetching the required accounts, tick arrays, and determining the swap quote.\n *\n * @template T - The type of swap (exact input or output).\n * @param {SolanaRpc} rpc - The Solana RPC client.\n * @param {T} params - The swap parameters, specifying either the input or output amount and the mint address of the token being swapped.\n * @param {Address} poolAddress - The address of the Whirlpool against which the swap will be made.\n * @param {number} [slippageToleranceBps=SLIPPAGE_TOLERANCE_BPS] - The maximum acceptable slippage tolerance for the swap, in basis points (BPS).\n * @param {TransactionSigner} [signer=FUNDER] - The wallet or signer executing the swap.\n * @returns {Promise<SwapInstructions<T>>} - A promise that resolves to an object containing the swap instructions and the swap quote.\n *\n * @example\n * import { setWhirlpoolsConfig, swapInstructions } from '@orca-so/whirlpools';\n * import { createSolanaRpc, devnet, address } from '@solana/web3.js';\n * import { loadWallet } from './utils';\n *\n * await setWhirlpoolsConfig('solanaDevnet');\n * const devnetRpc = createSolanaRpc(devnet('https://api.devnet.solana.com'));\n * const wallet = await loadWallet(); // CAUTION: This wallet is not persistent.\n * const whirlpoolAddress = address(\"3KBZiL2g8C7tiJ32hTv5v3KM7aK9htpqTw4cTXz1HvPt\");\n * const mintAddress = address(\"BRjpCHtyQLNCo8gqRUr8jtdAj5AjPYQaoqbvcZiHok1k\");\n * const inputAmount = 1_000_000n;\n *\n * const { instructions, quote } = await swapInstructions(\n *   devnetRpc,\n *   { inputAmount, mint: mintAddress },\n *   whirlpoolAddress,\n *   100,\n *   wallet\n * );\n *\n * console.log(`Quote estimated token out: ${quote.tokenEstOut}`);\n * console.log(`Number of instructions:, ${instructions.length}`);\n */\nexport async function swapInstructions<T extends SwapParams>(\n  rpc: Rpc<\n    GetAccountInfoApi &\n      GetMultipleAccountsApi &\n      GetMinimumBalanceForRentExemptionApi &\n      GetEpochInfoApi\n  >,\n  params: T,\n  poolAddress: Address,\n  slippageToleranceBps: number = SLIPPAGE_TOLERANCE_BPS,\n  signer: TransactionSigner = FUNDER,\n): Promise<SwapInstructions<T>> {\n  const whirlpool = await fetchWhirlpool(rpc, poolAddress);\n  const [tokenA, tokenB] = await fetchAllMint(rpc, [\n    whirlpool.data.tokenMintA,\n    whirlpool.data.tokenMintB,\n  ]);\n  const specifiedTokenA = params.mint === whirlpool.data.tokenMintA;\n  const specifiedInput = \"inputAmount\" in params;\n\n  const tickArrays = await fetchTickArrayOrDefault(rpc, whirlpool);\n\n  const oracleAddress = await getOracleAddress(whirlpool.address).then(\n    (x) => x[0],\n  );\n\n  const currentEpoch = await rpc.getEpochInfo().send();\n  const transferFeeA = getCurrentTransferFee(tokenA, currentEpoch.epoch);\n  const transferFeeB = getCurrentTransferFee(tokenB, currentEpoch.epoch);\n\n  const quote = getSwapQuote<T>(\n    params,\n    whirlpool.data,\n    transferFeeA,\n    transferFeeB,\n    tickArrays.map((x) => x.data),\n    specifiedTokenA,\n    slippageToleranceBps,\n  );\n  const maxInAmount = \"tokenIn\" in quote ? quote.tokenIn : quote.tokenMaxIn;\n  const aToB = specifiedTokenA === specifiedInput;\n\n  const { createInstructions, cleanupInstructions, tokenAccountAddresses } =\n    await prepareTokenAccountsInstructions(rpc, signer, {\n      [whirlpool.data.tokenMintA]: aToB ? maxInAmount : 0n,\n      [whirlpool.data.tokenMintB]: aToB ? 0n : maxInAmount,\n    });\n\n  const instructions: IInstruction[] = [];\n\n  instructions.push(...createInstructions);\n\n  const specifiedAmount =\n    \"inputAmount\" in params ? params.inputAmount : params.outputAmount;\n  const otherAmountThreshold =\n    \"tokenMaxIn\" in quote ? quote.tokenMaxIn : quote.tokenMinOut;\n\n  const swapInstruction = getSwapV2Instruction({\n    tokenProgramA: tokenA.programAddress,\n    tokenProgramB: tokenB.programAddress,\n    memoProgram: MEMO_PROGRAM_ADDRESS,\n    tokenAuthority: signer,\n    whirlpool: whirlpool.address,\n    tokenMintA: whirlpool.data.tokenMintA,\n    tokenMintB: whirlpool.data.tokenMintB,\n    tokenOwnerAccountA: tokenAccountAddresses[whirlpool.data.tokenMintA],\n    tokenOwnerAccountB: tokenAccountAddresses[whirlpool.data.tokenMintB],\n    tokenVaultA: whirlpool.data.tokenVaultA,\n    tokenVaultB: whirlpool.data.tokenVaultB,\n    tickArray0: tickArrays[0].address,\n    tickArray1: tickArrays[1].address,\n    tickArray2: tickArrays[2].address,\n    amount: specifiedAmount,\n    otherAmountThreshold,\n    sqrtPriceLimit: 0,\n    amountSpecifiedIsInput: specifiedInput,\n    aToB,\n    oracle: oracleAddress,\n    remainingAccountsInfo: {\n      slices: [\n        { accountsType: AccountsType.SupplementalTickArrays, length: 2 },\n      ],\n    },\n  });\n\n  swapInstruction.accounts.push(\n    { address: tickArrays[3].address, role: AccountRole.WRITABLE },\n    { address: tickArrays[4].address, role: AccountRole.WRITABLE },\n  );\n\n  instructions.push(swapInstruction);\n  instructions.push(...cleanupInstructions);\n\n  return {\n    quote,\n    instructions,\n  };\n}\n"],"mappings":"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","names":["generateKeyPairSigner","lamports","SolanaError","alphabet","alphabet","createEncoder","TextDecoder","TextEncoder","address","address","SolanaError","createDecoder","SolanaError","address","getStructDecoder","getDefaultLamportsDecoder","assertAccountExists","decodeAccount","fetchAllMint","assert","address","lamports","address","lamports","assert","fetchAllMint","generateKeyPairSigner","x","lamports","getTickArrayAddress","getTickArrayStartTickIndex","findAssociatedTokenPda","TOKEN_PROGRAM_ADDRESS","fetchAllMint","assert","getTickArrayStartTickIndex","findAssociatedTokenPda","getTickArrayAddress","TOKEN_PROGRAM_ADDRESS","collectFeesQuote","collectRewardsQuote","getTickArrayStartTickIndex","getTickIndexInArray","fetchAllTickArray","fetchPosition","fetchWhirlpool","getCollectFeesV2Instruction","getCollectRewardV2Instruction","getPositionAddress","getTickArrayAddress","findAssociatedTokenPda","fetchAllMaybeMint","MEMO_PROGRAM_ADDRESS","assert","getPositionAddress","fetchPosition","fetchWhirlpool","getTickArrayStartTickIndex","findAssociatedTokenPda","getTickArrayAddress","fetchAllTickArray","getTickIndexInArray","collectFeesQuote","collectRewardsQuote","getCollectFeesV2Instruction","getCollectRewardV2Instruction","fetchPosition","fetchWhirlpool","getInitializeTickArrayInstruction","getPositionAddress","getTickArrayAddress","getTickArraySize","getFullRangeTickIndexes","getTickArrayStartTickIndex","address","generateKeyPairSigner","lamports","findAssociatedTokenPda","fetchAllMint","TOKEN_2022_PROGRAM_ADDRESS","MEMO_PROGRAM_ADDRESS","assert","assert","getPositionAddress","fetchPosition","fetchWhirlpool","fetchAllMint","getTickArrayStartTickIndex","findAssociatedTokenPda","getTickArrayAddress","MEMO_PROGRAM_ADDRESS","generateKeyPairSigner","TOKEN_2022_PROGRAM_ADDRESS","getInitializeTickArrayInstruction","getTickArraySize","address","lamports","getFullRangeTickIndexes","getFeeTierAddress","getWhirlpoolAddress","fetchAllMint","getFeeTierAddress","getWhirlpoolAddress","x","getPositionAddress","TOKEN_PROGRAM_ADDRESS","TOKEN_2022_PROGRAM_ADDRESS","getBase64Encoder","x","positions","lamports","getTickArrayStartTickIndex","fetchAllMaybeTickArray","fetchWhirlpool","getTickArrayAddress","MEMO_PROGRAM_ADDRESS","fetchAllMint","address","lamports","getTickArrayStartTickIndex","getTickArrayAddress","fetchAllMaybeTickArray","fetchWhirlpool"]}